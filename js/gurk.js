// Generated by CoffeeScript 2.7.0
(function() {
  var AlertView, App, BasicStrategy, Button, ButtonGrid, CharacterInfoView, CharacterRollView, ChooseCharacterView, CombatView, Combatant, CombatantView, ConfirmView, CreateView, Creature, Device, FlowView, Font, Game, GearView, Gurk, ImageProcessor, InfoView, Item, ItemInfoView, ItemView, LevelUpView, Library, MapView, PartyView, Player, PlayerDialog, PlayerView, Preloader, QuestView, Screen, SelectView, SettingsView, SpellInfoView, SpellView, SplashView, Test, TileView, Util, Validate, View,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Device = (function() {
    class Device {
      static hasSavedGame() {
        return !!getData(Device.SAVE_KEY);
      }

      static saveGame(game) {
        return putData(Device.SAVE_KEY, game);
      }

      static loadGame() {
        return getData(Device.SAVE_KEY);
      }

      static clearGame() {
        return putData(Device.SAVE_KEY, null);
      }

      static getSetting(name, defaultValue) {
        var key;
        key = Device.SETTINGS_KEY + name;
        if (!!getData(key)) {
          if (getData(key) === "false") {
            return false;
          } else {
            return true;
          }
        } else {
          return defaultValue;
        }
      }

      static setSetting(name, value) {
        var key;
        key = Device.SETTINGS_KEY + name;
        return putData(key, value);
      }

    };

    Device.SAVE_KEY = "_GurkSavedGame";

    Device.SETTINGS_KEY = "_GurkSetting_";

    return Device;

  }).call(this);

  Util = class Util {
    static random(min, max) {
      var diff;
      diff = max - min + 1;
      return Math.floor(Math.random() * diff) + min;
    }

    static randomChance(num, den) {
      return Math.random() * den < num;
    }

    static randomElement(array) {
      var n, x;
      n = array.length;
      x = Util.random(0, n - 1);
      return array[x];
    }

    static isEmpty(object) {
      var x, y;
      for (x in object) {
        y = object[x];
        return false;
      }
      return true;
    }

    static statRoll() {
      return Util.random(1, 6) + Util.random(1, 6) + Util.random(1, 6);
    }

    static shuffle(a) {
      var b, c, d;
      b = a.length;
      while (b) {
        c = Math.floor(Math.random() * b);
        d = a[--b];
        a[b] = a[c];
        a[c] = d;
      }
      return a;
    }

    static hasAllProperties(obj, properties) {
      var a, l, len;
      if (properties instanceof Array) {
        for (l = 0, len = properties.length; l < len; l++) {
          a = properties[l];
          if (!obj[a]) {
            return false;
          }
        }
      } else {
        if (!obj[properties]) {
          return false;
        }
      }
      return true;
    }

    static hasCommonElements(array1, array2) {
      var a, b, l, len, len1, o;
      array1 = [].concat(array1);
      array2 = [].concat(array2);
      for (l = 0, len = array1.length; l < len; l++) {
        a = array1[l];
        for (o = 0, len1 = array2.length; o < len1; o++) {
          b = array2[o];
          if (a === b) {
            return true;
          }
        }
      }
      return false;
    }

    static hasElement(array, element) {
      var a, l, len;
      for (l = 0, len = array.length; l < len; l++) {
        a = array[l];
        if (a === element) {
          return true;
        }
      }
      return false;
    }

    static indexOfElement(array, element) {
      var a, index, l, len;
      index = 0;
      for (l = 0, len = array.length; l < len; l++) {
        a = array[l];
        if (a === element) {
          return index;
        }
        index++;
      }
      return -1;
    }

    static trunc(x) {
      return x | 0;
    }

    static create2DArray(width, height) {
      var a, b, l, o, ref, ref1, x, y;
      a = [];
      for (y = l = 0, ref = height; (0 <= ref ? l < ref : l > ref); y = 0 <= ref ? ++l : --l) {
        b = [];
        a.push(b);
        for (x = o = 0, ref1 = width; (0 <= ref1 ? o < ref1 : o > ref1); x = 0 <= ref1 ? ++o : --o) {
          b.push([]);
        }
      }
      return a;
    }

    static removeElement(array, element) {
      var a, index, l, len;
      index = 0;
      for (l = 0, len = array.length; l < len; l++) {
        a = array[l];
        if (a === element) {
          array.splice(index, 1);
          return true;
        }
        index++;
      }
      return false;
    }

    static copyProperties(source, dest) {
      var k, results1, v;
      results1 = [];
      for (k in source) {
        v = source[k];
        results1.push(dest[k] = v);
      }
      return results1;
    }

    static rgb(red, green, blue) {
      return {
        "red": red,
        "green": green,
        "blue": blue
      };
    }

    static blendColors(color1, color2, p1, p2) {
      var blue, green, red;
      red = Math.round(color1.red * p1 + color2.red * p2);
      green = Math.round(color1.green * p1 + color2.green * p2);
      blue = Math.round(color1.blue * p1 + color2.blue * p2);
      return {
        "red": red,
        "green": green,
        "blue": blue
      };
    }

    static capitalize(word) {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }

    static arrayToString(array) {
      var first, item, l, len, text;
      if (!array || array.length === 0) {
        return null;
      } else {
        first = true;
        text = "";
        for (l = 0, len = array.length; l < len; l++) {
          item = array[l];
          if (first) {
            text += item;
            first = false;
          } else {
            text += ", " + item;
          }
        }
        return text;
      }
    }

  };

  Preloader = (function() {
    // -----------------------------------------------------------------------------
    class Preloader {
      static reset() {
        Preloader.addedCount = 0;
        return Preloader.loadedCount = 0;
      }

      static imageLoaded() {
        Preloader.loadedCount++;
        console.log(`Preloading loading finished: ${Preloader.loadedCount}/${Preloader.addedCount} done.`);
        if (Preloader.loadedCount + 1 === Preloader.addedCount && Preloader.callback) {
          console.log("Preloading calling back.");
          return Preloader.callback();
        }
      }

      static load(src) {
        var item;
        console.log(`Loading '${src}'`);
        if (!Preloader.images[src]) {
          Preloader.addedCount++;
          console.log(`Add count now ${Preloader.addedCount}`);
          item = new Image();
          Preloader.images[src] = item;
          item.onload = Preloader.imageLoaded;
          item.src = src;
          return item;
        } else {
          console.log("Already loaded.");
          return Preloader.images[src];
        }
      }

      static setCallback(callback) {
        console.log("Preloader callback set.");
        Preloader.callback = callback;
        if (Preloader.loadedCount === Preloader.addedCount) {
          return callback();
        }
      }

      static getImage(src) {
        var item;
        item = Preloader.images[src];
        if (!item) {
          item = Preloader.load(src);
        }
        return item;
      }

    };

    Preloader.images = null;

    Preloader.loadedCount = 0;

    Preloader.addedCount = 0;

    Preloader.images = {};

    Preloader.callback = null;

    return Preloader;

  }).call(this);

  Font = (function() {
    // -----------------------------------------------------------------------------
    class Font {
      constructor(glyphMap, imageSrc) {
        this.drawChar = this.drawChar.bind(this);
        this.drawText = this.drawText.bind(this);
        this.getWidth = this.getWidth.bind(this);
        this.centerText = this.centerText.bind(this);
        this.wrapText = this.wrapText.bind(this);
        this.glyphMap = glyphMap;
        this.image = Preloader.getImage(imageSrc);
        this.fontHeight = this.glyphMap['A'].height;
      }

      drawChar(ctx, c, x, y) {
        var glyph, xx, yy;
        glyph = this.glyphMap[c];
        xx = x * Screen.SCALE;
        yy = y * Screen.SCALE;
        ctx.drawImage(this.image, Screen.SCALE * glyph.x, Screen.SCALE * glyph.y, Screen.SCALE * glyph.width, Screen.SCALE * glyph.height, xx, yy, Screen.SCALE * glyph.width, Screen.SCALE * glyph.height);
        return glyph.width;
      }

      drawText(ctx, text, color, x, y) {
        var i, l, n, o, ref, ref1, width;
        n = text.length;
        width = 0;
        for (i = l = 0, ref = n; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          width += this.glyphMap[text.charAt(i)].width;
        }
        ctx.fillStyle = color;
        ctx.fillRect(x * Screen.SCALE, y * Screen.SCALE, width * Screen.SCALE, this.fontHeight * Screen.SCALE);
        for (i = o = 0, ref1 = n; (0 <= ref1 ? o < ref1 : o > ref1); i = 0 <= ref1 ? ++o : --o) {
          x += this.drawChar(ctx, text.charAt(i), x, y);
        }
        return text;
      }

      getWidth(text) {
        var i, l, n, ref, width;
        n = text.length;
        width = 0;
        for (i = l = 0, ref = n; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          width += this.glyphMap[text.charAt(i)].width;
        }
        return width;
      }

      centerText(ctx, text, color, x, y, w, h) {
        var offsetX, offsetY, width;
        width = this.getWidth(text);
        offsetX = Math.floor((w - width) / 2);
        offsetY = Math.floor((h - this.fontHeight) / 2);
        return this.drawText(ctx, text, color, x + offsetX, y + offsetY);
      }

      wrapText(ctx, text, color, x, y, width) {
        var breakLine, c, force, i, last, line, n, newLine, start, totalLines, w;
        n = text.length;
        start = 0;
        last = 0;
        i = 0;
        w = 0;
        totalLines = 1;
        while (i < n) {
          breakLine = false;
          force = false;
          newLine = false;
          c = text.charAt(i);
          if (c === ' ') {
            last = i;
          } else if (c === '\n') {
            last = i;
            breakLine = true;
            newLine = true;
          }
          if (!breakLine) {
            w += this.glyphMap[text.charAt(i)].width;
            if (w > width) {
              breakLine = true;
            }
          }
          if (breakLine) {
            if (last === start && !newLine) {
              last = i;
              force = true;
            }
            line = text.substring(start, last);
            this.drawText(ctx, line, color, x, y);
            y += this.fontHeight;
            totalLines++;
            if (force) {
              start = last;
            } else {
              start = last + 1;
            }
            last = start;
            i = start;
            w = 0;
          } else {
            i++;
          }
        }
        if (start < n - 1) {
          line = text.substring(start);
          this.drawText(ctx, line, color, x, y);
        }
        return totalLines * this.fontHeight;
      }

    };

    Font.prototype.image = null;

    Font.prototype.fontHeight = 0;

    return Font;

  }).call(this);

  Screen = (function() {
    // -----------------------------------------------------------------------------
    class Screen {
      constructor(ctx1) {
        this.clear = this.clear.bind(this);
        this.clearColor = this.clearColor.bind(this);
        this.drawScreen = this.drawScreen.bind(this);
        this.drawIcon = this.drawIcon.bind(this);
        this.drawImage = this.drawImage.bind(this);
        this.drawAnim = this.drawAnim.bind(this);
        this.drawCustomAnim = this.drawCustomAnim.bind(this);
        this.drawText = this.drawText.bind(this);
        this.drawTextCentered = this.drawTextCentered.bind(this);
        this.wrapText = this.wrapText.bind(this);
        this.setAlpha = this.setAlpha.bind(this);
        this.drawPixel = this.drawPixel.bind(this);
        this.fillRect = this.fillRect.bind(this);
        this.ctx = ctx1;
        Screen.FONT = new Font(Screen.MICRO_GLYPHS, "img/font_micro" + Screen.SCALE + ".png");
        this.icons = [Preloader.getImage("img/icons0-" + Screen.SCALE + ".png"), Preloader.getImage("img/icons1-" + Screen.SCALE + ".png")];
        this.screen = Preloader.getImage("img/screen" + Screen.SCALE + ".png");
        Screen.CENTER_OFFSET = Math.floor(Screen.WIN_SIZE / 2);
      }

      clear() {
        return this.clearColor("#000");
      }

      clearColor(color) {
        this.ctx.fillStyle = color;
        return this.ctx.fillRect(0, 0, Screen.WIN_SIZE * Screen.UNIT * Screen.SCALE, Screen.WIN_SIZE * Screen.UNIT * Screen.SCALE);
      }

      drawScreen() {
        return this.ctx.drawImage(this.screen, 0, 0);
      }

      drawIcon(icon, x, y) {
        var coords, k;
        coords = Icons[icon];
        k = Screen.UNIT * Screen.SCALE;
        return this.ctx.drawImage(this.icons[coords.block], k * coords.x, k * coords.y, k, k, x * Screen.SCALE, y * Screen.SCALE, k, k);
      }

      drawImage(image, x, y) {
        return this.ctx.drawImage(image, x * Screen.SCALE, y * Screen.SCALE);
      }

      drawAnim(anim, x, y, frame) {
        var coords, i, ix, iy, k, l, m, ref;
        coords = Icons[anim];
        ix = coords.x;
        iy = coords.y;
        k = Screen.UNIT * Screen.SCALE;
        m = this.icons[coords.block].width / k;
        for (i = l = 0, ref = frame; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          ix++;
          if (ix === m) {
            ix = 0;
            iy++;
          }
        }
        return this.ctx.drawImage(this.icons[coords.block], k * ix, k * iy, k, k, x * Screen.SCALE, y * Screen.SCALE, k, k);
      }

      drawCustomAnim(custom, x, y) {
        var k;
        k = Screen.UNIT * Screen.SCALE;
        return this.ctx.drawImage(custom, (x - 2) * Screen.SCALE, (y - 2) * Screen.SCALE);
      }

      drawText(text, color, x, y) {
        return Screen.FONT.drawText(this.ctx, text, color, x, y);
      }

      drawTextCentered(text, color, x, y, width, height) {
        return Screen.FONT.centerText(this.ctx, text, color, x, y, width, height);
      }

      wrapText(text, color, x, y, width) {
        return Screen.FONT.wrapText(this.ctx, text, color, x, y, width);
      }

      setAlpha(alpha) {
        return this.ctx.globalAlpha = alpha;
      }

      drawPixel(color, x, y) {
        this.ctx.fillStyle = color;
        return this.ctx.fillRect(x * Screen.SCALE, y * Screen.SCALE, Screen.SCALE, Screen.SCALE);
      }

      fillRect(color, x, y, width, height) {
        this.ctx.fillStyle = color;
        return this.ctx.fillRect(x * Screen.SCALE, y * Screen.SCALE, width * Screen.SCALE, height * Screen.SCALE);
      }

    };

    Screen.SCALE = pixelWidth;

    Screen.SIZE = 128;

    Screen.GURK_BLUE = "#004c62";

    Screen.UNIT = 16;

    Screen.HALF_UNIT = Screen.UNIT / 2;

    Screen.WIN_SIZE = 9;

    Screen.CENTER_OFFSET = 0;

    Screen.ICONS_PER_ROW = 7;

    Screen.prototype.icons = null;

    Screen.prototype.screen = null;

    Screen.MICRO_GLYPHS = {
      'A': {
        x: 0,
        y: 0,
        width: 5,
        height: 8
      },
      'B': {
        x: 5,
        y: 0,
        width: 5,
        height: 8
      },
      'C': {
        x: 10,
        y: 0,
        width: 4,
        height: 8
      },
      'D': {
        x: 14,
        y: 0,
        width: 5,
        height: 8
      },
      'E': {
        x: 19,
        y: 0,
        width: 4,
        height: 8
      },
      'F': {
        x: 23,
        y: 0,
        width: 4,
        height: 8
      },
      'G': {
        x: 27,
        y: 0,
        width: 5,
        height: 8
      },
      'H': {
        x: 32,
        y: 0,
        width: 5,
        height: 8
      },
      'I': {
        x: 37,
        y: 0,
        width: 4,
        height: 8
      },
      'J': {
        x: 41,
        y: 0,
        width: 5,
        height: 8
      },
      'K': {
        x: 46,
        y: 0,
        width: 5,
        height: 8
      },
      'L': {
        x: 51,
        y: 0,
        width: 4,
        height: 8
      },
      'M': {
        x: 55,
        y: 0,
        width: 6,
        height: 8
      },
      'N': {
        x: 61,
        y: 0,
        width: 5,
        height: 8
      },
      'O': {
        x: 66,
        y: 0,
        width: 5,
        height: 8
      },
      'P': {
        x: 71,
        y: 0,
        width: 5,
        height: 8
      },
      'Q': {
        x: 76,
        y: 0,
        width: 5,
        height: 8
      },
      'R': {
        x: 81,
        y: 0,
        width: 5,
        height: 8
      },
      'S': {
        x: 86,
        y: 0,
        width: 5,
        height: 8
      },
      'T': {
        x: 91,
        y: 0,
        width: 4,
        height: 8
      },
      'U': {
        x: 95,
        y: 0,
        width: 5,
        height: 8
      },
      'V': {
        x: 100,
        y: 0,
        width: 5,
        height: 8
      },
      'W': {
        x: 105,
        y: 0,
        width: 6,
        height: 8
      },
      'X': {
        x: 111,
        y: 0,
        width: 5,
        height: 8
      },
      'Y': {
        x: 116,
        y: 0,
        width: 5,
        height: 8
      },
      'Z': {
        x: 121,
        y: 0,
        width: 4,
        height: 8
      },
      'a': {
        x: 0,
        y: 8,
        width: 5,
        height: 8
      },
      'b': {
        x: 5,
        y: 8,
        width: 5,
        height: 8
      },
      'c': {
        x: 10,
        y: 8,
        width: 4,
        height: 8
      },
      'd': {
        x: 14,
        y: 8,
        width: 5,
        height: 8
      },
      'e': {
        x: 19,
        y: 8,
        width: 5,
        height: 8
      },
      'f': {
        x: 24,
        y: 8,
        width: 4,
        height: 8
      },
      'g': {
        x: 28,
        y: 8,
        width: 5,
        height: 8
      },
      'h': {
        x: 33,
        y: 8,
        width: 5,
        height: 8
      },
      'i': {
        x: 38,
        y: 8,
        width: 2,
        height: 8
      },
      'j': {
        x: 40,
        y: 8,
        width: 3,
        height: 8
      },
      'k': {
        x: 43,
        y: 8,
        width: 5,
        height: 8
      },
      'l': {
        x: 48,
        y: 8,
        width: 2,
        height: 8
      },
      'm': {
        x: 50,
        y: 8,
        width: 6,
        height: 8
      },
      'n': {
        x: 56,
        y: 8,
        width: 5,
        height: 8
      },
      'o': {
        x: 61,
        y: 8,
        width: 5,
        height: 8
      },
      'p': {
        x: 66,
        y: 8,
        width: 5,
        height: 8
      },
      'q': {
        x: 71,
        y: 8,
        width: 5,
        height: 8
      },
      'r': {
        x: 76,
        y: 8,
        width: 4,
        height: 8
      },
      's': {
        x: 80,
        y: 8,
        width: 5,
        height: 8
      },
      't': {
        x: 85,
        y: 8,
        width: 4,
        height: 8
      },
      'u': {
        x: 89,
        y: 8,
        width: 5,
        height: 8
      },
      'v': {
        x: 94,
        y: 8,
        width: 5,
        height: 8
      },
      'w': {
        x: 99,
        y: 8,
        width: 6,
        height: 8
      },
      'x': {
        x: 105,
        y: 8,
        width: 4,
        height: 8
      },
      'y': {
        x: 109,
        y: 8,
        width: 5,
        height: 8
      },
      'z': {
        x: 114,
        y: 8,
        width: 5,
        height: 8
      },
      '#': {
        x: 119,
        y: 8,
        width: 6,
        height: 8
      },
      '1': {
        x: 0,
        y: 17,
        width: 3,
        height: 8
      },
      '2': {
        x: 3,
        y: 17,
        width: 5,
        height: 8
      },
      '3': {
        x: 8,
        y: 17,
        width: 5,
        height: 8
      },
      '4': {
        x: 13,
        y: 17,
        width: 5,
        height: 8
      },
      '5': {
        x: 18,
        y: 17,
        width: 5,
        height: 8
      },
      '6': {
        x: 23,
        y: 17,
        width: 5,
        height: 8
      },
      '7': {
        x: 28,
        y: 17,
        width: 5,
        height: 8
      },
      '8': {
        x: 33,
        y: 17,
        width: 5,
        height: 8
      },
      '9': {
        x: 38,
        y: 17,
        width: 5,
        height: 8
      },
      '0': {
        x: 43,
        y: 17,
        width: 5,
        height: 8
      },
      ',': {
        x: 48,
        y: 17,
        width: 3,
        height: 8
      },
      '.': {
        x: 51,
        y: 17,
        width: 2,
        height: 8
      },
      '?': {
        x: 53,
        y: 17,
        width: 5,
        height: 8
      },
      '!': {
        x: 58,
        y: 17,
        width: 2,
        height: 8
      },
      "'": {
        x: 60,
        y: 17,
        width: 2,
        height: 8
      },
      '"': {
        x: 65,
        y: 17,
        width: 4,
        height: 8
      },
      '/': {
        x: 69,
        y: 17,
        width: 6,
        height: 8
      },
      '(': {
        x: 81,
        y: 17,
        width: 3,
        height: 8
      },
      ')': {
        x: 84,
        y: 17,
        width: 3,
        height: 8
      },
      '[': {
        x: 87,
        y: 17,
        width: 3,
        height: 8
      },
      ']': {
        x: 90,
        y: 17,
        width: 3,
        height: 8
      },
      ':': {
        x: 103,
        y: 17,
        width: 2,
        height: 8
      },
      '-': {
        x: 105,
        y: 17,
        width: 4,
        height: 8
      },
      '*': {
        x: 109,
        y: 17,
        width: 4,
        height: 8
      },
      '+': {
        x: 114,
        y: 17,
        width: 4,
        height: 8
      },
      ' ': {
        x: 122,
        y: 17,
        width: 4,
        height: 8
      },
      '~': {
        x: 0,
        y: 25,
        width: 10,
        height: 8 // Move icon
      },
      '`': {
        x: 10,
        y: 25,
        width: 6,
        height: 8 // Attack icon
      },
      '=': {
        x: 16,
        y: 25,
        width: 4,
        height: 8 // Full spell
      },
      '|': {
        x: 20,
        y: 25,
        width: 4,
        height: 8 // Half spell
      }
    };

    Screen.FONT = null;

    return Screen;

  }).call(this);

  Button = (function() {
    // -----------------------------------------------------------------------------
    class Button {
      constructor(index1, x3, y3) {
        this.draw = this.draw.bind(this);
        this.enable = this.enable.bind(this);
        this.disable = this.disable.bind(this);
        this.isEnabled = this.isEnabled.bind(this);
        this.setText = this.setText.bind(this);
        this.index = index1;
        this.x = x3;
        this.y = y3;
        this.text = "BLAM";
      }

      draw(ctx) {
        var image;
        image = this.buttonOn ? ButtonGrid.onImage : ButtonGrid.offImage;
        ctx.drawImage(image, Screen.SCALE * this.x, Screen.SCALE * this.y);
        if (this.buttonOn) {
          ButtonGrid.FONT.centerText(ctx, this.text, "transparent", this.x + 1, this.y, ButtonGrid.BUTTON_WIDTH, ButtonGrid.BUTTON_HEIGHT);
        }
        ctx.drawImage(ButtonGrid.topImage, Screen.SCALE * this.x, Screen.SCALE * this.y);
        return false;
      }

      enable() {
        return this.buttonOn = true;
      }

      disable() {
        return this.buttonOn = false;
      }

      isEnabled() {
        return this.buttonOn;
      }

      setText(text) {
        return this.text = text;
      }

    };

    Button.prototype.buttonOn = false;

    Button.prototype.text = null;

    return Button;

  }).call(this);

  ButtonGrid = (function() {
    class ButtonGrid {
      constructor(ctx1, gurk1) {
        var index, l, o, x, xx, y, yy;
        this.draw = this.draw.bind(this);
        this.clicked = this.clicked.bind(this);
        this.getButtonByKeyNum = this.getButtonByKeyNum.bind(this);
        this.forceClick = this.forceClick.bind(this);
        this.clear = this.clear.bind(this);
        this.enableMovement = this.enableMovement.bind(this);
        // 1 2 3
        // 4 5 6
        // 7 8 9
        this.setButton = this.setButton.bind(this);
        this.setButtonByPosition = this.setButtonByPosition.bind(this);
        this.disableButtonByPosition = this.disableButtonByPosition.bind(this);
        this.ctx = ctx1;
        this.gurk = gurk1;
        ButtonGrid.FONT = new Font(ButtonGrid.GURKOID_GLYPHS, "img/font_gurkoid" + Screen.SCALE + ".png");
        ButtonGrid.onImage = Preloader.getImage("img/button" + Screen.SCALE + ".png");
        ButtonGrid.offImage = Preloader.getImage("img/buttonoff" + Screen.SCALE + ".png");
        ButtonGrid.topImage = Preloader.getImage("img/buttontop" + Screen.SCALE + ".png");
        //gapWidth = (ButtonGrid.GRID_WIDTH - 3 * ButtonGrid.BUTTON_WIDTH) / 4
        //gapHeight = (ButtonGrid.GRID_HEIGHT - 3 * ButtonGrid.BUTTON_HEIGHT) / 2
        index = 1;
        yy = GAP_Y;
        this.buttons = new Array(3);
        for (y = l = 0; l <= 2; y = ++l) {
          this.buttons[y] = new Array(3);
          xx = GAP_X;
          for (x = o = 0; o <= 2; x = ++o) {
            this.buttons[y][x] = new Button(index, xx, yy);
            index++;
            xx += ButtonGrid.BUTTON_WIDTH + GAP_X;
          }
          yy += GAP_Y + ButtonGrid.BUTTON_HEIGHT;
        }
        // Set up and enable the directional arrows
        this.enableMovement();
        false;
      }

      draw() {
        var f;
        f = () => {
          var l, results1, x, y;
          this.ctx.clearRect(0, 0, Screen.SCALE * GRID_WIDTH, Screen.SCALE * GRID_HEIGHT);
          results1 = [];
          for (y = l = 0; l <= 2; y = ++l) {
            results1.push((function() {
              var o, results2;
              results2 = [];
              for (x = o = 0; o <= 2; x = ++o) {
                results2.push(this.buttons[y][x].draw(this.ctx));
              }
              return results2;
            }).call(this));
          }
          return results1;
        };
        f();
        if (drawHack) {
          setTimeout(f, 50);
        }
        return false;
      }

      clicked(e) {
        var button, x, y;
        //console.log("e.x: " + e.x + ", e.y: " + e.y)
        // todo - dead zones between buttons?
        x = Math.floor(e.x * 3 / Screen.SCALE / GRID_WIDTH);
        y = Math.floor(e.y * 3 / Screen.SCALE / GRID_HEIGHT);
        //console.log("X: " + x + ", Y: " + y)
        // if @buttons[y][x].isEnabled() then @buttons[y][x].disable() else @buttons[y][x].enable()
        // @draw()
        button = this.buttons[y][x];
        if (button.buttonOn) {
          return this.gurk.buttonPressed(this.buttons[y][x].text);
        }
      }

      getButtonByKeyNum(keyNum) {
        var x, y;
        keyNum--;
        y = Math.floor(keyNum / 3);
        x = keyNum % 3;
        return this.buttons[y][x];
      }

      forceClick(keyNum) {
        var button;
        button = this.getButtonByKeyNum(keyNum);
        if (button.buttonOn) {
          return this.gurk.buttonPressed(button.text);
        }
      }

      clear() {
        var l, o, x, y;
        for (y = l = 0; l <= 2; y = ++l) {
          for (x = o = 0; o <= 2; x = ++o) {
            this.buttons[y][x].disable();
          }
        }
        return this.draw();
      }

      enableMovement() {
        this.buttons[1][0].enable();
        this.buttons[1][0].setText("1");
        this.buttons[0][1].enable();
        this.buttons[0][1].setText("2");
        this.buttons[1][2].enable();
        this.buttons[1][2].setText("3");
        this.buttons[2][1].enable();
        this.buttons[2][1].setText("4");
        return this.draw();
      }

      setButton(keyNum, text) {
        var button;
        button = this.getButtonByKeyNum(keyNum);
        button.setText(text);
        button.enable();
        return this.draw();
      }

      setButtonByPosition(x, y, text) {
        var button;
        button = this.buttons[y][x];
        button.setText(text);
        button.enable();
        return this.draw();
      }

      disableButtonByPosition(x, y) {
        var button;
        button = this.buttons[y][x];
        button.disable();
        return this.draw();
      }

    };

    ButtonGrid.GURKOID_GLYPHS = {
      'A': {
        x: 1,
        y: 1,
        width: 5,
        height: 9
      },
      'B': {
        x: 6,
        y: 1,
        width: 5,
        height: 9
      },
      'C': {
        x: 11,
        y: 1,
        width: 5,
        height: 9
      },
      'D': {
        x: 16,
        y: 1,
        width: 5,
        height: 9
      },
      'E': {
        x: 21,
        y: 1,
        width: 4,
        height: 9
      },
      'F': {
        x: 25,
        y: 1,
        width: 4,
        height: 9
      },
      'G': {
        x: 29,
        y: 1,
        width: 5,
        height: 9
      },
      'H': {
        x: 34,
        y: 1,
        width: 5,
        height: 9
      },
      'I': {
        x: 39,
        y: 1,
        width: 4,
        height: 9
      },
      'J': {
        x: 43,
        y: 1,
        width: 4,
        height: 9
      },
      'K': {
        x: 47,
        y: 1,
        width: 5,
        height: 9
      },
      'L': {
        x: 52,
        y: 1,
        width: 5,
        height: 9
      },
      'M': {
        x: 57,
        y: 1,
        width: 6,
        height: 9
      },
      'N': {
        x: 63,
        y: 1,
        width: 6,
        height: 9
      },
      'O': {
        x: 69,
        y: 1,
        width: 5,
        height: 9
      },
      'P': {
        x: 74,
        y: 1,
        width: 5,
        height: 9
      },
      'Q': {
        x: 79,
        y: 1,
        width: 5,
        height: 9
      },
      'R': {
        x: 84,
        y: 1,
        width: 5,
        height: 9
      },
      'S': {
        x: 89,
        y: 1,
        width: 5,
        height: 9
      },
      'T': {
        x: 94,
        y: 1,
        width: 6,
        height: 9
      },
      'U': {
        x: 100,
        y: 1,
        width: 5,
        height: 9
      },
      'V': {
        x: 105,
        y: 1,
        width: 5,
        height: 9
      },
      'W': {
        x: 110,
        y: 1,
        width: 6,
        height: 9
      },
      'X': {
        x: 116,
        y: 1,
        width: 6,
        height: 9
      },
      'Y': {
        x: 122,
        y: 1,
        width: 6,
        height: 9
      },
      'Z': {
        x: 128,
        y: 1,
        width: 5,
        height: 9
      },
      '1': {
        x: 133,
        y: 1,
        width: 8,
        height: 9
      },
      '2': {
        x: 141,
        y: 1,
        width: 10,
        height: 9
      },
      '3': {
        x: 151,
        y: 1,
        width: 8,
        height: 9
      },
      '4': {
        x: 159,
        y: 1,
        width: 10,
        height: 9
      },
      '/': {
        x: 169,
        y: 1,
        width: 2,
        height: 9
      },
      '.': {
        x: 171,
        y: 1,
        width: 2,
        height: 9
      },
      ' ': {
        x: 173,
        y: 1,
        width: 4,
        height: 9
      }
    };

    //@GRID_WIDTH : 160
    //@GRID_HEIGHT : 85
    ButtonGrid.BUTTON_WIDTH = 45;

    ButtonGrid.BUTTON_HEIGHT = 23;

    ButtonGrid.FONT = null;

    ButtonGrid.onImage = null;

    ButtonGrid.offImage = null;

    ButtonGrid.topImage = null;

    ButtonGrid.prototype.buttons = null;

    return ButtonGrid;

  }).call(this);

  View = (function() {
    // -----------------------------------------------------------------------------
    class View {
      constructor(screen, gurk1) {
        var l, o, x, y;
        this.processResult = this.processResult.bind(this);
        // no-op, override to do something
        this.draw = this.draw.bind(this);
        this.doDraw = this.doDraw.bind(this);
        this.doLayout = this.doLayout.bind(this);
        this.command = this.command.bind(this);
        // no-op
        this.setButtons = this.setButtons.bind(this);
        this.enableMovement = this.enableMovement.bind(this);
        this.clearButton = this.clearButton.bind(this);
        this.clearAllButtons = this.clearAllButtons.bind(this);
        this.setButton = this.setButton.bind(this);
        this.getTextWidth = this.getTextWidth.bind(this);
        this.screen = screen;
        this.gurk = gurk1;
        this.buttons = new Array(3);
        for (y = l = 0; l <= 2; y = ++l) {
          this.buttons[y] = new Array(3);
          for (x = o = 0; o <= 2; x = ++o) {
            this.buttons[y][x] = null;
          }
        }
        true;
      }

      processResult(result) {}

      draw() {
        var f;
        f = () => {
          this.screen.clear();
          this.doDraw();
          return this.screen.drawScreen();
        };
        f();
        if (drawHack) {
          return setTimeout(f, 50);
        }
      }

      doDraw() {}

      doLayout() {}

      command(text) {}

      setButtons(grid) {
        var l, results1, x, y;
        grid.clear();
        results1 = [];
        for (y = l = 0; l <= 2; y = ++l) {
          results1.push((function() {
            var o, results2;
            results2 = [];
            for (x = o = 0; o <= 2; x = ++o) {
              if (this.buttons[y][x]) {
                results2.push(grid.setButtonByPosition(x, y, this.buttons[y][x]));
              } else {
                results2.push(void 0);
              }
            }
            return results2;
          }).call(this));
        }
        return results1;
      }

      enableMovement() {
        this.buttons[1][0] = View.LEFT;
        this.buttons[0][1] = View.UP;
        this.buttons[1][2] = View.RIGHT;
        this.buttons[2][1] = View.DOWN;
        if (this.gurk.isCurrentView(this)) {
          return this.setButtons(this.gurk.buttonGrid);
        }
      }

      static coords(keyNum) {
        var x, y;
        keyNum--;
        y = Math.floor(keyNum / 3);
        x = keyNum % 3;
        return [x, y];
      }

      clearButton(keyNum) {
        var x, y;
        [x, y] = View.coords(keyNum);
        this.buttons[y][x] = null;
        if (this.gurk.isCurrentView(this)) {
          return this.gurk.buttonGrid.disableButtonByPosition(x, y);
        }
      }

      clearAllButtons() {
        var i, l;
        for (i = l = 1; l <= 9; i = ++l) {
          this.clearButton(i);
        }
        return true;
      }

      setButton(keyNum, text) {
        var x, y;
        [x, y] = View.coords(keyNum);
        this.buttons[y][x] = text;
        if (this.gurk.isCurrentView(this)) {
          return this.gurk.buttonGrid.setButtonByPosition(x, y, text);
        }
      }

      getTextWidth(text) {
        return Screen.FONT.getWidth(text);
      }

    };

    View.LEFT = "1";

    View.UP = "2";

    View.RIGHT = "3";

    View.DOWN = "4";

    View.prototype.buttons = null;

    View.prototype.name = "No Name";

    return View;

  }).call(this);

  InfoView = (function() {
    // -----------------------------------------------------------------------------
    class InfoView extends View {
      constructor(gurk, doneVerb = "DONE") {
        super(gurk.getScreen(), gurk);
        this.clear = this.clear.bind(this);
        this.addIcon = this.addIcon.bind(this);
        this.changeIcon = this.changeIcon.bind(this);
        this.addLabel = this.addLabel.bind(this);
        this.addLabelCentered = this.addLabelCentered.bind(this);
        this.doDraw = this.doDraw.bind(this);
        this.command = this.command.bind(this);
        this.icons = new Array();
        this.labels = new Array();
        this.doneVerb = doneVerb;
        this.setButton(5, this.doneVerb);
      }

      clear() {
        boundMethodCheck(this, InfoView);
        this.icons = new Array();
        return this.labels = new Array();
      }

      addIcon(icon, x, y) {
        boundMethodCheck(this, InfoView);
        this.icons.push({
          "icon": icon,
          "x": x,
          "y": y
        });
        return this.icons.length - 1;
      }

      changeIcon(index, icon) {
        boundMethodCheck(this, InfoView);
        return this.icons[index].icon = icon;
      }

      addLabel(text, color, x, y) {
        boundMethodCheck(this, InfoView);
        this.labels.push({
          "text": text,
          "color": color,
          "x": x,
          "y": y
        });
        return this.labels.length - 1;
      }

      addLabelCentered(text, color, x, y, width, height) {
        var h, w, xx, yy;
        boundMethodCheck(this, InfoView);
        w = Screen.FONT.getWidth(text);
        h = Screen.FONT.fontHeight;
        xx = x + Math.floor((width - w) / 2);
        yy = y + Math.floor((height - h) / 2);
        return this.addLabel(text, color, xx, yy);
      }

      doDraw() {
        var icon, l, label, len, len1, o, ref, ref1, results1;
        boundMethodCheck(this, InfoView);
        this.screen.clearColor(Screen.GURK_BLUE);
        ref = this.icons;
        for (l = 0, len = ref.length; l < len; l++) {
          icon = ref[l];
          this.screen.drawIcon(icon.icon, icon.x, icon.y);
        }
        ref1 = this.labels;
        results1 = [];
        for (o = 0, len1 = ref1.length; o < len1; o++) {
          label = ref1[o];
          results1.push(this.screen.drawText(label.text, label.color, label.x, label.y));
        }
        return results1;
      }

      command(text) {
        boundMethodCheck(this, InfoView);
        switch (text) {
          case this.doneVerb:
            return this.gurk.popView(null);
        }
      }

    };

    InfoView.prototype.icons = null;

    InfoView.prototype.labels = null;

    InfoView.prototype.doneVerb = null;

    return InfoView;

  }).call(this);

  SelectView = (function() {
    // -----------------------------------------------------------------------------
    class SelectView extends InfoView {
      constructor(gurk, selectVerb = "SELECT", cancelVerb = "CANCEL") {
        super(gurk);
        this.clear = this.clear.bind(this);
        this.start = this.start.bind(this);
        this.setSelectVerb = this.setSelectVerb.bind(this);
        this.turnOffSelection = this.turnOffSelection.bind(this);
        this.cancelled = this.cancelled.bind(this);
        this.itemSelected = this.itemSelected.bind(this);
        this.itemHighlighted = this.itemHighlighted.bind(this);
        // no-op, override to respond to highlight
        this.addOption = this.addOption.bind(this);
        this.changeOption = this.changeOption.bind(this);
        this.moveUp = this.moveUp.bind(this);
        this.moveDown = this.moveDown.bind(this);
        this.makeSelection = this.makeSelection.bind(this);
        this.command = this.command.bind(this);
        this.doDraw = this.doDraw.bind(this);
        this.selectVerb = selectVerb;
        this.cancelVerb = cancelVerb;
        this.options = new Array();
        // Use up/down for selection
        this.setButton(2, View.UP);
        this.setButton(8, View.DOWN);
        this.setButton(5, this.selectVerb);
        if (this.cancelVerb) {
          this.setButton(9, this.cancelVerb);
        } else {
          this.clearButton(9);
        }
      }

      clear() {
        boundMethodCheck(this, SelectView);
        super.clear();
        return this.options = new Array();
      }

      start() {
        boundMethodCheck(this, SelectView);
        if (this.selected >= this.options.length) {
          this.selected = 0;
        }
        if (this.options.length > 0) {
          return this.itemHighlighted(this.selected, this.options[this.selected]);
        }
      }

      setSelectVerb(verb) {
        boundMethodCheck(this, SelectView);
        this.selectVerb = verb;
        return this.setButton(5, this.selectVerb);
      }

      turnOffSelection() {
        boundMethodCheck(this, SelectView);
        return this.clearButton(5);
      }

      cancelled() {
        boundMethodCheck(this, SelectView);
        // Override to respond to cancellation differently
        return this.gurk.popView(null);
      }

      itemSelected(index, item) {
        boundMethodCheck(this, SelectView);
        // Override to respond to selection differently
        return this.gurk.popView(item);
      }

      itemHighlighted(index, item) {
        boundMethodCheck(this, SelectView);
      }

      addOption(text, color, x, y, highlightColor = SelectView.SELECT_COLOR) {
        boundMethodCheck(this, SelectView);
        this.options.push({
          "text": text,
          "color": color,
          "highlightColor": highlightColor,
          "x": x,
          "y": y
        });
        return this.options.length - 1;
      }

      changeOption(index, text, color) {
        var option;
        boundMethodCheck(this, SelectView);
        option = this.options[index];
        option.text = text;
        return option.color = color;
      }

      moveUp() {
        boundMethodCheck(this, SelectView);
        if (this.options.length > 0) {
          this.selected--;
          if (this.selected < 0) {
            this.selected = this.options.length - 1;
          }
          this.itemHighlighted(this.selected, this.options[this.selected]);
          return this.draw();
        }
      }

      moveDown() {
        boundMethodCheck(this, SelectView);
        if (this.options.length > 0) {
          this.selected++;
          if (this.selected >= this.options.length) {
            this.selected = 0;
          }
          this.itemHighlighted(this.selected, this.options[this.selected]);
          return this.draw();
        }
      }

      makeSelection() {
        boundMethodCheck(this, SelectView);
        if (this.options.length > 0) {
          return this.itemSelected(this.selected, this.options[this.selected]);
        }
      }

      command(text) {
        boundMethodCheck(this, SelectView);
        switch (text) {
          case View.UP:
            return this.moveUp();
          case View.DOWN:
            return this.moveDown();
          case this.selectVerb:
            return this.makeSelection();
          case this.cancelVerb:
            return this.cancelled();
        }
      }

      doDraw() {
        var color, i, icon, l, label, len, len1, len2, o, option, p, ref, ref1, ref2, results1;
        boundMethodCheck(this, SelectView);
        super.doDraw();
        this.screen.clearColor(Screen.GURK_BLUE);
        ref = this.icons;
        for (l = 0, len = ref.length; l < len; l++) {
          icon = ref[l];
          this.screen.drawIcon(icon.icon, icon.x, icon.y);
        }
        ref1 = this.labels;
        for (o = 0, len1 = ref1.length; o < len1; o++) {
          label = ref1[o];
          this.screen.drawText(label.text, label.color, label.x, label.y);
        }
        ref2 = this.options;
        results1 = [];
        for (i = p = 0, len2 = ref2.length; p < len2; i = ++p) {
          option = ref2[i];
          color = (i === this.selected) ? option.highlightColor : option.color;
          results1.push(this.screen.drawText(option.text, color, option.x, option.y));
        }
        return results1;
      }

    };

    SelectView.BASIC_COLOR = "#FFF";

    SelectView.SELECT_COLOR = "#0FF";

    SelectView.prototype.options = null;

    SelectView.prototype.selected = 0;

    SelectView.prototype.selectVerb = null;

    SelectView.prototype.cancelVerb = null;

    return SelectView;

  }).call(this);

  AlertView = (function() {
    // -----------------------------------------------------------------------------
    class AlertView extends View {
      constructor(gurk, icon1, title1, text1, result1, altIcon1 = null) {
        super(gurk.getScreen(), gurk);
        this.doDraw = this.doDraw.bind(this);
        this.command = this.command.bind(this);
        this.icon = icon1;
        this.title = title1;
        this.text = text1;
        this.result = result1;
        this.altIcon = altIcon1;
        this.setButton(5, "OK");
      }

      doDraw() {
        boundMethodCheck(this, AlertView);
        this.screen.clearColor(Screen.GURK_BLUE);
        this.screen.drawIcon(this.icon, AlertView.ICON_X, AlertView.ICON_Y);
        if (this.altIcon) {
          this.screen.drawIcon(this.altIcon, Screen.SIZE - Screen.UNIT - AlertView.ICON_X, AlertView.ICON_Y);
        }
        if (this.subtitle) {
          this.screen.drawTextCentered(this.title, "#FFF", 0, 1, Screen.SIZE, Screen.UNIT);
          this.screen.drawTextCentered(this.subtitle, "#A0A0A0", 0, 9, Screen.SIZE, Screen.UNIT);
        } else {
          this.screen.drawTextCentered(this.title, "#FFF", 0, AlertView.ICON_Y + 1, Screen.SIZE, Screen.UNIT);
        }
        return this.screen.wrapText(this.text, "#FFF", AlertView.ICON_X, AlertView.ICON_Y * 2 + Screen.UNIT, Screen.SIZE - 2 * AlertView.ICON_X);
      }

      command(text) {
        boundMethodCheck(this, AlertView);
        switch (text) {
          case "OK":
            return this.gurk.popView(this.result);
        }
      }

    };

    AlertView.ICON_X = 3;

    AlertView.ICON_Y = 3;

    AlertView.TITLE_Y = 7;

    AlertView.prototype.subtitle = null;

    return AlertView;

  }).call(this);

  FlowView = (function() {
    // -----------------------------------------------------------------------------
    class FlowView extends AlertView {
      constructor(gurk, icon, title, result, altIcon = null) {
        super(gurk, icon, title, "", result, altIcon);
        this.addParagraph = this.addParagraph.bind(this);
        this.addGap = this.addGap.bind(this);
        this.doDraw = this.doDraw.bind(this);
        this.paragraphs = new Array();
      }

      addParagraph(text, color) {
        boundMethodCheck(this, FlowView);
        return this.paragraphs.push({
          "text": text,
          "color": color
        });
      }

      addGap() {
        boundMethodCheck(this, FlowView);
        return this.paragraphs.push({
          "text": null
        });
      }

      doDraw() {
        var l, len, paragraph, ref, results1, x, y;
        boundMethodCheck(this, FlowView);
        super.doDraw();
        y = AlertView.ICON_Y * 2 + Screen.UNIT;
        x = AlertView.ICON_X;
        ref = this.paragraphs;
        results1 = [];
        for (l = 0, len = ref.length; l < len; l++) {
          paragraph = ref[l];
          if (!paragraph.text) {
            results1.push(y += 4);
          } else {
            results1.push(y += this.screen.wrapText(paragraph.text, paragraph.color, x, y, Screen.SIZE - 2 * x));
          }
        }
        return results1;
      }

    };

    FlowView.ICON_X = 3;

    FlowView.ICON_Y = 3;

    FlowView.TITLE_Y = 7;

    FlowView.prototype.paragraphs = null;

    return FlowView;

  }).call(this);

  // -----------------------------------------------------------------------------
  ConfirmView = class ConfirmView extends AlertView {
    constructor(gurk, icon, title, text, yesResult1, noResult1, altIcon = null) {
      var noResult, yesResult;
      noResult = function() {
        return this.noResult;
      };
      yesResult = function() {
        return this.yesResult;
      };
      super(gurk, icon, title, text, noResult, altIcon);
      this.command = this.command.bind(this);
      this.yesResult = yesResult1;
      this.noResult = noResult1;
      this.clearButton(5);
      this.setButton(1, "YES");
      this.setButton(3, "NO");
    }

    command(text) {
      boundMethodCheck(this, ConfirmView);
      switch (text) {
        case "YES":
          return this.gurk.popView(this.yesResult);
        case "NO":
          return this.gurk.popView(this.noResult);
      }
    }

  };

  TileView = (function() {
    // -----------------------------------------------------------------------------
    class TileView extends View {
      constructor(gurk, mapName1) {
        super(gurk.getScreen(), gurk);
        this.setMap = this.setMap.bind(this);
        this.drawTile = this.drawTile.bind(this);
        this.drawCustom = this.drawCustom.bind(this);
        this.getTerrain = this.getTerrain.bind(this);
        this.getTerrainIcon = this.getTerrainIcon.bind(this);
        this.animateBlock = this.animateBlock.bind(this);
        this.animateBlockFrame = this.animateBlockFrame.bind(this);
        this.animate = this.animate.bind(this);
        this.animateFrame = this.animateFrame.bind(this);
        this.fly = this.fly.bind(this);
        this.flyFrame = this.flyFrame.bind(this);
        this.setBanner = this.setBanner.bind(this);
        this.clearBanner = this.clearBanner.bind(this);
        this.drawBanner = this.drawBanner.bind(this);
        this.setTopBanner = this.setTopBanner.bind(this);
        this.clearTopBanner = this.clearTopBanner.bind(this);
        this.drawTopBanner = this.drawTopBanner.bind(this);
        this.mapName = mapName1;
        this.setMap(this.mapName, 0, 0);
        this.enableMovement();
        this.centerBanner = false;
      }

      setMap(mapName, x, y) {
        boundMethodCheck(this, TileView);
        this.mapName = mapName;
        this.map = Data.maps[this.mapName];
        this.height = this.map.height;
        this.width = this.map.width;
        this.posX = x;
        return this.posY = y;
      }

      drawTile(icon, x, y) {
        boundMethodCheck(this, TileView);
        return this.screen.drawIcon(icon, x * Screen.UNIT + this.offsetX, y * Screen.UNIT + this.offsetY);
      }

      drawCustom(image, x, y) {
        boundMethodCheck(this, TileView);
        return this.screen.drawImage(image, x * Screen.UNIT + this.offsetX - 2, y * Screen.UNIT + this.offsetY - 2);
      }

      getTerrain(x, y) {
        var c, index;
        boundMethodCheck(this, TileView);
        index = y * this.map.width + x;
        c = this.map.map.charAt(index);
        return Data.tiles[c];
      }

      getTerrainIcon(x, y) {
        boundMethodCheck(this, TileView);
        return this.getTerrain(x, y).icon;
      }

      animateBlock(anim, x, y, radius, rate, callback) {
        var fn, step;
        boundMethodCheck(this, TileView);
        step = 0;
        fn = () => {
          return this.animateBlockFrame(anim, x, y, radius, rate, step++, callback);
        };
        fn();
        return this.interval = setInterval(fn, rate);
      }

      animateBlockFrame(anim, x, y, radius, rate, frame, callback) {
        var frames, l, ref, ref1, results1, xx, yy;
        boundMethodCheck(this, TileView);
        frames = Icons[anim].frames;
        if (!frames) {
          frames = 1;
        }
        this.draw();
        if (frame === frames) {
          clearInterval(this.interval);
          return callback();
        } else {
          results1 = [];
          for (yy = l = ref = y - radius, ref1 = y + radius; (ref <= ref1 ? l <= ref1 : l >= ref1); yy = ref <= ref1 ? ++l : --l) {
            if (yy >= 0 && yy < this.height) {
              results1.push((function() {
                var o, ref2, ref3, results2;
                results2 = [];
                for (xx = o = ref2 = x - radius, ref3 = x + radius; (ref2 <= ref3 ? o <= ref3 : o >= ref3); xx = ref2 <= ref3 ? ++o : --o) {
                  if (xx >= 0 && xx < this.width) {
                    results2.push(this.screen.drawAnim(anim, xx * Screen.UNIT + this.offsetX, yy * Screen.UNIT + this.offsetY, frame));
                  } else {
                    results2.push(void 0);
                  }
                }
                return results2;
              }).call(this));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }
      }

      animate(anim, x, y, rate, callback) {
        var fn, step;
        boundMethodCheck(this, TileView);
        step = 0;
        fn = () => {
          return this.animateFrame(anim, x * Screen.UNIT + this.offsetX, y * Screen.UNIT + this.offsetY, rate, step++, callback);
        };
        fn();
        return this.interval = setInterval(fn, rate);
      }

      animateFrame(anim, x, y, rate, frame, callback) {
        var frames;
        boundMethodCheck(this, TileView);
        frames = Icons[anim].frames;
        if (!frames) {
          frames = 1;
        }
        this.draw();
        if (frame === frames) {
          clearInterval(this.interval);
          return callback();
        } else {
          return this.screen.drawAnim(anim, x, y, frame);
        }
      }

      fly(anim, x1, x2, y1, y2, rate, callback, custom = null) {
        var fn, n, step;
        boundMethodCheck(this, TileView);
        n = Math.floor(Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) * rate / 50) + 1;
        step = 0;
        fn = () => {
          return this.flyFrame(anim, x1 * Screen.UNIT + this.offsetX, x2 * Screen.UNIT + this.offsetX, y1 * Screen.UNIT + this.offsetY, y2 * Screen.UNIT + this.offsetY, rate, step++, n, callback, custom);
        };
        fn();
        return this.interval = setInterval(fn, rate);
      }

      flyFrame(anim, x1, x2, y1, y2, rate, step, n, callback, custom) {
        var frame, frames, x, y;
        boundMethodCheck(this, TileView);
        x = Math.floor(x1 + (x2 - x1) * step / n);
        y = Math.floor(y1 + (y2 - y1) * step / n);
        frames = Icons[anim].frames;
        if (!frames) {
          frames = 1;
        }
        frame = step % frames;
        this.draw();
        if (custom) {
          this.screen.drawCustomAnim(custom, x, y);
        } else {
          this.screen.drawAnim(anim, x, y, frame);
        }
        if (step > n) {
          clearInterval(this.interval);
          this.draw();
          return callback();
        }
      }

      setBanner(text) {
        boundMethodCheck(this, TileView);
        this.banner = text;
        return this.draw();
      }

      clearBanner() {
        boundMethodCheck(this, TileView);
        this.banner = null;
        return this.draw();
      }

      drawBanner() {
        var i, l, x, y;
        boundMethodCheck(this, TileView);
        if (this.banner) {
          x = -Screen.HALF_UNIT;
          y = 7 * Screen.UNIT;
          this.screen.drawIcon(Data.icons.bannerLeft, x, y);
          for (i = l = 0; l < 7; i = ++l) {
            x += Screen.UNIT;
            this.screen.drawIcon(Data.icons.banner, x, y);
          }
          x += Screen.UNIT;
          this.screen.drawIcon(Data.icons.bannerRight, x, y);
          if (this.centerBanner) {
            return this.screen.drawTextCentered(this.banner, "#FFF", 0, y + 5, 128, 8);
          } else {
            return this.screen.drawText(this.banner, "#FFF", 4, y + 5);
          }
        }
      }

      setTopBanner(numMoves, numAttacks, half = false) {
        boundMethodCheck(this, TileView);
        return this.topBanner = {
          "numMoves": numMoves,
          "numAttacks": numAttacks,
          "half": half
        };
      }

      clearTopBanner() {
        boundMethodCheck(this, TileView);
        return this.topBanner = null;
      }

      drawTopBanner() {
        var attacks, i, l, leftX, x, y;
        boundMethodCheck(this, TileView);
        if (this.topBanner) {
          if (this.topBannerLeft) {
            leftX = -Screen.HALF_UNIT;
          } else {
            leftX = 5 * Screen.UNIT - Screen.HALF_UNIT;
          }
          y = 0;
          x = leftX;
          this.screen.drawIcon(Data.icons.bannerLeft, x, y);
          for (i = l = 0; l < 2; i = ++l) {
            x += Screen.UNIT;
            this.screen.drawIcon(Data.icons.banner, x, y);
          }
          x += Screen.UNIT;
          this.screen.drawIcon(Data.icons.bannerRight, x, y);
          x = leftX + Screen.HALF_UNIT + 5;
          y = 5;
          this.screen.drawText("~", "#A0A0A0", x, y);
          x += 10;
          this.screen.drawText(":", "#A0A0A0", x, y);
          x += 3;
          this.screen.drawText(`${this.topBanner.numMoves}`, "#FFF", x, y);
          x = leftX + Screen.HALF_UNIT + 25;
          this.screen.drawText("`", "#A0A0A0", x, y);
          x += 6;
          this.screen.drawText(":", "#A0A0A0", x, y);
          x += 3;
          if (this.topBanner.half) {
            attacks = `${this.topBanner.numAttacks - 1}|`;
          } else {
            attacks = `${this.topBanner.numAttacks}`;
          }
          return this.screen.drawText(`${attacks}`, "#FFF", x, y);
        }
      }

    };

    TileView.prototype.width = 0;

    TileView.prototype.height = 0;

    TileView.prototype.posX = 0;

    TileView.prototype.posY = 0;

    TileView.prototype.offsetX = 0;

    TileView.prototype.offsetY = 0;

    TileView.prototype.map = null;

    TileView.prototype.animation = null;

    TileView.prototype.interval = null;

    TileView.prototype.banner = null;

    TileView.prototype.centerBanner = false;

    TileView.prototype.topBanner = null;

    TileView.prototype.topBannerLeft = false;

    return TileView;

  }).call(this);

  ImageProcessor = (function() {
    // -----------------------------------------------------------------------------
    class ImageProcessor {
      constructor(canvas, ctx1, icons) {
        // No-op
        this.drawIcon = this.drawIcon.bind(this);
        this.drawRotated = this.drawRotated.bind(this);
        this.clear = this.clear.bind(this);
        this.paint = this.paint.bind(this);
        this.glow = this.glow.bind(this);
        this.shade = this.shade.bind(this);
        this.halo = this.halo.bind(this);
        this.process = this.process.bind(this);
        this.rotate = this.rotate.bind(this);
        this.canvas = canvas;
        this.ctx = ctx1;
        this.icons = icons;
      }

      drawIcon(icon) {
        var coords, k, x, y;
        x = 2;
        y = 2;
        coords = Icons[icon];
        k = Screen.UNIT * Screen.SCALE;
        return this.ctx.drawImage(this.icons[coords.block], k * coords.x, k * coords.y, k, k, x * Screen.SCALE, y * Screen.SCALE, k, k);
      }

      drawRotated(icon, degrees) {
        var t;
        this.ctx.save();
        t = (Screen.HALF_UNIT + 2) * Screen.SCALE;
        this.ctx.translate(t, t);
        this.ctx.rotate(degrees * Math.PI / 180);
        this.ctx.translate(-t, -t);
        this.drawIcon(icon);
        return this.ctx.restore();
      }

      clear() {
        return this.ctx.clearRect(0, 0, (Screen.UNIT + 4) * Screen.SCALE, (Screen.UNIT + 4) * Screen.SCALE);
      }

      paint(colors) {
        var a, arcs, b, c, g, i, img, l, o, r, ref, ref1, result, size, src, x, xx, y, yy;
        arcs = ImageProcessor.computeArcs(colors, 12);
        size = (Screen.UNIT + 4) * Screen.SCALE;
        img = this.ctx.getImageData(0, 0, size, size).data;
        for (y = l = 0, ref = Screen.UNIT; (0 <= ref ? l < ref : l > ref); y = 0 <= ref ? ++l : --l) {
          yy = (y + 2) * Screen.SCALE;
          for (x = o = 0, ref1 = Screen.UNIT; (0 <= ref1 ? o < ref1 : o > ref1); x = 0 <= ref1 ? ++o : --o) {
            xx = (x + 2) * Screen.SCALE;
            i = (yy * size + xx) * 4;
            r = img[i];
            g = img[i + 1];
            b = img[i + 2];
            a = img[i + 3];
            if (a > 0 && (r > 0 || g > 0 || b > 0)) {
              c = ImageProcessor.blend(colors, arcs, Screen.HALF_UNIT - y, Screen.HALF_UNIT - x);
              if (c.red > 0) {
                r = Math.min(255, r + c.red);
              } else {
                r = Math.max(0, r + c.red);
              }
              if (c.green > 0) {
                g = Math.min(255, g + c.green);
              } else {
                g = Math.max(0, g + c.green);
              }
              if (c.blue > 0) {
                b = Math.min(255, b + c.blue);
              } else {
                b = Math.max(0, b + c.blue);
              }
              this.ctx.fillStyle = `rgba(${r},${g},${b},${a})`;
              this.ctx.fillRect(xx, yy, Screen.SCALE, Screen.SCALE);
            }
          }
        }
        src = this.canvas.toDataURL();
        result = new Image();
        result.src = src;
        return result;
      }

      static blend(colors, arcs, x, y) {
        var a1, a2, angle, l, len, len1, max, min, o, p1, p2, ref, ref1, xx, yy;
        if (colors.length === 1) {
          return colors[0];
        }
        max = -2 * Math.PI;
        min = 2 * Math.PI;
        ref = [y, y + 1];
        for (l = 0, len = ref.length; l < len; l++) {
          yy = ref[l];
          ref1 = [x, x + 1];
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            xx = ref1[o];
            angle = Math.atan2(yy, xx);
            if (angle > max) {
              max = angle;
            }
            if (angle < min) {
              min = angle;
            }
          }
        }
        if (min < 0) {
          min += 2 * Math.PI;
        }
        if (max < 0) {
          max += 2 * Math.PI;
        }
        a1 = Math.floor(min * arcs / Math.PI / 2);
        a2 = Math.floor(max * arcs / Math.PI / 2);
        if (a1 === a2) {
          return colors[a1 % colors.length];
        } else {
          p1 = a2 - min * arcs / Math.PI / 2;
          p2 = max * arcs / Math.PI / 2 - a2;
          return Util.blendColors(colors[a1 % colors.length], colors[a2 % colors.length], p1 / (p1 + p2), p2 / (p1 + p2));
        }
      }

      static computeArcs(colors, target) {
        var k, n;
        n = colors.length;
        if (n === 1) {
          return 1;
        } else {
          k = Math.round(target / n);
          return k * n;
        }
      }

      glow(colors, intensity) {
        var a, arcs, c, cells, i, i1, img, l, length, o, p, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, result, s, size, src, u, x, xx, y, yy, z;
        arcs = ImageProcessor.computeArcs(colors, 30);
        length = Screen.UNIT + 4;
        cells = Util.create2DArray(length, length);
        size = length * Screen.SCALE;
        img = this.ctx.getImageData(0, 0, size, size).data;
        for (y = l = 0, ref = length - 2; (0 <= ref ? l < ref : l > ref); y = 0 <= ref ? ++l : --l) {
          yy = y * Screen.SCALE;
          for (x = o = 0, ref1 = length; (0 <= ref1 ? o < ref1 : o > ref1); x = 0 <= ref1 ? ++o : --o) {
            xx = x * Screen.SCALE;
            i = (yy * size + xx) * 4;
            a = img[i + 3];
            if (a > 0) {
              cells[y][x] = 3;
            } else {
              cells[y][x] = 0;
            }
          }
        }
        for (y = p = 0, ref2 = length - 3; (0 <= ref2 ? p < ref2 : p > ref2); y = 0 <= ref2 ? ++p : --p) {
          for (x = q = 0, ref3 = length; (0 <= ref3 ? q < ref3 : q > ref3); x = 0 <= ref3 ? ++q : --q) {
            if (cells[y][x] === 0) {
              if (x > 0) {
                if (cells[y][x - 1] === 3) {
                  cells[y][x] = 2;
                }
              }
              if (x + 1 < length) {
                if (cells[y][x + 1] === 3) {
                  cells[y][x] = 2;
                }
              }
              if (y > 0) {
                if (cells[y - 1][x] === 3) {
                  cells[y][x] = 2;
                }
              }
              if (y + 1 < length) {
                if (cells[y + 1][x] === 3) {
                  cells[y][x] = 2;
                }
              }
            }
          }
        }
        for (y = s = 0, ref4 = length - 2; (0 <= ref4 ? s < ref4 : s > ref4); y = 0 <= ref4 ? ++s : --s) {
          for (x = u = 0, ref5 = length; (0 <= ref5 ? u < ref5 : u > ref5); x = 0 <= ref5 ? ++u : --u) {
            if (cells[y][x] === 0) {
              if (x > 0) {
                if (cells[y][x - 1] === 2) {
                  cells[y][x] = 1;
                }
              }
              if (x + 1 < length) {
                if (cells[y][x + 1] === 2) {
                  cells[y][x] = 1;
                }
              }
              if (y > 0) {
                if (cells[y - 1][x] === 2) {
                  cells[y][x] = 1;
                }
              }
              if (y + 1 < length) {
                if (cells[y + 1][x] === 2) {
                  cells[y][x] = 1;
                }
              }
            }
          }
        }
        for (y = z = 0, ref6 = length - 2; (0 <= ref6 ? z < ref6 : z > ref6); y = 0 <= ref6 ? ++z : --z) {
          yy = y * Screen.SCALE;
          for (x = i1 = 0, ref7 = length; (0 <= ref7 ? i1 < ref7 : i1 > ref7); x = 0 <= ref7 ? ++i1 : --i1) {
            if (cells[y][x] > 0 && cells[y][x] < 3) {
              xx = x * Screen.SCALE;
              i = (yy * size + xx) * 4;
              if (cells[y][x] === 1) {
                this.ctx.globalAlpha = intensity / 100 / 3;
              } else {
                this.ctx.globalAlpha = intensity / 100;
              }
              c = ImageProcessor.blend(colors, arcs, length / 2 - y, length / 2 - x);
              this.ctx.fillStyle = `rgba(${c.red},${c.green},${c.blue},255)`;
              this.ctx.fillRect(xx, yy, Screen.SCALE, Screen.SCALE);
            }
          }
        }
        this.ctx.globalAlpha = 1;
        src = this.canvas.toDataURL();
        result = new Image();
        result.src = src;
        return result;
      }

      shade(icon, colors) {
        this.clear();
        this.drawIcon(icon);
        return this.paint(colors);
      }

      halo(icon, colors, intensity) {
        this.clear();
        this.drawIcon(icon);
        return this.glow(colors, intensity);
      }

      process(icon, shadeColors, haloColors) {
        var result;
        this.clear();
        this.drawIcon(icon);
        result = null;
        if (shadeColors && shadeColors.length > 0) {
          result = this.paint(shadeColors);
        }
        if (haloColors && haloColors.length > 0) {
          result = this.glow(haloColors, 80);
        }
        return result;
      }

      rotate(icon, direction) {
        var result, src;
        this.clear();
        this.drawRotated(icon, direction);
        src = this.canvas.toDataURL();
        result = new Image();
        result.src = src;
        return result;
      }

    };

    ImageProcessor.UP = 0;

    ImageProcessor.RIGHT = 90;

    ImageProcessor.DOWN = 180;

    ImageProcessor.LEFT = 270;

    return ImageProcessor;

  }).call(this);

  Library = class Library {
    static getItemTemplateByName(name) {
      var item, l, len, ref;
      ref = Data.items;
      for (l = 0, len = ref.length; l < len; l++) {
        item = ref[l];
        if (item.name === name) {
          return item;
        }
      }
      return null;
    }

    static getItemTemplates(level, groups) {
      var item, l, len, ref, results;
      results = new Array();
      ref = Data.items;
      for (l = 0, len = ref.length; l < len; l++) {
        item = ref[l];
        if (item.level === level && (!groups || Util.hasCommonElements(groups, item.groups))) {
          results.push(item);
        }
      }
      return results;
    }

    static getCharacterByName(name) {
      var character, l, len, ref;
      ref = Data.characters;
      for (l = 0, len = ref.length; l < len; l++) {
        character = ref[l];
        if (character.name === name) {
          return character;
        }
      }
      return null;
    }

    static getCreatureByName(name) {
      var creature, l, len, ref;
      ref = Data.creatures;
      for (l = 0, len = ref.length; l < len; l++) {
        creature = ref[l];
        if (creature.name === name) {
          return creature;
        }
      }
      return null;
    }

    static getCreatures(level, groups) {
      var creature, l, len, ref, results;
      results = new Array();
      ref = Data.creatures;
      for (l = 0, len = ref.length; l < len; l++) {
        creature = ref[l];
        if (creature.level === level && (!groups || Util.hasCommonElements(groups, creature.groups))) {
          results.push(creature);
        }
      }
      return results;
    }

    static getLevelNear(level) {
      var a, i, x;
      x = Util.random(0, 9999);
      a = Data.levelTransformations[level - 1];
      i = 0;
      while (x > a[i]) {
        x -= a[i];
        i++;
      }
      return i + 1;
    }

    static getSpellsForCharacterAndLevel(character, level) {
      var job, l, len, ref, results, spell, type;
      type = character.type;
      job = character.job;
      results = new Array();
      ref = Data.spells;
      for (l = 0, len = ref.length; l < len; l++) {
        spell = ref[l];
        if ((spell.who === type || spell.who === job) && spell.level <= level) {
          results.push(spell);
        }
      }
      return results;
    }

    static newSpellsForCharacterAndLevel(character, level) {
      var job, l, len, ref, spell, type;
      type = character.type;
      job = character.job;
      ref = Data.spells;
      for (l = 0, len = ref.length; l < len; l++) {
        spell = ref[l];
        if ((spell.who === type || spell.who === job) && spell.level === level) {
          return true;
        }
      }
      return false;
    }

    static getSpellByName(name) {
      var l, len, ref, spell;
      ref = Data.spells;
      for (l = 0, len = ref.length; l < len; l++) {
        spell = ref[l];
        if (spell.name === name) {
          return spell;
        }
      }
      return null;
    }

  };

  Item = (function() {
    // -----------------------------------------------------------------------------
    // An instance of an item
    class Item {
      constructor(template1, id1, bonus1 = 0, charges1 = 0) {
        this.getColor = this.getColor.bind(this);
        this.getType = this.getType.bind(this);
        this.isWeapon = this.isWeapon.bind(this);
        this.getHitSpell = this.getHitSpell.bind(this);
        this.getCombatSpell = this.getCombatSpell.bind(this);
        this.isUseable = this.isUseable.bind(this);
        this.isEquipableBy = this.isEquipableBy.bind(this);
        this.isFor = this.isFor.bind(this);
        this.getSpell = this.getSpell.bind(this);
        this.getSpellRange = this.getSpellRange.bind(this);
        this.canUseOutsideOfCombat = this.canUseOutsideOfCombat.bind(this);
        this.isMeleeWeapon = this.isMeleeWeapon.bind(this);
        this.isRangeWeapon = this.isRangeWeapon.bind(this);
        this.isAreaWeapon = this.isAreaWeapon.bind(this);
        this.getMeleeMinDamage = this.getMeleeMinDamage.bind(this);
        this.getMeleeMaxDamage = this.getMeleeMaxDamage.bind(this);
        this.getRangeMinDamage = this.getRangeMinDamage.bind(this);
        this.getRangeMaxDamage = this.getRangeMaxDamage.bind(this);
        this.getToHitBonus = this.getToHitBonus.bind(this);
        this.getArmorClass = this.getArmorClass.bind(this);
        this.getResistance = this.getResistance.bind(this);
        this.getExtraMoves = this.getExtraMoves.bind(this);
        this.getExtraAttacks = this.getExtraAttacks.bind(this);
        this.getStrengthBonus = this.getStrengthBonus.bind(this);
        this.getAccuracyBonus = this.getAccuracyBonus.bind(this);
        this.getAwarenessBonus = this.getAwarenessBonus.bind(this);
        this.getConstitutionBonus = this.getConstitutionBonus.bind(this);
        this.getValue = this.getValue.bind(this);
        this.getShopValue = this.getShopValue.bind(this);
        this.getSpellName = this.getSpellName.bind(this);
        this.template = template1;
        this.id = id1;
        this.bonus = bonus1;
        this.charges = charges1;
        this.name = this.template.name;
        if (this.bonus > 0) {
          this.name += " +" + this.bonus;
        } else if (this.bonus < 0) {
          this.name += " -" + (-this.bonus);
        }
      }

      getColor() {
        var ref;
        return (ref = this.template.legendary) != null ? ref : "#FFF";
      }

      getType() {
        return this.template.type;
      }

      isWeapon() {
        return this.template.type === Item.TYPE_WEAPON;
      }

      getHitSpell() {
        if (this.template.hitSpell) {
          return Library.getSpellByName(this.template.hitSpell);
        } else {
          return null;
        }
      }

      getCombatSpell() {
        if (this.template.combatSpell) {
          return Library.getSpellByName(this.template.combatSpell);
        } else {
          return null;
        }
      }

      isUseable() {
        return this.template.type === Item.TYPE_USE;
      }

      isEquipableBy(characterType) {
        return !this.isUseable() && this.isFor(characterType);
      }

      isFor(characterType) {
        return Util.hasElement(this.template.usedBy, characterType);
      }

      getSpell() {
        if (this.template.spell) {
          return Library.getSpellByName(this.template.spell);
        } else if (this.template.combatSpell) {
          return Library.getSpellByName(this.template.combatSpell);
        } else {
          return null;
        }
      }

      getSpellRange(spell = null) {
        if (!spell) {
          spell = this.getSpell();
        }
        if (!spell) {
          spell = this.getHitSpell();
        }
        return {
          "min": spell.minAmount + this.bonus * spell.modifyAmount,
          "max": spell.maxAmount + this.bonus * spell.modifyAmount
        };
      }

      canUseOutsideOfCombat() {
        var spell;
        spell = this.getSpell();
        return this.isUseable() && spell.type === "heal" && (spell.healType === "restore" || spell.healType === "heal" || !spell.healType);
      }

      isMeleeWeapon() {
        return this.isWeapon() && this.template.meleeMinDamage;
      }

      isRangeWeapon() {
        return this.isWeapon() && this.template.rangeMinDamage;
      }

      isAreaWeapon() {
        return this.isWeapon() && this.template.target === "area";
      }

      getMeleeMinDamage() {
        return this.template.meleeMinDamage + this.bonus;
      }

      getMeleeMaxDamage() {
        return this.template.meleeMaxDamage + this.bonus;
      }

      getRangeMinDamage() {
        return this.template.rangeMinDamage + this.bonus;
      }

      getRangeMaxDamage() {
        return this.template.rangeMaxDamage + this.bonus;
      }

      getToHitBonus() {
        if (this.isWeapon()) {
          if (this.template.toHitBonus) {
            return this.template.toHitBonus + this.bonus;
          } else {
            return this.bonus;
          }
        } else {
          return 0;
        }
      }

      getArmorClass() {
        if (this.template.armorClass) {
          return this.template.armorClass + this.bonus;
        } else {
          return 0;
        }
      }

      getResistance() {
        if (this.template.resistance) {
          return this.template.resistance + this.bonus;
        } else {
          return 0;
        }
      }

      getExtraMoves() {
        var ref;
        return (ref = this.template.extraMoves) != null ? ref : 0;
      }

      getExtraAttacks() {
        var ref;
        return (ref = this.template.extraAttacks) != null ? ref : 0;
      }

      getStrengthBonus() {
        if (this.template.strengthBonus) {
          return this.template.strengthBonus + this.bonus;
        } else {
          return 0;
        }
      }

      getAccuracyBonus() {
        if (this.template.accuracyBonus) {
          return this.template.accuracyBonus + this.bonus;
        } else {
          return 0;
        }
      }

      getAwarenessBonus() {
        if (this.template.awarenessBonus) {
          return this.template.awarenessBonus + this.bonus;
        } else {
          return 0;
        }
      }

      getConstitutionBonus() {
        if (this.template.constitutionBonus) {
          return this.template.constitutionBonus + this.bonus;
        } else {
          return 0;
        }
      }

      getValue() {
        var i, l, o, ref, ref1, value;
        value = this.template.baseValue;
        if (this.isUseable()) {
          value *= this.charges;
          value = Math.round(value + (value * this.bonus / 2));
        } else {
          if (this.bonus > 0) {
            for (i = l = 0, ref = this.bonus; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
              value = value * 1.8;
            }
          } else if (this.bonus < 0) {
            for (i = o = ref1 = this.bonus; (ref1 <= 0 ? o < 0 : o > 0); i = ref1 <= 0 ? ++o : --o) {
              value = value / 1.5;
            }
            value = Math.max(1, value);
          }
        }
        return Math.round(value);
      }

      getShopValue(modPerCent) {
        var value;
        value = Math.floor(this.getValue() * modPerCent / 100);
        if (value < 1) {
          value = 1;
        }
        return value;
      }

      getSpellName() {
        return this.template.spell;
      }

    };

    Item.TYPE_WEAPON = "weapon";

    Item.TYPE_SHIELD = "shield";

    Item.TYPE_HAT = "hat";

    Item.TYPE_ARMOR = "armor";

    Item.TYPE_BOOTS = "boots";

    Item.TYPE_AMULET = "amulet";

    Item.TYPE_USE = "use";

    Item.TYPES = [Item.TYPE_WEAPON, Item.TYPE_SHIELD, Item.TYPE_HAT, Item.TYPE_ARMOR, Item.TYPE_BOOTS, Item.TYPE_AMULET, Item.TYPE_USE];

    Item.prototype.name = null;

    return Item;

  }).call(this);

  Creature = (function() {
    // -----------------------------------------------------------------------------
    class Creature {
      constructor(template1, bonus1 = 0) {
        this.canAttackRange = this.canAttackRange.bind(this);
        this.canAttackArea = this.canAttackArea.bind(this);
        this.canAttackMelee = this.canAttackMelee.bind(this);
        this.getHitSpell = this.getHitSpell.bind(this);
        this.getToHitBonus = this.getToHitBonus.bind(this);
        this.getResistance = this.getResistance.bind(this);
        this.getPotency = this.getPotency.bind(this);
        this.getArmorClass = this.getArmorClass.bind(this);
        this.getMeleeDamageBounds = this.getMeleeDamageBounds.bind(this);
        this.getRangeDamageBounds = this.getRangeDamageBounds.bind(this);
        this.getSpellRange = this.getSpellRange.bind(this);
        this.getName = this.getName.bind(this);
        this.getSpells = this.getSpells.bind(this);
        this.template = template1;
        this.bonus = bonus1;
        this.maxHitPoints = Util.random(this.template.minHitPoints, this.template.maxHitPoints) + this.bonus;
        if (this.maxHitPoints < 1) {
          this.maxHitPoints = 1;
        }
        this.hitPoints = this.maxHitPoints;
        if (this.template.minSpellPoints) {
          this.maxSpellPoints = Util.random(this.template.minSpellPoints, this.template.maxSpellPoints) + this.bonus;
          this.spellPoints = this.maxSpellPoints;
        }
        this.good = false;
      }

      canAttackRange() {
        if (this.template.rangeMinDamage) {
          return true;
        } else {
          return false;
        }
      }

      canAttackArea() {
        if (this.template.target === "area") {
          return true;
        } else {
          return false;
        }
      }

      canAttackMelee() {
        if (this.template.meleeMinDamage) {
          return true;
        } else {
          return false;
        }
      }

      getHitSpell() {
        if (this.template.hitSpell) {
          return Library.getSpellByName(this.template.hitSpell);
        } else {
          return null;
        }
      }

      getToHitBonus() {
        var ref;
        return ((ref = this.template.hitModifier) != null ? ref : 0) + this.bonus;
      }

      getResistance() {
        var ref;
        return ((ref = this.template.resistance) != null ? ref : 0) + this.bonus;
      }

      getPotency() {
        var ref;
        return ((ref = this.template.potency) != null ? ref : 0) + Math.floor(this.template.level / 2) + this.bonus;
      }

      getArmorClass() {
        var ref;
        return ((ref = this.template.armorClass) != null ? ref : 0) + this.bonus;
      }

      getMeleeDamageBounds() {
        var max, min;
        min = Math.max(this.template.meleeMinDamage + this.bonus, 1);
        max = Math.max(this.template.meleeMaxDamage + this.bonus, 1);
        return {
          "min": min,
          "max": max
        };
      }

      getRangeDamageBounds() {
        var max, min;
        min = Math.max(this.template.rangeMinDamage + this.bonus, 1);
        max = Math.max(this.template.rangeMaxDamage + this.bonus, 1);
        return {
          "min": min,
          "max": max
        };
      }

      getSpellRange(spell) {
        var max, min;
        min = spell.minAmount + this.bonus;
        max = spell.maxAmount + this.bonus;
        if (min < 1) {
          min = 1;
        }
        if (max < 1) {
          max = 1;
        }
        return {
          "min": min,
          "max": max
        };
      }

      getName() {
        return this.template.name;
      }

      getSpells() {
        var l, len, list, results, spell;
        list = this.template.spells;
        results = [];
        if (list) {
          for (l = 0, len = list.length; l < len; l++) {
            spell = list[l];
            results.push(Library.getSpellByName(spell.name));
          }
        }
        return results;
      }

    };

    Creature.prototype.hitPoints = 0;

    Creature.prototype.maxHitPoints = 0;

    Creature.prototype.spellPoints = 0;

    Creature.prototype.maxSpellPoints = 0;

    return Creature;

  }).call(this);

  Player = (function() {
    // -----------------------------------------------------------------------------
    // A "hero", but also used to represent the bag of holding.
    class Player {
      fromData(data) {
        var id, item, k, l, len, obj, ref, ref1, results1;
        Util.copyProperties(data, this);
        this.items = new Array();
        this.equipment = {};
        this.equipment[Item.TYPE_WEAPON] = null;
        this.equipment[Item.TYPE_SHIELD] = null;
        this.equipment[Item.TYPE_HAT] = null;
        this.equipment[Item.TYPE_ARMOR] = null;
        this.equipment[Item.TYPE_BOOTS] = null;
        this.equipment[Item.TYPE_AMULET] = null;
        ref = data.items;
        for (l = 0, len = ref.length; l < len; l++) {
          obj = ref[l];
          item = new Item(Library.getItemTemplateByName(obj.template), obj.id, obj.bonus, obj.charges);
          this.items.push(item);
        }
        ref1 = data.equipment;
        results1 = [];
        for (k in ref1) {
          id = ref1[k];
          if (id) {
            results1.push(this.equipment[k] = this.getItemById(id));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      constructor(character1) {
        var attributes, best;
        // todo - starting items
        this.getName = this.getName.bind(this);
        this.canCarryMoreItems = this.canCarryMoreItems.bind(this);
        this.numberOfItems = this.numberOfItems.bind(this);
        this.addItem = this.addItem.bind(this);
        this.getItemById = this.getItemById.bind(this);
        this.equipItem = this.equipItem.bind(this);
        this.isItemEquipped = this.isItemEquipped.bind(this);
        this.unequipItem = this.unequipItem.bind(this);
        this.unequipItemByType = this.unequipItemByType.bind(this);
        this.dropItem = this.dropItem.bind(this);
        this.hasItem = this.hasItem.bind(this);
        this.canEmploy = this.canEmploy.bind(this);
        this.hasUsableItem = this.hasUsableItem.bind(this);
        this.getEquipableItemsByType = this.getEquipableItemsByType.bind(this);
        this.getEquippedItemByType = this.getEquippedItemByType.bind(this);
        this.getWeapon = this.getWeapon.bind(this);
        this.getHitSpell = this.getHitSpell.bind(this);
        this.getAttributeBonus = this.getAttributeBonus.bind(this);
        this.computeNextLevelHitPoints = this.computeNextLevelHitPoints.bind(this);
        this.computeNextLevelSpellPoints = this.computeNextLevelSpellPoints.bind(this);
        this.isAlive = this.isAlive.bind(this);
        this.takeDamage = this.takeDamage.bind(this);
        this.isRestored = this.isRestored.bind(this);
        this.isHealed = this.isHealed.bind(this);
        this.healCompletely = this.healCompletely.bind(this);
        this.heal = this.heal.bind(this);
        this.getExtraMoves = this.getExtraMoves.bind(this);
        this.getExtraAttacks = this.getExtraAttacks.bind(this);
        this.getArmorClass = this.getArmorClass.bind(this);
        this.getResistance = this.getResistance.bind(this);
        this.getPotency = this.getPotency.bind(this);
        this.getToHitBonus = this.getToHitBonus.bind(this);
        this.getStrength = this.getStrength.bind(this);
        this.getAccuracy = this.getAccuracy.bind(this);
        this.getAwareness = this.getAwareness.bind(this);
        this.getConstitution = this.getConstitution.bind(this);
        this.canAttackRange = this.canAttackRange.bind(this);
        this.canAttackArea = this.canAttackArea.bind(this);
        this.canAttackMelee = this.canAttackMelee.bind(this);
        this.getMeleeDamageBounds = this.getMeleeDamageBounds.bind(this);
        this.getRangeDamageBounds = this.getRangeDamageBounds.bind(this);
        this.getSpellRange = this.getSpellRange.bind(this);
        this.hasSpells = this.hasSpells.bind(this);
        this.getSpells = this.getSpells.bind(this);
        this.character = character1;
        this.level = 1;
        this.experience = 0;
        attributes = [Util.statRoll(), Util.statRoll(), Util.statRoll(), Util.statRoll()];
        attributes.sort(function(a, b) {
          return a - b;
        });
        best = attributes[3];
        attributes.pop();
        Util.shuffle(attributes);
        if (this.character.bestAttribute === "strength") {
          this.strength = best;
          this.accuracy = attributes[0];
          this.awareness = attributes[1];
          this.constitution = attributes[2];
        } else if (this.character.bestAttribute === "accuracy") {
          this.accuracy = best;
          this.strength = attributes[0];
          this.awareness = attributes[1];
          this.constitution = attributes[2];
        } else if (this.character.bestAttribute === "awareness") {
          this.awareness = best;
          this.accuracy = attributes[0];
          this.strength = attributes[1];
          this.constitution = attributes[2];
        } else if (this.character.bestAttribute === "constitution") {
          this.constitution = best;
          this.accuracy = attributes[0];
          this.awareness = attributes[1];
          this.strength = attributes[2];
        }
        if (this.character.strength) {
          this.strength += this.character.strength;
        }
        if (this.character.accuracy) {
          this.accuracy += this.character.accuracy;
        }
        if (this.character.awareness) {
          this.awareness += this.character.awareness;
        }
        if (this.character.constitution) {
          this.constitution += this.character.constitution;
        }
        if (this.strength < 1) {
          this.strength = 1;
        }
        if (this.accuracy < 1) {
          this.accuracy = 1;
        }
        if (this.awareness < 1) {
          this.awareness = 1;
        }
        if (this.constitution < 1) {
          this.constitution = 1;
        }
        this.maxHitPoints = Math.max(4, this.computeNextLevelHitPoints()) + this.character.hitPoints;
        if (Library.getSpellsForCharacterAndLevel(this.character, 1).length > 0) {
          this.maxSpellPoints = Math.max(2, this.computeNextLevelSpellPoints());
        } else {
          this.maxSpellPoints = 0;
        }
        this.healCompletely();
        this.items = new Array();
        this.equipment = {};
        this.equipment[Item.TYPE_WEAPON] = null;
        this.equipment[Item.TYPE_SHIELD] = null;
        this.equipment[Item.TYPE_HAT] = null;
        this.equipment[Item.TYPE_ARMOR] = null;
        this.equipment[Item.TYPE_BOOTS] = null;
        this.equipment[Item.TYPE_AMULET] = null;
      }

      getName() {
        return this.character.name;
      }

      canCarryMoreItems() {
        return this.items.length < Player.MAX_ITEMS;
      }

      numberOfItems() {
        return this.items.length;
      }

      addItem(item) {
        if (this.canCarryMoreItems()) {
          return this.items.push(item);
        }
      }

      getItemById(id) {
        var item, l, len, ref;
        ref = this.items;
        for (l = 0, len = ref.length; l < len; l++) {
          item = ref[l];
          if (item.id === id) {
            return item;
          }
        }
        return null;
      }

      equipItem(item) {
        var type;
        type = item.template.type;
        if (type !== Item.TYPE_USE) {
          return this.equipment[type] = item;
        }
      }

      isItemEquipped(item) {
        var type;
        type = item.template.type;
        return this.equipment[type] && this.equipment[type].id === item.id;
      }

      unequipItem(item) {
        var type;
        if (this.isItemEquipped(item)) {
          type = item.template.type;
          this.equipment[type] = null;
          return true;
        } else {
          return false;
        }
      }

      unequipItemByType(type) {
        var item;
        item = this.equipment[type];
        if (item) {
          return this.unequipItem(item);
        }
      }

      dropItem(item) {
        var i, l, ref;
        this.unequipItem(item);
        for (i = l = 0, ref = this.items.length; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          if (this.items[i].id === item.id) {
            this.items.splice(i, 1);
            return true;
          }
        }
        return false;
      }

      hasItem(name) {
        var item, l, len, ref;
        ref = this.items;
        for (l = 0, len = ref.length; l < len; l++) {
          item = ref[l];
          if (item.template.name === name) {
            return true;
          }
        }
        return false;
      }

      canEmploy(item) {
        return item.isFor(this.character.type);
      }

      hasUsableItem(inCombat, melee = false, summon = false, combatant = null) {
        var item, l, len, ref, spell;
        ref = this.items;
        for (l = 0, len = ref.length; l < len; l++) {
          item = ref[l];
          if (item.isUseable() && this.canEmploy(item) || combatant && inCombat && item.getCombatSpell() && !combatant.isCombatSpellUsed(item)) {
            spell = item.getSpell();
            if (spell) {
              if (inCombat) {
                if (spell.type === "summon" && summon) {
                  return true;
                }
                if (spell.target !== "touch" || melee || spell.type === "heal") {
                  return true;
                }
              } else if (spell.type === "heal" && spell.healType !== "remove") {
                return true;
              }
            }
          }
        }
        return false;
      }

      getEquipableItemsByType(type) {
        var item, l, len, ref, result;
        result = new Array();
        ref = this.items;
        for (l = 0, len = ref.length; l < len; l++) {
          item = ref[l];
          if (item.template.type === type && item.isEquipableBy(this.character.type)) {
            result.push(item);
          }
        }
        return result;
      }

      getEquippedItemByType(type) {
        return this.equipment[type];
      }

      getWeapon() {
        return this.getEquippedItemByType(Item.TYPE_WEAPON);
      }

      getHitSpell() {
        var weapon;
        weapon = this.getWeapon();
        if (weapon) {
          return weapon.getHitSpell();
        } else {
          return null;
        }
      }

      getAttributeBonus(value) {
        return Util.trunc((value - 1) / 2.4 - 4);
      }

      computeNextLevelHitPoints() {
        return Util.random(1, 8) + this.getAttributeBonus(this.getConstitution());
      }

      computeNextLevelSpellPoints() {
        return Util.random(1, 5) + this.getAttributeBonus(this.getAwareness());
      }

      isAlive() {
        return this.hitPoints > 0;
      }

      takeDamage(amount) {
        this.hitPoints -= amount;
        if (this.hitPoints < 0) {
          this.hitPoints = 0;
        }
        return this.hitPoints;
      }

      isRestored() {
        return this.spellPoints === this.maxSpellPoints;
      }

      isHealed() {
        return this.hitPoints === this.maxHitPoints;
      }

      healCompletely() {
        this.hitPoints = this.maxHitPoints;
        return this.spellPoints = this.maxSpellPoints;
      }

      heal() {
        if (this.hitPoints > 0) {
          this.hitPoints = Math.min(this.maxHitPoints, this.hitPoints + 1);
          return this.spellPoints = Math.min(this.maxSpellPoints, this.spellPoints + 1);
        }
      }

      getExtraMoves() {
        var item, k, moves, ref;
        moves = 0;
        ref = this.equipment;
        for (k in ref) {
          item = ref[k];
          if (item) {
            moves += item.getExtraMoves();
          }
        }
        return moves;
      }

      getExtraAttacks() {
        var attacks, item, k, ref;
        attacks = 0;
        ref = this.equipment;
        for (k in ref) {
          item = ref[k];
          if (item) {
            attacks += item.getExtraAttacks();
          }
        }
        return attacks;
      }

      getArmorClass() {
        var ac, item, k, ref;
        ac = this.getAttributeBonus(this.getAwareness());
        ref = this.equipment;
        for (k in ref) {
          item = ref[k];
          if (item) {
            ac += item.getArmorClass();
          }
        }
        return ac;
      }

      getResistance() {
        var item, k, r, ref;
        r = this.getAttributeBonus(this.getConstitution());
        ref = this.equipment;
        for (k in ref) {
          item = ref[k];
          if (item) {
            r += item.getResistance();
          }
        }
        return r;
      }

      getPotency() {
        return Math.floor(this.level / 2);
      }

      getToHitBonus() {
        var toHit, weapon;
        toHit = this.getAttributeBonus(this.getAccuracy());
        weapon = this.equipment[Item.TYPE_WEAPON];
        if (weapon) {
          toHit += weapon.getToHitBonus();
        }
        return toHit;
      }

      getStrength() {
        var item, k, ref, strength;
        strength = this.strength;
        ref = this.equipment;
        for (k in ref) {
          item = ref[k];
          if (item) {
            strength += item.getStrengthBonus();
          }
        }
        return strength;
      }

      getAccuracy() {
        var accuracy, item, k, ref;
        accuracy = this.accuracy;
        ref = this.equipment;
        for (k in ref) {
          item = ref[k];
          if (item) {
            accuracy += item.getAccuracyBonus();
          }
        }
        return accuracy;
      }

      getAwareness() {
        var awareness, item, k, ref;
        awareness = this.awareness;
        ref = this.equipment;
        for (k in ref) {
          item = ref[k];
          if (item) {
            awareness += item.getAwarenessBonus();
          }
        }
        return awareness;
      }

      getConstitution() {
        var constitution, item, k, ref;
        constitution = this.constitution;
        ref = this.equipment;
        for (k in ref) {
          item = ref[k];
          if (item) {
            constitution += item.getConstitutionBonus();
          }
        }
        return constitution;
      }

      canAttackRange() {
        var weapon;
        weapon = this.equipment[Item.TYPE_WEAPON];
        return weapon && weapon.isRangeWeapon();
      }

      canAttackArea() {
        var weapon;
        weapon = this.equipment[Item.TYPE_WEAPON];
        return weapon && weapon.isAreaWeapon();
      }

      canAttackMelee() {
        var weapon;
        weapon = this.equipment[Item.TYPE_WEAPON];
        return weapon && weapon.isMeleeWeapon();
      }

      getMeleeDamageBounds() {
        var bonus, max, min, weapon;
        weapon = this.equipment[Item.TYPE_WEAPON];
        if (!weapon) {
          min = 1;
          max = 1;
        } else if (weapon.isMeleeWeapon()) {
          min = weapon.getMeleeMinDamage();
          max = weapon.getMeleeMaxDamage();
        } else {
          min = weapon.getRangeMinDamage();
          max = weapon.getRangeMaxDamage();
        }
        bonus = this.getAttributeBonus(this.getStrength());
        min = Math.max(min + bonus, 1);
        max = Math.max(max + bonus, 1);
        return {
          min: min,
          max: max
        };
      }

      getRangeDamageBounds() {
        var bonus, max, min, weapon;
        weapon = this.equipment[Item.TYPE_WEAPON];
        bonus = this.getAttributeBonus(this.getStrength());
        if (weapon.isRangeWeapon()) {
          min = weapon.getRangeMinDamage() + bonus;
          max = weapon.getRangeMaxDamage() + bonus;
          min = Math.max(min, 1);
          max = Math.max(max, 1);
          return {
            min: min,
            max: max
          };
        } else {
          return {
            min: 0,
            max: 0
          };
        }
      }

      getSpellRange(spell) {
        var bonus, levelDiff, max, min;
        bonus = this.getAttributeBonus(this.getAwareness());
        levelDiff = this.level - spell.level;
        if (levelDiff < 0) {
          levelDiff = 0;
        }
        bonus += Math.round(spell.modifyAmount * levelDiff / 100);
        min = spell.minAmount + bonus;
        max = spell.maxAmount + bonus;
        if (min < 1) {
          min = 1;
        }
        if (max < 1) {
          max = 1;
        }
        return {
          "min": min,
          "max": max
        };
      }

      hasSpells() {
        return this.getSpells().length > 0;
      }

      getSpells() {
        return Library.getSpellsForCharacterAndLevel(this.character, this.level);
      }

    };

    Player.TYPE_WARRIOR = "warrior";

    Player.TYPE_ARCHER = "archer";

    Player.TYPE_MAGE = "mage";

    Player.ATTRIBUTES = ["Strength", "Accuracy", "Awareness", "Toughness"];

    Player.MAX_ITEMS = 15;

    Player.prototype.strength = 0;

    Player.prototype.accuracy = 0;

    Player.prototype.awareness = 0;

    Player.prototype.constitution = 0;

    Player.prototype.hitPoints = 0;

    Player.prototype.maxHitPoints = 0;

    Player.prototype.spellPoints = 0;

    Player.prototype.maxSpellPoints = 0;

    Player.prototype.experience = 0;

    Player.prototype.level = 0;

    Player.prototype.items = null;

    Player.prototype.equipment = null;

    return Player;

  }).call(this);

  Game = (function() {
    // -----------------------------------------------------------------------------
    class Game {
      constructor() {
        this.saveGame = this.saveGame.bind(this);
        this.loadGame = this.loadGame.bind(this);
        this.createBag = this.createBag.bind(this);
        this.death = this.death.bind(this);
        this.getStart = this.getStart.bind(this);
        this.setMarkers = this.setMarkers.bind(this);
        this.hasMarker = this.hasMarker.bind(this);
        this.hasAllMarkers = this.hasAllMarkers.bind(this);
        this.hasAnyMarkers = this.hasAnyMarkers.bind(this);
        this.buildFeatures = this.buildFeatures.bind(this);
        this.populateShopItems = this.populateShopItems.bind(this);
        this.getShopItems = this.getShopItems.bind(this);
        this.isChartered = this.isChartered.bind(this);
        this.boardShip = this.boardShip.bind(this);
        this.moveShip = this.moveShip.bind(this);
        this.disembark = this.disembark.bind(this);
        this.getCombatMap = this.getCombatMap.bind(this);
        this.getFeatures = this.getFeatures.bind(this);
        this.getFeature = this.getFeature.bind(this);
        this.addPlayer = this.addPlayer.bind(this);
        this.getVisitedArray = this.getVisitedArray.bind(this);
        this.markVisited = this.markVisited.bind(this);
        this.wasVisited = this.wasVisited.bind(this);
        this.moveTo = this.moveTo.bind(this);
        this.transitionTo = this.transitionTo.bind(this);
        this.doesItemExist = this.doesItemExist.bind(this);
        this.createItem = this.createItem.bind(this);
        this.getRandomTemplate = this.getRandomTemplate.bind(this);
        this.getRandomItem = this.getRandomItem.bind(this);
        this.playersNeedHealing = this.playersNeedHealing.bind(this);
        this.healParty = this.healParty.bind(this);
        this.regenerateParty = this.regenerateParty.bind(this);
        this.getEncounter = this.getEncounter.bind(this);
        this.giveExperience = this.giveExperience.bind(this);
        this.getAveragePlayerLevel = this.getAveragePlayerLevel.bind(this);
        this.getTile = this.getTile.bind(this);
        this.getTerrainInfo = this.getTerrainInfo.bind(this);
        this.checkForRandomEncounter = this.checkForRandomEncounter.bind(this);
        this.createEncounter = this.createEncounter.bind(this);
        this.players = new Array();
        this.map = Data.start[0].map;
        this.x = Data.start[0].x;
        this.y = Data.start[0].y;
        this.gold = Data.start[0].gold;
        this.ships = {};
        this.markers = {};
        this.shops = {};
        this.visited = {};
        this.moveNum = 0;
        this.buildFeatures();
      }

      saveGame() {
        var copy, item, k, l, len, len1, len2, o, p, player, ref, ref1, ref2, ref3;
        copy = JSON.parse(JSON.stringify(this));
        delete copy.features;
        ref = copy.players;
        for (l = 0, len = ref.length; l < len; l++) {
          player = ref[l];
          ref1 = player.items;
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            item = ref1[o];
            item.template = item.template.name;
          }
          ref2 = player.equipment;
          for (k in ref2) {
            item = ref2[k];
            if (item) {
              player.equipment[k] = item.id;
            }
          }
        }
        if (copy.bag) {
          ref3 = copy.bag.items;
          for (p = 0, len2 = ref3.length; p < len2; p++) {
            item = ref3[p];
            item.template = item.template.name;
          }
        }
        return copy;
      }

      loadGame(json) {
        var l, len, obj, player, ref, saved;
        saved = JSON.parse(json);
        this.players = [];
        ref = saved.players;
        for (l = 0, len = ref.length; l < len; l++) {
          obj = ref[l];
          player = new Player(obj.character);
          player.fromData(obj);
          this.players.push(player);
        }
        this.map = saved.map;
        this.x = saved.x;
        this.y = saved.y;
        this.gold = saved.gold;
        this.ships = saved.ships;
        this.markers = saved.markers;
        this.visited = saved.visited;
        this.moveNum = saved.moveNum;
        this.itemId = saved.itemId;
        if (saved.bag) {
          this.bag = new Player(saved.bag.character);
          this.bag.fromData(saved.bag);
        }
        this.buildFeatures();
        return true;
      }

      createBag() {
        if (!this.bag) {
          return this.bag = new Player(Library.getCharacterByName("Bag of Holding"));
        }
      }

      death() {
        var l, len, player, ref;
        this.ships = {};
        ref = this.players;
        for (l = 0, len = ref.length; l < len; l++) {
          player = ref[l];
          player.healCompletely();
        }
        this.gold = 0;
        return this.buildFeatures();
      }

      getStart() {
        var best, l, len, ref, start;
        best = Data.start[0];
        ref = Data.start;
        for (l = 0, len = ref.length; l < len; l++) {
          start = ref[l];
          if (start.after && this.hasMarker(start.after)) {
            best = start;
          }
        }
        return best;
      }

      static getKey(x, y) {
        return "" + x + "_" + y;
      }

      setMarkers(listOrSingle) {
        var a, l, len, newMarkers;
        if (listOrSingle === "bagOfHolding" && !this.bag) {
          this.createBag();
        }
        if (listOrSingle === "gameOver") {
          Device.setSetting("won", true);
        }
        newMarkers = false;
        if (listOrSingle) {
          if (listOrSingle instanceof Array) {
            for (l = 0, len = listOrSingle.length; l < len; l++) {
              a = listOrSingle[l];
              if (!this.markers[a]) {
                this.markers[a] = true;
                newMarkers = true;
              }
            }
          } else {
            if (!this.markers[listOrSingle]) {
              this.markers[listOrSingle] = true;
              newMarkers = true;
            }
          }
        }
        if (newMarkers) {
          this.buildFeatures();
        }
        return newMarkers;
      }

      hasMarker(marker) {
        return !!this.markers[marker];
      }

      hasAllMarkers(listOrSingle) {
        var a, l, len;
        if (listOrSingle) {
          if (listOrSingle instanceof Array) {
            for (l = 0, len = listOrSingle.length; l < len; l++) {
              a = listOrSingle[l];
              if (!this.markers[a]) {
                return false;
              }
            }
          } else {
            if (!this.markers[listOrSingle]) {
              return false;
            }
          }
        }
        return true;
      }

      hasAnyMarkers(listOrSingle) {
        var a, l, len;
        if (listOrSingle) {
          if (listOrSingle instanceof Array) {
            for (l = 0, len = listOrSingle.length; l < len; l++) {
              a = listOrSingle[l];
              if (this.markers[a]) {
                return true;
              }
            }
          } else {
            if (this.markers[listOrSingle]) {
              return true;
            }
          }
        }
        return false;
      }

      buildFeatures() {
        var feature, key, l, len, list, object, results1, x, y;
        list = Data.maps[this.map].features;
        this.features = {};
        this.shops = {};
        if (list) {
          results1 = [];
          for (l = 0, len = list.length; l < len; l++) {
            feature = list[l];
            if (this.hasAllMarkers(feature.after) && !this.hasAnyMarkers(feature.until) && !this.hasAnyMarkers(feature.id)) {
              x = feature.x;
              y = feature.y;
              // If it's a ship, it may have moved
              if (feature.type === "ship" && this.ships[feature.id]) {
                ({x, y} = this.ships[feature.id]);
              }
              key = Game.getKey(x, y);
              object = this.features[key];
              if (!object) {
                object = {};
                this.features[key] = object;
              }
              object[feature.type] = feature;
              if (feature.type === "shop") {
                results1.push(this.populateShopItems(key, feature));
              } else {
                results1.push(void 0);
              }
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }
      }

      populateShopItems(key, shop) {
        var i, item, items, l, ref, results1;
        items = [];
        this.shops[key] = items;
        results1 = [];
        for (i = l = 0, ref = Game.NUM_SHOP_ITEMS; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          item = this.getRandomItem(shop.level, shop.groups);
          if (item) {
            results1.push(items.push(item));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      getShopItems(x, y) {
        var key;
        key = Game.getKey(x, y);
        return this.shops[key];
      }

      isChartered(shipID) {
        if (this.ships[shipID]) {
          return true;
        } else {
          return false;
        }
      }

      boardShip(shipID) {
        this.aboard = shipID;
        return this.moveShip(this.x, this.y);
      }

      moveShip(x, y) {
        var feature, key, object, oldKey, oldPos, pos;
        oldPos = this.ships[this.aboard];
        if (oldPos) {
          oldKey = Game.getKey(oldPos.x, oldPos.y);
          object = this.features[oldKey];
          if (object) {
            feature = object["ship"];
            if (object) {
              delete object["ship"];
              if (Util.isEmpty(object)) {
                delete this.features[oldKey];
              }
            }
          }
        } else {
          feature = this.getFeature(x, y, "ship");
        }
        key = Game.getKey(x, y);
        pos = {
          "x": x,
          "y": y
        };
        this.ships[this.aboard] = pos;
        object = this.features[key];
        if (!object) {
          object = {};
        }
        this.features[key] = object;
        return object["ship"] = feature;
      }

      disembark() {
        return this.aboard = null;
      }

      getCombatMap() {
        return this.getTerrainInfo().combatMap;
      }

      getFeatures(x, y) {
        var key;
        key = Game.getKey(x, y);
        return this.features[key];
      }

      getFeature(x, y, type) {
        var key, object;
        key = Game.getKey(x, y);
        object = this.features[key];
        if (!object) {
          return null;
        } else {
          return object[type];
        }
      }

      addPlayer(player) {
        return this.players.push(player);
      }

      getVisitedArray() {
        var array, l, o, ref, ref1, x, y;
        array = this.visited[this.map];
        if (!array) {
          array = Util.create2DArray(Data.maps[this.map].width, Data.maps[this.map].height);
          for (y = l = 0, ref = Data.maps[this.map].height; (0 <= ref ? l < ref : l > ref); y = 0 <= ref ? ++l : --l) {
            for (x = o = 0, ref1 = Data.maps[this.map].width; (0 <= ref1 ? o < ref1 : o > ref1); x = 0 <= ref1 ? ++o : --o) {
              array[y][x] = 0;
            }
          }
          this.visited[this.map] = array;
        }
        return array;
      }

      markVisited(x, y) {
        var array;
        array = this.getVisitedArray();
        return array[y][x] = 1;
      }

      wasVisited(x, y) {
        var array;
        array = this.getVisitedArray();
        return array[y][x] === 1;
      }

      moveTo(x, y) {
        this.x = x;
        this.y = y;
        if (this.aboard) {
          return this.moveShip(x, y);
        }
      }

      transitionTo(map, x, y) {
        this.map = map;
        this.buildFeatures();
        this.x = x;
        return this.y = y;
      }

      doesItemExist(name) {
        var item, k, l, len, len1, o, player, ref, ref1, shop;
        ref = this.players;
        //# 1) Check all players
        for (l = 0, len = ref.length; l < len; l++) {
          player = ref[l];
          if (player.hasItem(name)) {
            return true;
          }
        }
        if (this.bag && this.bag.hasItem(name)) {
          return true;
        }
        ref1 = this.shops;
        //# 2) Check all shops
        for (k in ref1) {
          shop = ref1[k];
          for (o = 0, len1 = shop.length; o < len1; o++) {
            item = shop[o];
            if (item.template.name === name) {
              return true;
            }
          }
        }
        return false;
      }

      createItem(template, bonus = 0, charges = 0) {
        this.itemId++;
        return new Item(template, this.itemId, bonus, charges);
      }

      getRandomTemplate(templates) {
        var l, len, len1, o, rarity, ref, ref1, sum, template, value;
        sum = 0;
        for (l = 0, len = templates.length; l < len; l++) {
          template = templates[l];
          sum += (ref = template.rarity) != null ? ref : 1000;
        }
        value = Util.random(0, sum - 1);
        for (o = 0, len1 = templates.length; o < len1; o++) {
          template = templates[o];
          rarity = (ref1 = template.rarity) != null ? ref1 : 1000;
          if (rarity > value) {
            return template;
          } else {
            value -= rarity;
          }
        }
        return null;
      }

      getRandomItem(mapLevel, groups) {
        var attempts, bonus, chance, charges, i, l, level, levelDiffFactor, modChance, realLevel, ref, template, templates;
        level = Library.getLevelNear(mapLevel);
        templates = Library.getItemTemplates(level, groups);
        realLevel = level;
        while (templates === null && realLevel > 1) {
          realLevel--;
          templates = Library.getItemTemplates(realLevel, groups);
        }
        level = realLevel;
        if (templates && templates.length > 0) {
          attempts = 0;
          template = null;
          while (template === null && attempts < 5) {
            attempts++;
            template = this.getRandomTemplate(templates);
            if (template.legendary) {
              if (this.doesItemExist(template.name)) {
                template = null;
              }
            }
          }
          if (template === null) {
            return null;
          } else {
            bonus = 0;
            if (!template.legendary) {
              modChance = 1;
              levelDiffFactor = mapLevel - level + 2;
              if (levelDiffFactor > 0) {
                for (i = l = 0, ref = levelDiffFactor; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
                  modChance *= 2;
                }
              }
              if (modChance > 75) {
                modChance = 75;
              }
              chance = Util.random(0, 99);
              while (chance < modChance && bonus < 6) {
                bonus++;
                chance = Util.random(0, 99);
              }
            }
            if (template.chargesMin) {
              charges = Util.random(template.chargesMin, template.chargesMax);
            } else {
              charges = 0;
            }
            return this.createItem(template, bonus, charges);
          }
        } else {
          return null;
        }
      }

      playersNeedHealing() {
        var l, len, player, ref;
        ref = this.players;
        for (l = 0, len = ref.length; l < len; l++) {
          player = ref[l];
          if (player.hitPoints < player.maxHitPoints) {
            return true;
          }
        }
        return false;
      }

      healParty() {
        var l, len, player, ref, results1;
        ref = this.players;
        results1 = [];
        for (l = 0, len = ref.length; l < len; l++) {
          player = ref[l];
          results1.push(player.healCompletely());
        }
        return results1;
      }

      regenerateParty() {
        var l, len, player, ref, results1;
        ref = this.players;
        results1 = [];
        for (l = 0, len = ref.length; l < len; l++) {
          player = ref[l];
          if (player.isAlive()) {
            if (player.hitPoints < player.maxHitPoints) {
              player.hitPoints++;
            }
            if (player.spellPoints < player.maxSpellPoints) {
              results1.push(player.spellPoints++);
            } else {
              results1.push(void 0);
            }
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      static getCreatureQuantity(creatureLevel, mapLevel, limit = false) {
        var amount, diff;
        diff = creatureLevel - mapLevel;
        if (diff < -3) {
          diff = -3;
        } else if (diff > 3) {
          diff = 3;
        }
        switch (diff) {
          case -3:
            amount = Util.random(3, 9);
            break;
          case -2:
            amount = Util.random(2, 5);
            break;
          case -1:
            amount = Util.random(1, 4);
            break;
          case 0:
            amount = Util.random(1, 3);
            break;
          default:
            amount = 1;
        }
        if (limit) {
          amount = Math.round(amount / 2);
          if (amount < 1) {
            amount = 1;
          }
          if (amount > 2) {
            amount = 2;
          }
        }
        return amount;
      }

      getEncounter(feature) {
        var ambushed, bonus, charges, creature, creatures, gold, hpBonus, item, items, l, len, len1, o, ref, ref1, ref2, ref3, ref4, ref5, template;
        creatures = [];
        ref = feature.creatures;
        for (l = 0, len = ref.length; l < len; l++) {
          creature = ref[l];
          template = Library.getCreatureByName(creature.name);
          bonus = (ref1 = creature.bonus) != null ? ref1 : 0;
          hpBonus = (ref2 = creature.hitPoints) != null ? ref2 : 0;
          creature = new Creature(template, bonus);
          creature.maxHitPoints += hpBonus;
          creature.hitPoints += hpBonus;
          creatures.push(creature);
        }
        items = [];
        ref3 = feature.items;
        for (o = 0, len1 = ref3.length; o < len1; o++) {
          item = ref3[o];
          template = Library.getItemTemplateByName(item.name);
          bonus = (ref4 = item.bonus) != null ? ref4 : 0;
          if (template.chargesMin) {
            charges = Util.random(template.chargesMin, template.chargesMax);
          } else {
            charges = 0;
          }
          items.push(this.createItem(template, bonus, charges));
        }
        gold = (ref5 = feature.gold) != null ? ref5 : 0;
        if (feature.ambushed) {
          ambushed = true;
        } else {
          ambushed = false;
        }
        return {
          "creatures": creatures,
          "items": items,
          "gold": gold,
          "ambushed": ambushed
        };
      }

      giveExperience(creatures) {
        var attr, attrBonuses, awarenessBonus, constitutionBonus, creature, hitPointBonus, i, l, len, len1, len2, newSpells, o, p, player, q, ref, ref1, spellPointBonus, totalPlayers, totalXP, upgrades, xp;
        totalXP = 0;
        for (l = 0, len = creatures.length; l < len; l++) {
          creature = creatures[l];
          totalXP += creature.template.experienceValue;
        }
        totalPlayers = 0;
        ref = this.players;
        for (o = 0, len1 = ref.length; o < len1; o++) {
          player = ref[o];
          if (player.isAlive()) {
            totalPlayers++;
          }
        }
        xp = Math.ceil(totalXP / totalPlayers);
        upgrades = [];
        ref1 = this.players;
        for (p = 0, len2 = ref1.length; p < len2; p++) {
          player = ref1[p];
          if (player.isAlive()) {
            player.experience += xp;
            if (player.experience >= Data.levels[player.level]) {
              // Level up
              player.level++;
              attrBonuses = [0, 0, 0, 0];
              for (i = q = 0; q < 2; i = ++q) {
                attr = Util.random(0, 3);
                attrBonuses[attr]++;
                switch (attr) {
                  case 0:
                    player.strength++;
                    break;
                  case 1:
                    player.accuracy++;
                    break;
                  case 2:
                    player.awareness++;
                    break;
                  case 3:
                    player.constitution++;
                }
              }
              constitutionBonus = player.getAttributeBonus(player.getConstitution());
              awarenessBonus = player.getAttributeBonus(player.getAwareness());
              hitPointBonus = Util.random(2, 8) + constitutionBonus;
              if (hitPointBonus < 1) {
                hitPointBonus = 1;
              }
              if (player.hasSpells()) {
                spellPointBonus = Util.random(1, 5) + awarenessBonus;
                if (spellPointBonus < 1) {
                  spellPointBonus = 1;
                }
                if (player.maxSpellPoints === 0) {
                  player.spellPoints = 0;
                }
              } else {
                spellPointBonus = 0;
              }
              player.maxHitPoints += hitPointBonus;
              player.hitPoints += hitPointBonus;
              player.maxSpellPoints += spellPointBonus;
              player.spellPoints += spellPointBonus;
              newSpells = Library.newSpellsForCharacterAndLevel(player.character, player.level);
              upgrades.push({
                "player": player,
                "attrBonuses": attrBonuses,
                "hitPointBonus": hitPointBonus,
                "spellPointBonus": spellPointBonus,
                "newSpells": newSpells
              });
            }
          }
        }
        return upgrades;
      }

      getAveragePlayerLevel() {
        var l, len, player, ref, total;
        total = 0;
        ref = this.players;
        for (l = 0, len = ref.length; l < len; l++) {
          player = ref[l];
          if (player.isAlive()) {
            total += player.level;
          }
        }
        return total / 3;
      }

      getTile(x, y) {
        var index, override;
        override = this.getFeature(x, y, "override");
        if (override) {
          return override.tile;
        } else {
          index = y * Data.maps[this.map].width + x;
          return Data.maps[this.map].map.charAt(index);
        }
      }

      getTerrainInfo() {
        var map, ref, terrain, tile;
        tile = this.getTile(this.x, this.y);
        terrain = (ref = Data.maps[this.map].terrain) != null ? ref[tile] : void 0;
        if (terrain) {
          return terrain;
        } else {
          map = Data.maps[this.map];
          return {
            level: map.level,
            encounterChance: map.encounterChance,
            combatMap: map.combatMap,
            groups: map.groups
          };
        }
      }

      checkForRandomEncounter() {
        var chance, dungeonLevel, encounterChance, terrain;
        terrain = this.getTerrainInfo();
        encounterChance = terrain.encounterChance;
        if (encounterChance) {
          dungeonLevel = terrain.level;
          chance = encounterChance;
          if (dungeonLevel < 10) { // Don't filter encounters over a certain level, for indefinite play
            chance = chance / Math.max(1, this.getAveragePlayerLevel() - dungeonLevel - 1.5);
          }
          if (Util.randomChance(chance, 1000)) {
            return true;
          }
        }
        return false;
      }

      createEncounter() {
        var ambushed, candidates, creature, creatures, full, gold, groups, i, item, items, j, k, l, len, len1, level, mapLevel, max, maxGold, n, o, other, p, q, ref, ref1, ref2, s, template, terrain, treasureLevel, unique;
        terrain = this.getTerrainInfo();
        mapLevel = terrain.level;
        groups = terrain.groups;
        creatures = [];
        k = Util.random(1, 3);
        full = false;
        for (i = l = 0, ref = k; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
          if (!full) {
            level = Library.getLevelNear(mapLevel);
            candidates = Library.getCreatures(level, groups);
            while (candidates.length === 0 && level > 0) {
              level--;
              candidates = Library.getCreatures(level, groups);
            }
            if (candidates.length > 0) {
              template = Util.randomElement(candidates);
              n = Game.getCreatureQuantity(template.level, mapLevel, template.limit);
              if (template.summons) {
                n = Math.min(n, 2);
              }
              for (j = o = 0, ref1 = n; (0 <= ref1 ? o < ref1 : o > ref1); j = 0 <= ref1 ? ++o : --o) {
                // Todo - maybe have a chance of an "uber" version of creature here, with a bonus?
                creatures.push(new Creature(template, 0));
                if (creatures.length === Game.MAX_ENCOUNTER_CREATURES) {
                  full = true;
                  break;
                }
              }
            }
          }
        }
        items = [];
        gold = 0;
        for (p = 0, len = creatures.length; p < len; p++) {
          creature = creatures[p];
          maxGold = 2;
          for (i = q = 0, ref2 = creature.template.level - 1; (0 <= ref2 ? q < ref2 : q > ref2); i = 0 <= ref2 ? ++q : --q) {
            if (i > 9) {
              maxGold = maxGold * 1.1;
            } else if (i > 2) {
              maxGold = maxGold * 1.4;
            } else {
              maxGold = maxGold * 1.8;
            }
          }
          max = Math.round(maxGold);
          gold += Util.random(0, max);
          treasureLevel = creature.template.level;
          if (treasureLevel > 10) {
            treasureLevel = 10;
          }
          if (Util.randomChance(Data.treasureChance[treasureLevel - 1], 1000)) {
            item = this.getRandomItem(creature.template.level, groups);
            if (item) {
              if (item.template.legendary) {
                unique = true;
                for (s = 0, len1 = items.length; s < len1; s++) {
                  other = items[s];
                  if (other.template.name === item.template.name) {
                    unique = false;
                    break;
                  }
                }
                if (!unique) {
                  item = null;
                }
              }
            }
            if (item) {
              items.push(item);
            }
            if (items.length === 5) {
              break;
            }
          }
        }
        ambushed = Util.randomChance(25, 100);
        return {
          "creatures": creatures,
          "items": items,
          "gold": gold,
          "ambushed": ambushed
        };
      }

    };

    Game.MAX_ENCOUNTER_CREATURES = 18;

    Game.NUM_SHOP_ITEMS = 15;

    Game.prototype.players = null;

    Game.prototype.bag = null;

    Game.prototype.gold = 0;

    Game.prototype.map = null;

    Game.prototype.x = 0;

    Game.prototype.y = 0;

    Game.prototype.itemId = 0;

    Game.prototype.moveNum = 0;

    // Record of what squares have been visited
    Game.prototype.visited = null;

    // Transient - current map features
    Game.prototype.features = null;

    // Map of ship ID to current location (ship will not be here if not yet chartered)
    Game.prototype.ships = null;

    // Map of game variables to 'true' if completed.
    Game.prototype.markers = null;

    // Map of shop key to items (transient)
    Game.prototype.shops = null;

    // If currently in a ship, this will be its ID
    Game.prototype.aboard = null;

    return Game;

  }).call(this);

  ChooseCharacterView = (function() {
    class ChooseCharacterView extends SelectView {
      constructor(gurk, type1, game1) {
        super(gurk, "CHOOSE", "DONE");
        this.doLayout = this.doLayout.bind(this);
        this.itemSelected = this.itemSelected.bind(this);
        this.itemHighlighted = this.itemHighlighted.bind(this);
        this.command = this.command.bind(this);
        this.processResult = this.processResult.bind(this);
        this.type = type1;
        this.game = game1;
      }

      doLayout() {
        var character, def, l, len, len1, o, ref, ref1, results1, y;
        boundMethodCheck(this, ChooseCharacterView);
        this.characters = [];
        ref = Data.characters;
        for (l = 0, len = ref.length; l < len; l++) {
          character = ref[l];
          if (character.type === this.type) {
            if (!character.after || Device.getSetting(character.after, false)) {
              this.characters.push(character);
            }
          }
        }
        this.clearButton(7);
        this.clearButton(9);
        this.setButton(1, "INFO");
        this.clear();
        y = 3;
        def = "a";
        if (this.type === "archer") {
          def = "an";
        }
        this.addLabelCentered(`Choose ${def} ${Util.capitalize(this.type)}`, "#FFF", 0, y, 128, Screen.FONT.fontHeight);
        y += 8;
        this.addLabelCentered("(Press INFO to learn more)", "#A0A0A0", 0, y, 128, Screen.FONT.fontHeight);
        // bestAttribute = Util.capitalize(@characters[0].bestAttribute)
        y += 12;
        ref1 = this.characters;
        results1 = [];
        for (o = 0, len1 = ref1.length; o < len1; o++) {
          character = ref1[o];
          this.addIcon(character.icon, 2, y);
          this.addOption(character.name, "#FFF", 20, y);
          y += 8;
          this.addLabel(`Level 1 ${character.job}`, "#A0A0A0", 20, y);
          // @doAttributes(y, character)
          results1.push(y += 20);
        }
        return results1;
      }

      itemSelected(index, item) {
        boundMethodCheck(this, ChooseCharacterView);
        return this.gurk.pushView(new CharacterRollView(this.gurk, this.game, this.characters[this.selected]));
      }

      itemHighlighted(index, item) {
        boundMethodCheck(this, ChooseCharacterView);
        if (index === 0) {
          this.fiddles++;
          if (this.fiddles > 10) {
            Device.setSetting("won", true);
            this.doLayout();
            return this.fiddles = 0;
          }
        }
      }

      command(text) {
        boundMethodCheck(this, ChooseCharacterView);
        if (text === "INFO") {
          return this.gurk.pushView(new CharacterInfoView(this.gurk, this.characters[this.selected]));
        } else {
          return super.command(text);
        }
      }

      processResult(result) {
        boundMethodCheck(this, ChooseCharacterView);
        if (result === "NEXT") {
          return this.gurk.popView(result);
        }
      }

    };

    ChooseCharacterView.prototype.characters = null;

    ChooseCharacterView.prototype.fiddles = 0;

    return ChooseCharacterView;

  }).call(this);

  CharacterInfoView = (function() {
    // -----------------------------------------------------------------------------
    class CharacterInfoView extends InfoView {
      constructor(gurk, character1) {
        var y;
        super(gurk, "BACK");
        this.doAttributes = this.doAttributes.bind(this);
        this.doDraw = this.doDraw.bind(this);
        this.character = character1;
        this.addIcon(this.character.icon, 3, 3);
        y = 4;
        this.addLabel(`${this.character.name}`, "#FFF", 20, y);
        y += 8;
        this.addLabel(`Level 1 ${this.character.job}`, "#A0A0A0", 20, y);
        y += 12;
        this.blurbY = this.doAttributes(y) + 4;
      }

      doAttributes(y) {
        var attribute, l, len, name, ref, value;
        boundMethodCheck(this, CharacterInfoView);
        ref = CharacterInfoView.ATTRIBUTES;
        for (l = 0, len = ref.length; l < len; l++) {
          attribute = ref[l];
          if (this.character[attribute]) {
            value = this.character[attribute];
            if (value > 0) {
              value = "+" + value;
            }
            name = Util.capitalize(attribute);
            if (name === "Constitution") {
              name = "Toughness";
            }
            this.addLabel(`${name}: ${value}`, "#FFF", 3, y);
            y += 8;
          }
        }
        return y;
      }

      doDraw() {
        boundMethodCheck(this, CharacterInfoView);
        super.doDraw();
        return this.screen.wrapText(this.character.description, "#A0A0A0", 3, this.blurbY, 122);
      }

    };

    CharacterInfoView.ATTRIBUTES = ["strength", "accuracy", "awareness", "constitution"];

    CharacterInfoView.prototype.blurbY = 0;

    return CharacterInfoView;

  }).call(this);

  CharacterRollView = (function() {
    // -----------------------------------------------------------------------------
    class CharacterRollView extends InfoView {
      constructor(gurk, game1, character1) {
        super(gurk, "KEEP");
        this.roll = this.roll.bind(this);
        this.command = this.command.bind(this);
        this.game = game1;
        this.character = character1;
        this.setButton(1, "REROLL");
        this.setButton(7, "BACK");
        this.roll();
      }

      roll() {
        var accuracyBonus, awarenessBonus, constitutionBonus, levelUp, strengthBonus, y;
        boundMethodCheck(this, CharacterRollView);
        this.player = new Player(this.character);
        this.clear();
        this.addIcon(this.player.character.icon, 3, 3);
        y = 4;
        this.addLabel(this.player.character.name, "#FFF", 20, y);
        y += 8;
        this.addLabel(`Level ${this.player.level} ${this.player.character.job}`, "#FFF", 20, y);
        y += 8;
        levelUp = Data.levels[this.player.level + 1];
        this.addLabel(`XP: ${this.player.experience}/${levelUp}`, "#FFF", 20, y);
        y += 8;
        if (this.player.maxSpellPoints > 0) {
          this.addLabel(`HP: ${this.player.hitPoints}/${this.player.maxHitPoints}, SP: ${this.player.spellPoints}/${this.player.maxSpellPoints}`, "#FFF", 20, y);
        } else {
          this.addLabel(`Hit Points: ${this.player.hitPoints}/${this.player.maxHitPoints}`, "#FFF", 20, y);
        }
        y += 8;
        this.addLabel(`Armor Class: ${this.player.getArmorClass()}`, "#FFF", 20, y);
        y += 16;
        this.addLabel(`Strength: ${this.player.getStrength()}`, "#FFF", 20, y);
        y += 8;
        strengthBonus = this.player.getAttributeBonus(this.player.getStrength());
        if (strengthBonus !== 0) {
          this.addLabel(`Damage Bonus: ${strengthBonus}`, "#A0A0A0", 28, y);
        }
        y += 10;
        this.addLabel(`Accuracy: ${this.player.getAccuracy()}`, "#FFF", 20, y);
        y += 8;
        accuracyBonus = this.player.getAttributeBonus(this.player.getAccuracy());
        if (accuracyBonus !== 0) {
          this.addLabel(`To-Hit Bonus: ${accuracyBonus}`, "#A0A0A0", 28, y);
        }
        y += 10;
        this.addLabel(`Awareness: ${this.player.getAwareness()}`, "#FFF", 20, y);
        y += 8;
        awarenessBonus = this.player.getAttributeBonus(this.player.getAwareness());
        if (awarenessBonus !== 0) {
          this.addLabel(`Armor Class Bonus: ${awarenessBonus}`, "#A0A0A0", 28, y);
        }
        y += 10;
        this.addLabel(`Toughness: ${this.player.getConstitution()}`, "#FFF", 20, y);
        y += 8;
        constitutionBonus = this.player.getAttributeBonus(this.player.getConstitution());
        if (constitutionBonus !== 0) {
          return this.addLabel(`HP Bonus/Level: ${constitutionBonus}`, "#A0A0A0", 28, y);
        }
      }

      command(text) {
        boundMethodCheck(this, CharacterRollView);
        switch (text) {
          case "KEEP":
            this.game.addPlayer(this.player);
            return this.gurk.popView("NEXT");
          case "BACK":
            return this.gurk.popView("BACK");
          case "REROLL":
            this.roll();
            return this.draw();
        }
      }

    };

    CharacterRollView.prototype.player = null;

    return CharacterRollView;

  }).call(this);

  CreateView = (function() {
    // -----------------------------------------------------------------------------
    class CreateView extends InfoView {
      constructor(gurk) {
        super(gurk, "KEEP");
        this.getCharacters = this.getCharacters.bind(this);
        this.roll = this.roll.bind(this);
        this.command = this.command.bind(this);
        this.types = ["warrior", "archer", "mage"];
        this.index = 0;
        this.setButton(1, "REROLL");
        this.game = new Game();
        this.getCharacters();
        this.roll();
      }

      getCharacters() {
        var character, l, len, ref, type;
        boundMethodCheck(this, CreateView);
        this.characters = [];
        type = this.types[this.index];
        ref = Data.characters;
        for (l = 0, len = ref.length; l < len; l++) {
          character = ref[l];
          if (character.type === type) {
            this.characters.push(character);
          }
        }
        return this.charIndex = 0;
      }

      roll() {
        var accuracyBonus, awarenessBonus, character, constitutionBonus, levelUp, strengthBonus, y;
        boundMethodCheck(this, CreateView);
        character = this.characters[this.charIndex];
        this.player = new Player(character);
        this.clear();
        this.addIcon(this.player.character.icon, 3, 3);
        y = 4;
        this.addLabel(this.player.character.name, "#FFF", 20, y);
        y += 8;
        this.addLabel(`Level ${this.player.level} ${this.player.character.job}`, "#FFF", 20, y);
        y += 8;
        levelUp = Data.levels[this.player.level + 1];
        this.addLabel(`XP: ${this.player.experience}/${levelUp}`, "#FFF", 20, y);
        y += 8;
        // todo - add spell points if there are any, use HP, SP
        if (this.player.maxSpellPoints > 0) {
          this.addLabel(`HP: ${this.player.hitPoints}/${this.player.maxHitPoints}, SP: ${this.player.spellPoints}/${this.player.maxSpellPoints}`, "#FFF", 20, y);
        } else {
          this.addLabel(`Hit Points: ${this.player.hitPoints}/${this.player.maxHitPoints}`, "#FFF", 20, y);
        }
        y += 8;
        this.addLabel(`Armor Class: ${this.player.getArmorClass()}`, "#FFF", 20, y);
        y += 16;
        this.addLabel(`Strength: ${this.player.getStrength()}`, "#FFF", 20, y);
        y += 8;
        strengthBonus = this.player.getAttributeBonus(this.player.getStrength());
        if (strengthBonus !== 0) {
          this.addLabel(`Damage Bonus: ${strengthBonus}`, "#A0A0A0", 28, y);
        }
        y += 10;
        this.addLabel(`Accuracy: ${this.player.getAccuracy()}`, "#FFF", 20, y);
        y += 8;
        accuracyBonus = this.player.getAttributeBonus(this.player.getAccuracy());
        if (accuracyBonus !== 0) {
          this.addLabel(`To-Hit Bonus: ${accuracyBonus}`, "#A0A0A0", 28, y);
        }
        y += 10;
        this.addLabel(`Awareness: ${this.player.getAwareness()}`, "#FFF", 20, y);
        y += 8;
        awarenessBonus = this.player.getAttributeBonus(this.player.getAwareness());
        if (awarenessBonus !== 0) {
          this.addLabel(`Armor Class Bonus: ${awarenessBonus}`, "#A0A0A0", 28, y);
        }
        y += 10;
        this.addLabel(`Toughness: ${this.player.getConstitution()}`, "#FFF", 20, y);
        y += 8;
        constitutionBonus = this.player.getAttributeBonus(this.player.getConstitution());
        if (constitutionBonus !== 0) {
          return this.addLabel(`HP Bonus/Level: ${constitutionBonus}`, "#A0A0A0", 28, y);
        }
      }

      command(text) {
        boundMethodCheck(this, CreateView);
        switch (text) {
          case "KEEP":
            this.game.addPlayer(this.player);
            this.index++;
            if (this.index === this.types.length) {
              return this.gurk.startNewGame(this.game);
            } else {
              this.getCharacters();
              this.roll();
              return this.draw();
            }
            break;
          case "REROLL":
            this.charIndex++;
            if (this.charIndex === this.characters.length) {
              this.charIndex = 0;
            }
            this.roll();
            return this.draw();
        }
      }

    };

    CreateView.prototype.index = 0;

    CreateView.prototype.charIndex = 0;

    CreateView.prototype.types = null;

    CreateView.prototype.characters = null;

    CreateView.prototype.player = null;

    CreateView.prototype.game = null;

    return CreateView;

  }).call(this);

  SplashView = (function() {
    // -----------------------------------------------------------------------------
    class SplashView extends TileView {
      constructor(gurk) {
        super(gurk, "splashScreen");
        this.doLayout = this.doLayout.bind(this);
        this.doDraw = this.doDraw.bind(this);
        this.showIntro = this.showIntro.bind(this);
        this.command = this.command.bind(this);
        this.processResult = this.processResult.bind(this);
        this.name = "Splash";
        this.offsetX = -Screen.HALF_UNIT;
        this.offsetY = -Screen.HALF_UNIT;
        this.index = 0;
      }

      doLayout() {
        boundMethodCheck(this, SplashView);
        this.setButton(1, "NEW");
        if (Device.hasSavedGame()) {
          this.setButton(3, "LOAD");
        } else {
          this.clearButton(3);
        }
        this.setButton(7, "OPTIONS");
        // Uncomment to have a hook to validate game data
        return this.setButton(9, "CHECK");
      }

      doDraw() {
        var feature, l, len, o, p, ref, ref1, ref2, results1, tile, x, y;
        boundMethodCheck(this, SplashView);
        console.log("Splash View drawing.");
        for (y = l = 0, ref = this.height; (0 <= ref ? l < ref : l > ref); y = 0 <= ref ? ++l : --l) {
          for (x = o = 0, ref1 = this.width; (0 <= ref1 ? o < ref1 : o > ref1); x = 0 <= ref1 ? ++o : --o) {
            tile = this.getTerrainIcon(x, y);
            this.drawTile(tile, x, y);
          }
        }
        ref2 = this.map.features;
        results1 = [];
        for (p = 0, len = ref2.length; p < len; p++) {
          feature = ref2[p];
          results1.push(this.drawTile(feature.icon, feature.x, feature.y));
        }
        return results1;
      }

      showIntro() {
        boundMethodCheck(this, SplashView);
        return this.gurk.pushView(new AlertView(this.gurk, Data.icons.party, "Welcome", "Welcome to realm of Gurk!\n\nRoll the stats for your Warrior, Archer and Mage, then lead them on to thrilling adventure!", "CREATE"));
      }

      command(text) {
        var flow;
        boundMethodCheck(this, SplashView);
        switch (text) {
          case "NEW":
            if (Device.hasSavedGame()) {
              return this.gurk.pushView(new ConfirmView(this.gurk, Data.icons.party, "Warning!", "Creating a new game will delete your existing game. Are you sure you want to do this?", "NEW", "CANCEL"));
            } else {
              // @gurk.startTestGame()
              return this.showIntro();
            }
            break;
          case "LOAD":
            return this.gurk.startSavedGame();
          case "TEST":
            return this.gurk.startTestGame();
          case "OPTIONS":
            return this.gurk.showSettings();
          case "CHECK":
            return Validate.run();
          case "FLOW":
            flow = new FlowView(this.gurk, Data.icons.death, "Flow View", null);
            flow.addParagraph("Berserk", "#FFF");
            flow.addParagraph("While berserk, combatant will get an extra attack (or spell cast) each turn.", "#A0A0A0");
            flow.addGap();
            flow.addParagraph("Blinded", "#FFF");
            flow.addParagraph("When blinded, combatant's chance to hit when attack will be reduced considerably.", "#A0A0A0");
            flow.addGap();
            flow.addParagraph("Rooted", "#FFF");
            flow.addParagraph("A rooted combatant cannot move, although it may still attack and cast spells.", "#A0A0A0");
            return this.gurk.pushView(flow);
        }
      }

      processResult(result) {
        boundMethodCheck(this, SplashView);
        switch (result) {
          case "NEW":
            //@gurk.startTestGame()
            return this.showIntro();
          case "CREATE":
            //@gurk.setView(new CreateView(@gurk))
            this.game = new Game();
            return this.gurk.pushView(new ChooseCharacterView(this.gurk, SplashView.TYPES[this.index], this.game));
          case "NEXT":
            this.index++;
            if (this.index === SplashView.TYPES.length) {
              return this.gurk.startNewGame(this.game);
            } else {
              return this.gurk.pushView(new ChooseCharacterView(this.gurk, SplashView.TYPES[this.index], this.game));
            }
        }
      }

    };

    SplashView.TYPES = ["warrior", "archer", "mage"];

    SplashView.prototype.index = 0;

    SplashView.prototype.game = null;

    return SplashView;

  }).call(this);

  MapView = (function() {
    // -----------------------------------------------------------------------------
    class MapView extends TileView {
      constructor(gurk) {
        var l, o, x, y;
        super(gurk, gurk.game.map);
        this.toggleMap = this.toggleMap.bind(this);
        this.command = this.command.bind(this);
        this.checkVisibility = this.checkVisibility.bind(this);
        this.computeShadows = this.computeShadows.bind(this);
        this.trackVisited = this.trackVisited.bind(this);
        this.getTerrain = this.getTerrain.bind(this);
        this.doDraw = this.doDraw.bind(this);
        this.getTopFeature = this.getTopFeature.bind(this);
        this.move = this.move.bind(this);
        this.setMap = this.setMap.bind(this);
        this.addButtonForFeature = this.addButtonForFeature.bind(this);
        this.processFeature = this.processFeature.bind(this);
        this.processResult = this.processResult.bind(this);
        this.name = "MapView";
        this.offsetX = -Screen.HALF_UNIT;
        this.offsetY = -Screen.HALF_UNIT;
        this.game = gurk.game;
        this.posX = this.game.x;
        this.posY = this.game.y;
        this.mapMode = false;
        this.shadowOverlay = Preloader.getImage("img/shadow" + Screen.SCALE + ".png");
        this.setButton(1, "HEROES");
        this.setButton(9, "MAP");
        this.setButton(3, "SAVE");
        this.setButton(7, "QUESTS");
        this.shadows = Util.create2DArray(Screen.WIN_SIZE, Screen.WIN_SIZE);
        for (y = l = -1; l <= 1; y = ++l) {
          for (x = o = -1; o <= 1; x = ++o) {
            this.shadows[y + Screen.CENTER_OFFSET][x + Screen.CENTER_OFFSET] = false;
          }
        }
        this.centerBanner = true;
        this.move(0, 0);
      }

      toggleMap() {
        boundMethodCheck(this, MapView);
        this.mapMode = !this.mapMode;
        if (this.mapMode) {
          this.setButton(9, "NO MAP");
        } else {
          this.setButton(9, "MAP");
        }
        return this.draw();
      }

      command(text) {
        var save;
        boundMethodCheck(this, MapView);
        switch (text) {
          case View.LEFT:
            return this.move(-1, 0);
          case View.UP:
            return this.move(0, -1);
          case View.RIGHT:
            return this.move(1, 0);
          case View.DOWN:
            return this.move(0, 1);
          case "MAP":
          case "NO MAP":
            return this.toggleMap();
          case "HEROES":
            return this.gurk.pushView(new PartyView(this.gurk));
          case "QUESTS":
            return this.gurk.pushView(new QuestView(this.gurk));
          case "SAVE":
            save = JSON.stringify(this.game.saveGame());
            // console.log(save)
            Device.saveGame(save);
            return this.gurk.pushView(new AlertView(this.gurk, Data.icons.party, "Game Saved", "Your game has been saved!", null));
          default:
            return this.processFeature(text);
        }
      }

      checkVisibility(x, y) {
        var dx, dy, nx, ny, t1, t2, t3, xx, yy;
        boundMethodCheck(this, MapView);
        dx = x - Screen.CENTER_OFFSET;
        dy = y - Screen.CENTER_OFFSET;
        yy = dy + this.posY;
        xx = dx + this.posX;
        if (yy >= 0 && yy < this.height && xx >= 0 && xx < this.width) {
          nx = dx > 0 ? -1 : 1;
          ny = dy > 0 ? -1 : 1;
          if (dx === 0) {
            return this.shadows[y][x] = this.shadows[ny + y][x] || this.getTerrain(xx, ny + yy).opaque;
          } else if (dy === 0) {
            return this.shadows[y][x] = this.shadows[y][nx + x] || this.getTerrain(nx + xx, yy).opaque;
          } else if (dx === dy || dx === -dy) {
            return this.shadows[y][x] = this.shadows[ny + y][nx + x] || this.getTerrain(nx + xx, ny + yy).opaque;
          } else {
            t1 = this.shadows[ny + y][x] || this.getTerrain(xx, ny + yy).opaque;
            t2 = this.shadows[y][nx + x] || this.getTerrain(nx + xx, yy).opaque;
            t3 = this.shadows[ny + y][nx + x] || this.getTerrain(nx + xx, ny + yy).opaque;
            return this.shadows[y][x] = t1 && t2 && t3;
          }
        } else {
          return this.shadows[y][x] = true;
        }
      }

      computeShadows() {
        var C, i, k, l, o, ref, x, y;
        boundMethodCheck(this, MapView);
        // Immediate surroundings are always visible
        C = Screen.CENTER_OFFSET;
// Move in a spiral pattern, inductively computing visibility
        for (k = l = 2; l <= 4; k = ++l) {
          for (i = o = 0, ref = k; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {
            x = i + C;
            y = k + C;
            this.checkVisibility(x, y);
            x = i + C;
            y = -k + C;
            this.checkVisibility(x, y);
            if (i < k) {
              y = i + C;
              x = k + C;
              this.checkVisibility(x, y);
              y = i + C;
              x = -k + C;
              this.checkVisibility(x, y);
            }
            if (i > 0) {
              x = -i + C;
              y = k + C;
              this.checkVisibility(x, y);
              x = -i + C;
              y = -k + C;
              this.checkVisibility(x, y);
              if (i < k) {
                y = -i + C;
                x = k + C;
                this.checkVisibility(x, y);
                y = -i + C;
                x = -k + C;
                this.checkVisibility(x, y);
              }
            }
          }
        }
        return false;
      }

      trackVisited() {
        var l, ref, results1, x, xx, y, yy;
        boundMethodCheck(this, MapView);
        results1 = [];
        for (y = l = 0, ref = Screen.WIN_SIZE; (0 <= ref ? l < ref : l > ref); y = 0 <= ref ? ++l : --l) {
          yy = y + this.posY - Screen.CENTER_OFFSET;
          if (yy >= 0 && yy < this.height) {
            results1.push((function() {
              var o, ref1, results2;
              results2 = [];
              for (x = o = 0, ref1 = Screen.WIN_SIZE; (0 <= ref1 ? o < ref1 : o > ref1); x = 0 <= ref1 ? ++o : --o) {
                xx = x + this.posX - Screen.CENTER_OFFSET;
                if (xx >= 0 && xx < this.width) {
                  if (!this.map.dark || !this.shadows[y][x]) {
                    results2.push(this.game.markVisited(xx, yy));
                  } else {
                    results2.push(void 0);
                  }
                } else {
                  results2.push(void 0);
                }
              }
              return results2;
            }).call(this));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      getTerrain(x, y) {
        boundMethodCheck(this, MapView);
        return Data.tiles[this.game.getTile(x, y)];
      }

      doDraw() {
        var color, feature, i1, icon, l, o, p, partyIcon, q, ref, ref1, ref2, ref3, ref4, ref5, s, sx, sy, tile, u, x, xx, y, yy, z;
        boundMethodCheck(this, MapView);
        for (y = l = 0, ref = Screen.WIN_SIZE; (0 <= ref ? l < ref : l > ref); y = 0 <= ref ? ++l : --l) {
          yy = y + this.posY - Screen.CENTER_OFFSET;
          if (yy >= 0 && yy < this.height) {
            for (x = o = 0, ref1 = Screen.WIN_SIZE; (0 <= ref1 ? o < ref1 : o > ref1); x = 0 <= ref1 ? ++o : --o) {
              xx = x + this.posX - Screen.CENTER_OFFSET;
              if (xx >= 0 && xx < this.width) {
                if (!this.map.dark || !this.shadows[y][x]) {
                  tile = this.getTerrainIcon(xx, yy);
                  this.drawTile(tile, x, y);
                  if (this.game.getFeatures(xx, yy)) {
                    feature = this.getTopFeature(xx, yy);
                    if (feature && feature.icon) {
                      this.drawTile(feature.icon, x, y);
                    }
                  }
                }
              }
            }
          }
        }
        partyIcon = this.game.aboard ? Data.icons.ship : Data.icons.party;
        this.drawTile(partyIcon, Screen.CENTER_OFFSET, Screen.CENTER_OFFSET);
        if (this.map.dark) {
          this.screen.drawImage(this.shadowOverlay, 0, 0);
        }
        if (this.mapMode) {
          sx = 128 - this.width - 5;
          if (sx < 10) {
            sx = (128 - this.width) / 2;
          }
          sy = 5;
          this.screen.setAlpha(0.5);
          this.screen.fillRect("#000", sx - 3, sy - 3, this.width + 6, this.height + 6);
          this.screen.setAlpha(1);
          this.screen.fillRect("#aaa", sx - 1, sy - 1, this.width + 2, this.height + 2);
          for (y = p = 0, ref2 = this.height; (0 <= ref2 ? p < ref2 : p > ref2); y = 0 <= ref2 ? ++p : --p) {
            for (x = q = 0, ref3 = this.width; (0 <= ref3 ? q < ref3 : q > ref3); x = 0 <= ref3 ? ++q : --q) {
              if (this.game.wasVisited(x, y)) {
                color = this.getTerrain(x, y).color;
              } else {
                color = "#000";
              }
              this.screen.drawPixel(color, x + sx, y + sy);
            }
          }
// Next: features
          for (y = s = 0, ref4 = this.height; (0 <= ref4 ? s < ref4 : s > ref4); y = 0 <= ref4 ? ++s : --s) {
            for (x = u = 0, ref5 = this.width; (0 <= ref5 ? u < ref5 : u > ref5); x = 0 <= ref5 ? ++u : --u) {
              if (this.game.wasVisited(x, y)) {
                feature = this.getTopFeature(x, y);
                if (feature) {
                  icon = null;
                  switch (feature.type) {
                    case "shop":
                    case "ship":
                    case "temple":
                      icon = MapView.MAP_ICONS[feature.type];
                      break;
                    case "transition":
                      icon = MapView.TRANSITION_ICONS[feature.transitionType];
                  }
                  if (icon) {
                    for (yy = z = 0; z < 3; yy = ++z) {
                      for (xx = i1 = 0; i1 < 3; xx = ++i1) {
                        color = icon[yy][xx];
                        if (color) {
                          this.screen.drawPixel(color, sx + x + xx - 1, sy + y + yy - 1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          // Finally, the adventurers
          this.screen.drawPixel("#F00", this.posX + sx - 1, this.posY + sy);
          this.screen.drawPixel("#F00", this.posX + sx + 1, this.posY + sy);
          this.screen.drawPixel("#F00", this.posX + sx, this.posY + sy + 1);
          return this.screen.drawPixel("#F00", this.posX + sx, this.posY + sy - 1);
        } else {
          this.drawBanner();
          return this.drawTopBanner();
        }
      }

      getTopFeature(x, y) {
        var feature, l, len, ref, type;
        boundMethodCheck(this, MapView);
        ref = MapView.FEATURE_TYPES;
        for (l = 0, len = ref.length; l < len; l++) {
          type = ref[l];
          feature = this.game.getFeature(x, y, type);
          if (feature) {
            return feature;
          }
        }
      }

      move(x, y) {
        var barrier, block, feature, gold, haveFeature, realMove, ref, ship, text, title, tx, ty;
        boundMethodCheck(this, MapView);
        realMove = !(x === 0 && y === 0);
        tx = this.posX + x;
        ty = this.posY + y;
        if (tx < 0 || tx >= this.width || ty < 0 || ty >= this.height) {
          return false;
        } else {
          block = this.game.getFeature(tx, ty, "block");
          if (block) {
            return false;
          }
          barrier = this.game.getFeature(tx, ty, "barrier");
          if (barrier) {
            if (!!barrier.title) {
              title = barrier.title;
            } else {
              title = "Cannot Pass";
            }
            this.gurk.pushView(new AlertView(this.gurk, barrier.icon, title, barrier.text, null));
            return false;
          }
          if (this.getTerrain(tx, ty).passable || this.getTerrain(tx, ty).shipPassable && (this.game.aboard || this.game.getFeature(tx, ty, "ship"))) {
            this.clearBanner();
            if (realMove && this.game.aboard && this.game.getFeature(tx, ty, "ship")) {
              // Move onto the next ship
              this.game.disembark();
              if (this.map.music) {
                this.gurk.playMusic(this.map.music);
              }
            }
            this.posX = tx;
            this.posY = ty;
            if (this.game.aboard && !this.getTerrain(tx, ty).shipPassable) {
              this.game.disembark();
              if (this.map.music) {
                this.gurk.playMusic(this.map.music);
              }
            }
            if (realMove) {
              this.gurk.game.moveTo(this.posX, this.posY);
              this.game.moveNum++;
              if (this.game.moveNum % 20 === 0) {
                this.game.regenerateParty();
              }
            }
            if (this.map.dark) {
              this.computeShadows();
            }
            this.trackVisited();
            haveFeature = false;
            if (!this.game.aboard && this.game.getFeature(tx, ty, "ship")) {
              ship = this.game.getFeature(tx, ty, "ship");
              if (this.game.isChartered(ship.id) || !ship.charter || ship.charter === 0) {
                this.clearButton(5);
                this.game.boardShip(this.game.getFeature(tx, ty, "ship").id);
                if (this.map.boatMusic) {
                  this.gurk.playMusic(this.map.boatMusic);
                } else {
                  this.gurk.playMusic(Data.boatMusic);
                }
              } else {
                this.setButton(5, "CHARTER");
                haveFeature = true;
              }
            }
            if (this.game.getFeatures(this.posX, this.posY)) {
              feature = this.getTopFeature(this.posX, this.posY);
              if (feature) {
                if (feature.type !== "ship") { // already handled
                  haveFeature = true;
                  switch (feature.type) {
                    case "encounter":
                      this.encounter = this.gurk.game.getEncounter(feature);
                      if (this.encounter.creatures.length === 0) {
                        this.game.setMarkers(feature.id);
                        this.game.setMarkers(feature.sets);
                        gold = (ref = this.encounter.gold) != null ? ref : 0;
                        text = feature.text;
                        if (gold > 0) {
                          this.game.gold += gold;
                          text = text + `\n\nYou find ${gold} gold pieces!`;
                        }
                        if (this.encounter.items.length === 0) {
                          this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Treasure", text, null, feature.altIcon));
                        } else {
                          this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Treasure", text, "treasure", feature.altIcon));
                        }
                      } else {
                        this.gurk.playCombatMusic();
                        this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Encounter", feature.text, "combat"));
                      }
                      return null;
                    case "alert":
                      if (realMove) {
                        this.gurk.game.setMarkers(feature.sets);
                        this.gurk.pushView(new AlertView(this.gurk, feature.icon, feature.title, feature.text, "alert", feature.altIcon));
                        return null;
                      }
                      break;
                    case "goal":
                      this.gurk.game.setMarkers(feature.sets);
                      this.gurk.pushView(new AlertView(this.gurk, feature.icon, feature.title, feature.text, "goal", feature.altIcon));
                      return null;
                    case "ship":
                      break;
                    default:
                      // Already handled, no-op
                      this.addButtonForFeature(feature, realMove);
                  }
                }
              }
            }
            if (!haveFeature) {
              this.clearButton(5);
              // Make sure it's a "real" move
              if (realMove) {
                if (this.game.checkForRandomEncounter()) {
                  this.encounter = this.game.createEncounter();
                  if (this.encounter.creatures.length > 0) {
                    if (this.encounter.ambushed) {
                      text = "Your adventurers have been ambushed!";
                    } else {
                      text = "Your adventurers have been attacked!";
                    }
                    this.gurk.playCombatMusic();
                    this.gurk.pushView(new AlertView(this.gurk, Data.icons.combat, "Encounter", text, "combat"));
                    return null;
                  }
                }
              }
            }
            return this.draw();
          }
        }
      }

      setMap(gurk, mapName, x, y) {
        boundMethodCheck(this, MapView);
        super.setMap(gurk, mapName, x, y);
        if (this.map.music) {
          return this.gurk.playMusic(this.map.music);
        }
      }

      addButtonForFeature(feature, realMove) {
        var command, name, ref;
        boundMethodCheck(this, MapView);
        this.clearButton(5);
        switch (feature.type) {
          case "sign":
            if (feature.text) {
              command = (ref = feature.action) != null ? ref : "LOOK";
              return this.setButton(5, command);
            }
            break;
          case "transition":
            if (realMove) {
              name = Data.maps[feature.target].name;
              this.setBanner(name);
            }
            return this.setButton(5, "GO");
          case "shop":
            this.setBanner(feature.name);
            return this.setButton(5, "SHOP");
          case "temple":
            return this.setButton(5, "HEAL");
          case "dispatch":
            return this.setButton(5, feature.action);
        }
      }

      processFeature(command) {
        var feature, ref;
        boundMethodCheck(this, MapView);
        feature = this.getTopFeature(this.posX, this.posY);
        switch (feature.type) {
          case "sign":
            this.gurk.game.setMarkers(feature.sets);
            return this.gurk.pushView(new AlertView(this.gurk, feature.icon, (ref = feature.title) != null ? ref : "Sign", feature.text, "sign", feature.altIcon));
          case "transition":
            return this.gurk.pushView(new ConfirmView(this.gurk, feature.icon, "Go", feature.text, "transition", null));
          case "shop":
            return this.gurk.pushView(new ItemView(this.gurk, null, ItemView.ACTION_BUY, feature));
          case "temple":
            if (feature.cost > this.game.gold) {
              return this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Cannot Pay", `The priests of the temple demand a tribute of ${feature.cost} gold pieces, but you cannot pay it!`, null));
            } else {
              return this.gurk.pushView(new ConfirmView(this.gurk, feature.icon, "Tribute", `To heal the adventurers, the priests require a tribute of ${feature.cost} gold pieces, will you pay it?`, "heal", null));
            }
            break;
          case "ship":
            if (feature.charter > this.game.gold) {
              return this.gurk.pushView(new AlertView(this.gurk, feature.icon, "Cannot Pay", `The crew demand ${feature.charter} gold pieces to charter this vessel, but you cannot pay it!`, null));
            } else {
              return this.gurk.pushView(new ConfirmView(this.gurk, feature.icon, "Charter Ship", `Will you pay the crew ${feature.charter} gold pieces to charter this ship?`, "charter", null));
            }
            break;
          case "dispatch":
            return this.gurk.pushView(new ConfirmView(this.gurk, feature.icon, feature.title, feature.text, "dispatch", null, feature.altIcon));
        }
      }

      processResult(result) {
        var action, combatView, feature, gold, icon, image, l, len, nextAction, ref, ship, start, temple, text, treasure, upgrade;
        boundMethodCheck(this, MapView);
        switch (result) {
          case "goal":
            this.move(0, 0);
            return this.draw();
          case "alert":
          case "sign":
            this.move(0, 0);
            return this.draw();
          case "transition":
            feature = this.getTopFeature(this.posX, this.posY);
            this.game.transitionTo(feature.target, feature.targetX, feature.targetY);
            this.setMap(feature.target, feature.targetX, feature.targetY);
            // Process it as a move
            this.move(0, 0);
            if (this.mapMode) {
              this.toggleMap();
            }
            return this.draw();
          case "victory":
            if (this.game.aboard) {
              if (this.map.boatMusic) {
                this.gurk.playMusic(this.map.boatMusic);
              } else {
                this.gurk.playMusic(Data.boatMusic);
              }
            } else if (this.map.music) {
              this.gurk.playMusic(this.map.music);
            }
            feature = this.game.getFeature(this.posX, this.posY, "encounter");
            if (feature) {
              this.gurk.game.setMarkers(feature.id);
              this.gurk.game.setMarkers(feature.sets);
            }
            this.move(0, 0); // Compute shadows, set visited, etc.
            treasure = this.encounter.items;
            gold = this.encounter.gold;
            this.game.gold += gold;
            action = null;
            if (treasure.length > 0) {
              action = "treasure";
              icon = Data.icons.treasure;
              if (gold > 0) {
                text = `You find ${gold} gold pieces and treasure amongst your defeated foes!`;
              } else {
                text = "You find treasure amongst your defeated your foes!";
              }
            } else {
              if (gold > 0) {
                icon = Data.icons.gold;
                text = `You find ${gold} gold pieces amongst your defeated foes!`;
              } else {
                icon = Data.icons.party;
                text = "You have defeated your foes!";
              }
            }
            this.upgrades = this.game.giveExperience(this.encounter.creatures);
            if (this.upgrades.length > 0) {
              text += "\n";
              ref = this.upgrades;
              for (l = 0, len = ref.length; l < len; l++) {
                upgrade = ref[l];
                text += `\n${upgrade.player.character.name} gained a level!`;
              }
              action = "levelup";
            }
            return this.gurk.pushView(new AlertView(this.gurk, icon, "Victory", text, action));
          case "levelup":
            if (this.encounter.items.length > 0) {
              nextAction = "treasure";
            } else {
              nextAction = null;
            }
            return this.gurk.pushView(new LevelUpView(this.gurk, this.upgrades, nextAction));
          case "treasure":
            treasure = this.encounter.items;
            return this.gurk.pushView(new ItemView(this.gurk, null, "GIVE", treasure));
          case "combat":
            combatView = new CombatView(this.gurk, this.gurk.game.getCombatMap(), this.gurk.imageProcessor, this.encounter.creatures, this.encounter.ambushed);
            return this.gurk.pushView(combatView);
          case "heal":
            temple = this.getTopFeature(this.posX, this.posY);
            this.game.gold -= temple.cost;
            return this.game.healParty();
          case "charter":
            ship = this.getTopFeature(this.posX, this.posY);
            this.game.gold -= ship.charter;
            this.game.boardShip(ship.id);
            if (this.map.boatMusic) {
              this.gurk.playMusic(this.map.boatMusic);
            } else {
              this.gurk.playMusic(Data.boatMusic);
            }
            return this.clearButton(5);
          case "dispatch":
            feature = this.getTopFeature(this.posX, this.posY);
            return this.gurk.game.setMarkers(feature.sets);
          case "defeat":
            this.game.death();
            start = this.game.getStart();
            this.map = start.map;
            this.x = start.x;
            this.y = start.y;
            this.game.transitionTo(start.map, start.x, start.y);
            this.setMap(start.map, start.x, start.y);
            this.move(0, 0);
            return this.gurk.pushView(new AlertView(this.gurk, Data.icons.death, "Defeat", "You have been defeated! As blackness closes in, a strange feeling comes over the adventurers...", null));
          case "debug1":
            this.game.players[0].takeDamage(3);
            image = this.gurk.imageProcessor.rotate(Data.icons.death, ImageProcessor.LEFT);
            return this.fly(Data.icons.death, 1, 7, 7, 1, 75, this.animDone, image);
        }
      }

    };

    MapView.MAP_ICONS = {
      "shop": [['#764F00', '#FFFF48', '#764F00'], ['#764F00', '#000000', '#764F00'], ['#764F00', '#000000', '#764F00']],
      "ship": [[null, '#FFFFFF', null], ['#FFFFFF', '#FFFFFF', null], ['#AF7300', '#AF7300', '#AF7300']],
      "temple": [['#FFFFFF', '#FF0000', '#FFFFFF'], ['#FF0000', '#FF0000', '#FF0000'], ['#FFFFFF', '#FF0000', '#FFFFFF']]
    };

    MapView.TRANSITION_ICONS = {
      "outdoor": [['#3CF000', '#3CF000', '#3CF000'], ['#32C800', '#32C800', '#32C800'], [null, '#AF7300', null]],
      "dungeon": [[null, '#FFFFFF', null], ['#FFFFFF', '#FFFFFF', '#FFFFFF'], ['#FFFFFF', '#000000', '#FFFFFF']],
      "up": [[null, null, '#FFFFFF'], [null, '#FFFFFF', '#FFFFFF'], ['#FFFFFF', '#FFFFFF', '#FFFFFF']],
      "down": [['#FFFFFF', null, null], ['#FFFFFF', '#FFFFFF', null], ['#FFFFFF', '#FFFFFF', '#FFFFFF']],
      "town": [['#FFFFFF', null, '#FFFFFF'], ['#FFFFFF', '#FFFFFF', '#FFFFFF'], ['#FFFFFF', '#AF7300', '#FFFFFF']]
    };

    MapView.FEATURE_TYPES = ["block", "barrier", "encounter", "goal", "alert", "dispatch", "transition", "shop", "temple", "ship", "sign", "override"];

    MapView.prototype.game = null;

    MapView.prototype.shadows = null;

    MapView.prototype.test = null;

    MapView.prototype.mapMode = false;

    MapView.prototype.encounter = null;

    MapView.prototype.upgrades = null;

    MapView.prototype.shadowOverlay = null;

    return MapView;

  }).call(this);

  // -----------------------------------------------------------------------------
  LevelUpView = class LevelUpView extends InfoView {
    constructor(gurk, upgrades, nextAction1) {
      var attrBonus, i, l, len, o, player, text, textX, upgrade, y;
      super(gurk, "OK");
      this.command = this.command.bind(this);
      this.nextAction = nextAction1;
      y = AlertView.ICON_Y;
      textX = AlertView.ICON_X * 2 + Screen.UNIT;
      this.addLabelCentered("Levelling Up", "#FFF", 0, y, 128, y + 8);
      y += 12;
      for (l = 0, len = upgrades.length; l < len; l++) {
        upgrade = upgrades[l];
        player = upgrade.player;
        this.addIcon(player.character.icon, AlertView.ICON_X, y);
        this.addLabel(`${player.character.name}`, "#FFF", textX, y);
        y += 8;
        text = `HP +${upgrade.hitPointBonus}`;
        if (upgrade.spellPointBonus > 0) {
          text += `, SP +${upgrade.spellPointBonus}`;
        }
        if (upgrade.newSpells) {
          text += " +spells";
        }
        // @addLabel("New spells!", "#A0A0A0", textX, y)
        this.addLabel(text, "#A0A0A0", textX, y);
        y += 8;
        text = "";
        for (i = o = 0; o < 4; i = ++o) {
          attrBonus = upgrade.attrBonuses[i];
          if (attrBonus > 0) {
            this.addLabel(`${Player.ATTRIBUTES[i]} +${attrBonus}`, "#A0A0A0", textX, y);
            y += 8;
          }
        }
        y += 4;
      }
    }

    command(text) {
      boundMethodCheck(this, LevelUpView);
      return this.gurk.popView(this.nextAction);
    }

  };

  PartyView = (function() {
    // -----------------------------------------------------------------------------
    class PartyView extends SelectView {
      constructor(gurk) {
        super(gurk, "VIEW", "EXIT");
        this.doLayout = this.doLayout.bind(this);
        this.itemSelected = this.itemSelected.bind(this);
        this.command = this.command.bind(this);
        this.game = this.gurk.game;
        this.setButton(1, "OPTIONS");
      }

      doLayout() {
        var color, key, l, len, map, marker, player, ref, ref1, stats, y;
        boundMethodCheck(this, PartyView);
        this.clear();
        ref = Data.keys;
        for (marker in ref) {
          key = ref[marker];
          if (this.gurk.game.hasMarker(marker) && !this.gurk.game.hasMarker(key.until)) {
            this.addIcon(key.icon, 110, 10);
          }
        }
        y = 2;
        this.addLabelCentered("The Adventurers", "#FFF", 0, y, 128, Screen.FONT.fontHeight);
        y += 10;
        map = Data.maps[this.game.map];
        this.addLabel(`In: ${map.name}`, "#FFF", 3, y);
        y += 8;
        this.addLabel(`Gold: ${this.game.gold}`, "#E8C627", 3, y);
        y += 10;
        ref1 = this.game.players;
        for (l = 0, len = ref1.length; l < len; l++) {
          player = ref1[l];
          this.addIcon(player.character.icon, 2, y);
          color = player.isAlive() ? "#FFF" : "#999";
          this.addOption(player.character.name, color, 20, y);
          y += 8;
          this.addLabel(`Level ${player.level} ${player.character.job}`, "#FFF", 20, y);
          stats = `HP: ${player.hitPoints}/${player.maxHitPoints}`;
          if (player.maxSpellPoints > 0) {
            stats = stats + ` SP: ${player.spellPoints}/${player.maxSpellPoints}`;
          }
          y += 8;
          this.addLabel(stats, "#FFF", 20, y);
          y += 10;
        }
        if (this.game.bag) {
          this.addIcon(this.game.bag.character.icon, 2, y);
          this.addOption(this.game.bag.character.name, "#BBB", 20, y);
          y += 8;
          if (this.game.bag.items.length === 0) {
            return this.addLabel("Empty", "#FFF", 20, y);
          } else if (this.game.bag.items.length === 1) {
            return this.addLabel("1 item", "#FFF", 20, y);
          } else {
            return this.addLabel(`${this.game.bag.items.length} items`, "#FFF", 20, y);
          }
        }
      }

      itemSelected(index, item) {
        boundMethodCheck(this, PartyView);
        if (index === 3) {
          return this.gurk.pushView(new ItemView(this.gurk, this.gurk.game.bag, ItemView.ACTION_INFO));
        } else {
          return this.gurk.pushView(new PlayerView(this.gurk, this.game.players[index]));
        }
      }

      command(text) {
        boundMethodCheck(this, PartyView);
        if (text === "OPTIONS") {
          return this.gurk.showSettings();
        } else {
          return super.command(text);
        }
      }

    };

    PartyView.prototype.game = null;

    return PartyView;

  }).call(this);

  PlayerDialog = (function() {
    // -----------------------------------------------------------------------------
    class PlayerDialog extends SelectView {
      constructor(gurk, action1, preselect = null) {
        var active, bag, color, index, l, len, message, player, ref, selectIndex, showBag, superAction, y;
        superAction = function() {
          return this.action;
        };
        super(gurk, superAction, "CANCEL");
        this.itemHighlighted = this.itemHighlighted.bind(this);
        this.itemSelected = this.itemSelected.bind(this);
        this.action = action1;
        this.preselect = preselect;
        this.game = this.gurk.game;
        this.canSelect = [];
        y = 3;
        showBag = false;
        switch (this.action) {
          case PlayerDialog.ACTION_HEAL:
            message = "Heal which Adventurer?";
            break;
          case PlayerDialog.ACTION_RESTORE:
            message = "Restore which Adventurer?";
            break;
          case PlayerDialog.ACTION_GIVE:
            message = "Give to which Adventurer?";
            showBag = true;
            break;
          case PlayerDialog.ACTION_SELL:
            message = "Which Adenturer will Sell?";
            showBag = true;
            break;
          default:
            message = "Choose an Adventurer";
        }
        this.addLabelCentered(message, "#FFF", 0, y, 128, Screen.FONT.fontHeight);
        y += 12;
        index = 0;
        selectIndex = -1;
        ref = this.game.players;
        for (l = 0, len = ref.length; l < len; l++) {
          player = ref[l];
          this.addIcon(player.character.icon, 2, y);
          active = true;
          if (this.action === PlayerDialog.ACTION_HEAL) {
            if (!player.isAlive() || player.isHealed()) {
              active = false;
            }
          } else if (this.action === PlayerDialog.ACTION_RESTORE) {
            if (!player.isAlive() || player.isRestored()) {
              active = false;
            }
          } else if (this.action === PlayerDialog.ACTION_GIVE) {
            if (!player.canCarryMoreItems()) {
              active = false;
            }
          } else if (this.action === PlayerDialog.ACTION_SELL) {
            if (player.numberOfItems() === 0) {
              active = false;
            }
          }
          this.canSelect.push(active);
          if (active && this.preselect && this.preselect === player) {
            selectIndex = index;
          }
          color = active ? "#FFF" : "#999";
          this.addOption(player.character.name, color, 20, y);
          y += 8;
          switch (this.action) {
            case PlayerDialog.ACTION_HEAL:
              this.addLabel(`Hit Points: ${player.hitPoints}/${player.maxHitPoints}`, "#999", 20, y);
              break;
            case PlayerDialog.ACTION_RESTORE:
              this.addLabel(`Spell Points: ${player.spellPoints}/${player.maxSpellPoints}`, "#999", 20, y);
              break;
            case PlayerDialog.ACTION_GIVE:
              this.addLabel(`Can carry ${Player.MAX_ITEMS - player.numberOfItems()} more items.`, "#999", 20, y);
              break;
            case PlayerDialog.ACTION_SELL:
              this.addLabel(`Carrying ${player.numberOfItems()} items.`, "#999", 20, y);
          }
          y += 20;
          index++;
        }
        if (showBag) {
          bag = this.gurk.game.bag;
          if (bag) {
            this.addIcon(bag.character.icon, 2, y);
            active = true;
            switch (this.action) {
              case PlayerDialog.ACTION_GIVE:
                if (!bag.canCarryMoreItems()) {
                  active = false;
                }
                break;
              case PlayerDialog.ACTION_SELL:
                if (bag.numberOfItems() === 0) {
                  active = false;
                }
            }
            this.canSelect.push(active);
            color = active ? "#FFF" : "#999";
            this.addOption(bag.character.name, color, 20, y);
            y += 8;
            switch (this.action) {
              case PlayerDialog.ACTION_GIVE:
                this.addLabel(`Room for ${Player.MAX_ITEMS - bag.numberOfItems()} more items.`, "#999", 20, y);
                break;
              case PlayerDialog.ACTION_SELL:
                this.addLabel(`Carrying ${bag.numberOfItems()} items.`, "#999", 20, y);
            }
          }
        }
        if (selectIndex >= 0) {
          this.selected = selectIndex;
        }
        this.start();
      }

      itemHighlighted(index, item) {
        boundMethodCheck(this, PlayerDialog);
        if (this.canSelect[index]) {
          return this.setSelectVerb(this.action);
        } else {
          return this.turnOffSelection();
        }
      }

      itemSelected(index, item) {
        boundMethodCheck(this, PlayerDialog);
        return this.gurk.popView(index);
      }

    };

    PlayerDialog.ACTION_HEAL = "HEAL";

    PlayerDialog.ACTION_RESTORE = "RESTORE";

    PlayerDialog.ACTION_GIVE = "GIVE";

    PlayerDialog.ACTION_SELL = "SELL";

    PlayerDialog.prototype.game = null;

    PlayerDialog.prototype.canSelect = null;

    return PlayerDialog;

  }).call(this);

  // -----------------------------------------------------------------------------
  PlayerView = class PlayerView extends InfoView {
    constructor(gurk, player1) {
      super(gurk, "X");
      this.doLayout = this.doLayout.bind(this);
      this.command = this.command.bind(this);
      this.player = player1;
      this.setButton(7, "BACK");
      this.setButton(9, "EXIT");
      this.setButton(5, "GEAR");
      this.setButton(1, "ITEMS");
    }

    doLayout() {
      var accuracyBonus, awarenessBonus, constitutionBonus, hasSpells, hasUse, levelUp, strengthBonus, y;
      boundMethodCheck(this, PlayerView);
      hasSpells = this.player.hasSpells();
      hasUse = this.player.hasUsableItem(false);
      if (this.player.isAlive()) {
        if (hasSpells && hasUse) {
          this.setButton(3, "CAST/USE");
        } else if (hasSpells) {
          this.setButton(3, "SPELLS");
        } else if (hasUse) {
          this.setButton(3, "USE");
        }
      }
      // Warning-- the below is repeated in CreateView verbatim, find way to merge?
      this.clear();
      this.addIcon(this.player.character.icon, 3, 3);
      y = 4;
      this.addLabel(this.player.character.name, "#FFF", 20, y);
      y += 8;
      this.addLabel(`Level ${this.player.level} ${this.player.character.job}`, "#FFF", 20, y);
      y += 8;
      levelUp = Data.levels[this.player.level];
      this.addLabel(`XP: ${this.player.experience}/${levelUp}`, "#FFF", 20, y);
      y += 8;
      // todo - add spell points if there are any, use HP, SP
      if (this.player.maxSpellPoints > 0) {
        this.addLabel(`HP: ${this.player.hitPoints}/${this.player.maxHitPoints}, SP: ${this.player.spellPoints}/${this.player.maxSpellPoints}`, "#FFF", 20, y);
      } else {
        this.addLabel(`Hit Points: ${this.player.hitPoints}/${this.player.maxHitPoints}`, "#FFF", 20, y);
      }
      y += 8;
      this.addLabel(`Armor Class: ${this.player.getArmorClass()}`, "#FFF", 20, y);
      y += 8;
      this.addLabel(`Resistance: ${this.player.getResistance()}`, "#FFF", 20, y);
      y += 12;
      this.addLabel(`Strength: ${this.player.getStrength()}`, "#FFF", 20, y);
      y += 8;
      strengthBonus = this.player.getAttributeBonus(this.player.getStrength());
      if (strengthBonus !== 0) {
        this.addLabel(`Damage Bonus: ${strengthBonus}`, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel(`Accuracy: ${this.player.getAccuracy()}`, "#FFF", 20, y);
      y += 8;
      accuracyBonus = this.player.getAttributeBonus(this.player.getAccuracy());
      if (accuracyBonus !== 0) {
        this.addLabel(`To-Hit Bonus: ${accuracyBonus}`, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel(`Awareness: ${this.player.getAwareness()}`, "#FFF", 20, y);
      y += 8;
      awarenessBonus = this.player.getAttributeBonus(this.player.getAwareness());
      if (awarenessBonus !== 0) {
        this.addLabel(`Armor Class Bonus: ${awarenessBonus}`, "#A0A0A0", 28, y);
      }
      y += 10;
      this.addLabel(`Toughness: ${this.player.getConstitution()}`, "#FFF", 20, y);
      y += 8;
      constitutionBonus = this.player.getAttributeBonus(this.player.getConstitution());
      if (constitutionBonus !== 0) {
        return this.addLabel(`Resistance Bonus: ${constitutionBonus}`, "#A0A0A0", 28, y);
      }
    }

    command(text) {
      boundMethodCheck(this, PlayerView);
      switch (text) {
        case "ITEMS":
          return this.gurk.pushView(new ItemView(this.gurk, this.player, ItemView.ACTION_INFO));
        case "GEAR":
          return this.gurk.pushView(new GearView(this.gurk, this.player));
        case "SPELLS":
        case "CAST/USE":
          return this.gurk.pushView(new SpellView(this.gurk, this.player));
        case "USE":
          return this.gurk.pushView(new ItemView(this.gurk, this.player, ItemView.ACTION_USE, false));
        case "BACK":
          return this.gurk.popView(null);
        case "EXIT":
          return this.gurk.popToTopView(null);
      }
    }

  };

  GearView = (function() {
    // -----------------------------------------------------------------------------
    class GearView extends SelectView {
      constructor(gurk, player1) {
        super(gurk, "EQUIP", "X");
        this.doLayout = this.doLayout.bind(this);
        this.itemSelected = this.itemSelected.bind(this);
        this.itemHighlighted = this.itemHighlighted.bind(this);
        this.command = this.command.bind(this);
        this.processResult = this.processResult.bind(this);
        this.player = player1;
        this.setButton(7, "BACK");
        this.setButton(9, "EXIT");
      }

      doLayout() {
        var color, icon, index, item, k, label, ref, y;
        boundMethodCheck(this, GearView);
        this.clear();
        this.addIcon(this.player.character.icon, 2, 2);
        this.addLabelCentered(`${this.player.character.name}'s Gear`, "#FFF", 0, 4, 128, 16);
        y = 2 + 16 + 2;
        index = 0;
        ref = this.player.equipment;
        for (k in ref) {
          item = ref[k];
          color = "#FFF";
          if (item) {
            icon = item.template.icon;
            label = item.name;
            color = item.getColor();
          } else {
            icon = GearView.slotIcons[index];
            label = "(none)";
          }
          this.addIcon(icon, 2, y);
          this.addOption(label, color, 21, y + 4);
          index++;
          y += 18;
        }
        return this.start();
      }

      itemSelected(index, item) {
        boundMethodCheck(this, GearView);
        return this.gurk.pushView(new ItemView(this.gurk, this.player, ItemView.ACTION_EQUIP, index));
      }

      itemHighlighted(index, item) {
        var type;
        boundMethodCheck(this, GearView);
        type = Item.TYPES[index];
        if (this.player.getEquipableItemsByType(type).length > 0) {
          this.setButton(5, "EQUIP");
        } else {
          this.clearButton(5);
        }
        if (this.player.getEquippedItemByType(type)) {
          return this.setButton(1, "INFO");
        } else {
          return this.clearButton(1);
        }
      }

      command(text) {
        boundMethodCheck(this, GearView);
        switch (text) {
          case "BACK":
            return this.gurk.popView(null);
          case "EXIT":
            return this.gurk.popToTopView(null);
          case "INFO":
            return this.gurk.pushView(new ItemInfoView(this.gurk, this.player.getEquippedItemByType(Item.TYPES[this.selected])));
          default:
            return super.command(text);
        }
      }

      processResult(item) {
        boundMethodCheck(this, GearView);
        if (item) {
          if (item === ItemView.NONE) {
            return this.player.unequipItemByType(Item.TYPES[this.selected]);
          } else {
            this.player.equipItem(item);
            this.changeIcon(this.selected + 1, item.template.icon);
            return this.changeOption(this.selected, item.name, "#FFF");
          }
        }
      }

    };

    GearView.slotIcons = [Data.icons.noWeapon, Data.icons.noShield, Data.icons.noHat, Data.icons.noArmor, Data.icons.noBoots, Data.icons.noAmulet];

    return GearView;

  }).call(this);

  // -----------------------------------------------------------------------------
  QuestView = class QuestView extends SelectView {
    constructor(gurk) {
      super(gurk, "VIEW", "EXIT");
      this.doLayout = this.doLayout.bind(this);
      this.itemSelected = this.itemSelected.bind(this);
      this.command = this.command.bind(this);
    }

    doLayout() {
      var haveQuests, info, quest, ref, y;
      boundMethodCheck(this, QuestView);
      this.clear();
      this.addLabelCentered("Quests", "#A0A0A0", 0, 1, 128, 8);
      haveQuests = false;
      y = 9;
      ref = Data.quests;
      for (quest in ref) {
        info = ref[quest];
        if (this.gurk.game.hasMarker(info.started)) {
          haveQuests = true;
          if (this.gurk.game.hasMarker(info.done)) {
            this.addLabel("+", "#FFF", 1, y);
          }
          this.addOption(quest, "#FFF", 6, y);
          y += 8;
        }
      }
      if (!haveQuests) {
        return this.addLabel("(No quests yet)", "#FFF", 6, y);
      }
    }

    itemSelected(index, label) {
      var done, infoView, questInfo;
      boundMethodCheck(this, QuestView);
      questInfo = Data.quests[label.text];
      done = this.gurk.game.hasMarker(questInfo.done);
      infoView = new AlertView(this.gurk, questInfo.icon, label.text, questInfo.text, null);
      if (done) {
        infoView.subtitle = "(Completed)";
      }
      return this.gurk.pushView(infoView);
    }

    command(text) {
      boundMethodCheck(this, QuestView);
      switch (text) {
        case "EXIT":
          return this.gurk.popToTopView(null);
        default:
          return super.command(text);
      }
    }

  };

  ItemView = (function() {
    // -----------------------------------------------------------------------------
    class ItemView extends SelectView {
      constructor(gurk, player1, itemAction, param1 = null, melee1 = null, summon1 = null, combatant1 = null) {
        var superAction;
        superAction = function() {
          return this.itemAction;
        };
        super(gurk, superAction, "X");
        this.doLayout = this.doLayout.bind(this);
        this.itemHighlighted = this.itemHighlighted.bind(this);
        this.itemSelected = this.itemSelected.bind(this);
        this.command = this.command.bind(this);
        this.processResult = this.processResult.bind(this);
        this.player = player1;
        this.itemAction = itemAction;
        this.param = param1;
        this.melee = melee1;
        this.summon = summon1;
        this.combatant = combatant1;
        if (this.itemAction === ItemView.ACTION_GIVE) {
          this.items = this.param;
        } else if (this.itemAction === ItemView.ACTION_BUY) {
          this.shop = this.param;
          this.items = gurk.game.getShopItems(this.shop.x, this.shop.y);
          this.buyRate = this.shop.buyRate;
          this.sellRate = this.shop.sellRate;
        } else if (this.itemAction === ItemView.ACTION_SELL) {
          this.shop = this.param;
          this.buyRate = this.shop.buyRate;
          this.sellRate = this.shop.sellRate;
          this.items = this.player.items;
        } else if (this.itemAction === ItemView.ACTION_USE) {
          this.inCombat = this.param;
        }
      }

      doLayout() {
        var canUse, color, item, l, len, len1, name, o, offset, option, optionWidth, ref, ref1, spell, y;
        boundMethodCheck(this, ItemView);
        this.clear();
        switch (this.itemAction) {
          case ItemView.ACTION_EQUIP:
            this.addLabelCentered(`${this.player.getName()}'s Items`, "#A0A0A0", 0, 1, 128, 8);
            this.setButton(1, "INFO");
            this.setButton(7, "BACK");
            if (this.melee) { // True if this is an in-combat wield
              this.clearButton(9);
            } else {
              this.setButton(9, "EXIT");
            }
            this.items = this.player.getEquipableItemsByType(Item.TYPES[this.param]);
            this.items.push(ItemView.NONE);
            break;
          case ItemView.ACTION_INFO:
            this.addLabelCentered(`${this.player.getName()}'s Items`, "#A0A0A0", 0, 1, 128, 8);
            this.setButton(9, "EXIT");
            this.setButton(7, "BACK");
            this.setButton(3, "GIVE");
            this.setButton(1, "DROP");
            // todo - add "USE" option here that is enabled for healing items
            this.items = this.player.items;
            break;
          case ItemView.ACTION_GIVE:
            this.addLabelCentered("Items", "#A0A0A0", 0, 1, 128, 8);
            this.setButton(1, "INFO");
            this.setButton(9, "EXIT");
            break;
          case ItemView.ACTION_BUY:
            this.addLabelCentered(`Gold: ${this.gurk.game.gold}`, "#E8C627", 0, 1, 128, 8);
            this.setButton(1, "INFO");
            this.setButton(3, "SELL...");
            this.setButton(9, "EXIT");
            break;
          case ItemView.ACTION_SELL:
            this.addLabelCentered(`${this.player.getName()}'s Items`, "#A0A0A0", 0, 1, 128, 8);
            this.setButton(1, "INFO");
            this.setButton(7, "BACK");
            this.setButton(9, "EXIT");
            break;
          case ItemView.ACTION_USE:
            this.addLabelCentered("Choose Item to Use", "#A0A0A0", 0, 1, 128, 8);
            this.setButton(1, "INFO");
            this.setButton(7, "BACK");
            if (!this.inCombat) {
              this.setButton(9, "EXIT");
            } else {
              this.clearButton(9);
            }
            this.items = [];
            ref = this.player.items;
            for (l = 0, len = ref.length; l < len; l++) {
              item = ref[l];
              if (this.player.canEmploy(item) && (item.isUseable() || (this.combatant && this.inCombat && item.getCombatSpell() && this.player.isItemEquipped(item) && !this.combatant.isCombatSpellUsed(item)))) {
                canUse = false;
                if (this.inCombat) {
                  spell = item.getSpell();
                  if (spell.type === "summon" && this.summon) {
                    canUse = true;
                  } else if (spell.target !== "touch" || this.melee || spell.type === "heal") {
                    canUse = true;
                  }
                } else if (item.canUseOutsideOfCombat()) {
                  canUse = true;
                }
                if (canUse) {
                  this.items.push(item);
                }
              }
            }
            if (this.items.length === 0) {
              this.gurk.popView(null);
            }
        }
        this.addIcon(Data.icons.blank, 128 - 17, 1);
        y = 9;
        if (this.items.length > 0) {
          ref1 = this.items;
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            item = ref1[o];
            if (item === ItemView.NONE) {
              this.addOption(ItemView.NONE, "#A0A0A0", 6, y);
            } else {
              color = item.getColor();
              if (this.player && this.player.isItemEquipped(item) && !this.inCombat) {
                this.addLabel("+", "#FFF", 1, y);
              }
              name = item.name;
              spell = null;
              if (item.charges > 0) {
                name = name + ` [${item.charges}]`;
                spell = item.getSpell();
              } else if (item.getCombatSpell() && this.inCombat) {
                name = name + " [+]";
                spell = item.getCombatSpell();
              }
              if (spell && this.inCombat) {
                if (spell.fast) {
                  this.addLabel("|", "#A0A0A0", 1, y);
                } else {
                  this.addLabel("=", "#A0A0A0", 1, y);
                }
              }
              if (this.itemAction === ItemView.ACTION_BUY) {
                option = `${name} (${item.getShopValue(this.buyRate)})`;
                this.addOption(option, "#FFF", 1, y);
                offset = 1;
              } else if (this.itemAction === ItemView.ACTION_SELL) {
                option = `${name} (${item.getShopValue(this.sellRate)})`;
                this.addOption(option, "#FFF", 6, y);
                offset = 6;
              } else {
                option = name;
                this.addOption(name, "#FFF", 6, y);
                offset = 6;
              }
              if (item.template.legendary) {
                optionWidth = this.getTextWidth(option);
                this.addLabel("=", color, offset + optionWidth + 1, y);
              }
            }
            y += 8;
          }
        } else {
          this.addLabel("(No items)", "#FFF", 6, y);
          this.clearButton(1);
          this.clearButton(3);
          this.clearButton(5);
        }
        return this.start();
      }

      itemHighlighted(index, item) {
        boundMethodCheck(this, ItemView);
        if (item.text === ItemView.NONE) {
          return this.changeIcon(0, GearView.slotIcons[this.param]);
        } else {
          this.changeIcon(0, this.items[index].template.icon);
          if (this.itemAction === ItemView.ACTION_BUY) {
            if (this.gurk.game.gold >= this.items[index].getShopValue(this.buyRate)) {
              return this.setButton(5, "BUY");
            } else {
              return this.clearButton(5);
            }
          }
        }
      }

      itemSelected(index, label) {
        var item, price;
        boundMethodCheck(this, ItemView);
        if (label === ItemView.NONE) {
          return this.gurk.popView(label);
        } else {
          item = this.items[index];
          if (this.itemAction === ItemView.ACTION_EQUIP) {
            this.gurk.popView(item);
          }
          if (this.itemAction === ItemView.ACTION_SELL) {
            price = item.getShopValue(this.sellRate);
            this.gurk.pushView(new ConfirmView(this.gurk, item.template.icon, "Confirm Sale", `Sell ${item.name} for ${price} gold pieces?`, "SELL_YES", "SELL_NO"));
          }
          if (this.itemAction === ItemView.ACTION_USE) {
            if (this.inCombat) {
              return this.gurk.popView(item);
            } else {
              if (item.getSpell().healType === "restore") {
                return this.gurk.pushView(new PlayerDialog(this.gurk, PlayerDialog.ACTION_RESTORE, this.player));
              } else {
                return this.gurk.pushView(new PlayerDialog(this.gurk, PlayerDialog.ACTION_HEAL, this.player));
              }
            }
          }
        }
      }

      command(text) {
        var item;
        boundMethodCheck(this, ItemView);
        this.selectAction = text;
        switch (text) {
          case "BACK":
            return this.gurk.popView(null);
          case "EXIT":
            return this.gurk.popToTopView(null);
          case "INFO":
            return this.gurk.pushView(new ItemInfoView(this.gurk, this.items[this.selected]));
          case "GIVE":
          case "BUY":
            return this.gurk.pushView(new PlayerDialog(this.gurk, "GIVE"));
          case "SELL...":
            return this.gurk.pushView(new PlayerDialog(this.gurk, "SELL"));
          case "DROP":
            item = this.items[this.selected];
            return this.gurk.pushView(new ConfirmView(this.gurk, item.template.icon, "Confirm Drop", `Drop ${item.name}? It will be gone forever!`, "DROP_YES", "DROP_NO"));
          default:
            return super.command(text);
        }
      }

      processResult(param) {
        var bounds, healAmount, item, orgHitPoints, orgSpellPoints, restoreAmount, spell, target;
        boundMethodCheck(this, ItemView);
        item = this.items[this.selected];
        if (param === "SELL_YES") {
          this.gurk.game.gold += item.getShopValue(this.sellRate);
          this.player.dropItem(item);
          return this.doLayout();
        } else if (param === "DROP_YES") {
          this.player.dropItem(item);
          return this.doLayout();
        } else if (param === "DROP_NO") {
          // no-op
          return false;
        } else if (param === "SELL_NO") {
          // no-op
          return false;
        } else if (this.selectAction === "SELL...") {
          this.selectAction = "SELL";
          if (param === 3) {
            this.sellingPlayer = this.gurk.game.bag;
          } else {
            this.sellingPlayer = this.gurk.game.players[param];
          }
          return this.gurk.pushView(new ItemView(this.gurk, this.sellingPlayer, "SELL", this.shop));
        } else if (this.selectAction === "USE") {
          target = this.gurk.game.players[param];
          spell = item.getSpell();
          bounds = item.getSpellRange();
          item.charges--;
          if (item.charges === 0) {
            this.player.dropItem(item);
          }
          if (spell.healType === "restore") {
            orgSpellPoints = target.spellPoints;
            target.spellPoints += Util.random(bounds.min, bounds.max);
            if (target.spellPoints > target.maxSpellPoints) {
              target.spellPoints = target.maxSpellPoints;
            }
            restoreAmount = target.spellPoints - orgSpellPoints;
            return this.gurk.pushView(new AlertView(this.gurk, target.character.icon, "Restored", `${target.character.name} was restored for ${restoreAmount} points.`, null));
          } else {
            orgHitPoints = target.hitPoints;
            target.hitPoints += Util.random(bounds.min, bounds.max);
            if (target.hitPoints > target.maxHitPoints) {
              target.hitPoints = target.maxHitPoints;
            }
            healAmount = target.hitPoints - orgHitPoints;
            return this.gurk.pushView(new AlertView(this.gurk, target.character.icon, "Healed", `${target.character.name} was healed for ${healAmount} points.`, null)); // GIVE
          }
        } else {
          if (param === 3) {
            target = this.gurk.game.bag;
          } else {
            target = this.gurk.game.players[param];
          }
          if (target) {
            if (this.player !== target) {
              item = this.items[this.selected];
              if (this.player) {
                this.player.dropItem(item);
              } else {
                this.items.splice(this.selected, 1);
                if (this.itemAction === ItemView.ACTION_BUY) {
                  this.gurk.game.gold -= item.getShopValue(this.buyRate);
                }
              }
              target.addItem(item);
              if (this.items.length === 0) {
                return this.gurk.popView(null);
              }
            }
          }
        }
      }

    };

    ItemView.ACTION_EQUIP = "EQUIP";

    ItemView.ACTION_INFO = "INFO";

    ItemView.ACTION_BUY = "BUY";

    ItemView.ACTION_SELL = "SELL";

    ItemView.ACTION_GIVE = "GIVE";

    ItemView.ACTION_USE = "USE";

    ItemView.ACTION_DROP = "DROP";

    ItemView.NONE = "(none)";

    ItemView.itemType = null;

    ItemView.items = null;

    ItemView.shop = null;

    ItemView.buyRate = 0;

    ItemView.sellRate = 0;

    ItemView.selectAction = null;

    ItemView.sellingPlayer = null;

    ItemView.inCombat = false;

    return ItemView;

  }).call(this);

  // -----------------------------------------------------------------------------
  ItemInfoView = class ItemInfoView extends InfoView {
    static getUsedBy(template) {
      var first, l, len, ref, text, type;
      first = true;
      text = "";
      ref = template.usedBy;
      for (l = 0, len = ref.length; l < len; l++) {
        type = ref[l];
        if (first) {
          first = false;
        } else {
          text += ", ";
        }
        switch (type) {
          case "warrior":
            text += "Warriors";
            break;
          case "archer":
            text += "Archers";
            break;
          case "mage":
            text += "Mages";
        }
      }
      return text;
    }

    constructor(gurk, item1) {
      var speed, spell, template, x, y;
      super(gurk, "DONE");
      this.showSpell = this.showSpell.bind(this);
      this.item = item1;
      template = this.item.template;
      this.addIcon(template.icon, 3, 3);
      y = 23;
      x = 3;
      if (template.legendary) {
        this.addLabelCentered(this.item.name, this.item.getColor(), 0, 3, 128, 8);
        this.addLabelCentered("(Legendary Artifact)", "#A0A0A0", 0, 12, 128, 8);
      } else {
        this.addLabelCentered(this.item.name, this.item.getColor(), 0, 4, 128, 16);
      }
      this.addLabel(`(${ItemInfoView.getUsedBy(template)})`, "#FFF", x, y);
      y += 8;
      // todo - show charges, and spell effect for usable items
      if (this.item.isMeleeWeapon()) {
        this.addLabel(`Melee Damage: ${Math.max(1, this.item.getMeleeMinDamage())} - ${Math.max(1, this.item.getMeleeMaxDamage())}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.isRangeWeapon()) {
        this.addLabel(`Range Damage: ${Math.max(1, this.item.getRangeMinDamage())} - ${Math.max(1, this.item.getRangeMaxDamage())}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.getHitSpell()) {
        this.addLabel("Hit Effect", "#A0A0A0", x, y);
        y += 8;
        y = this.showSpell(this.item.getHitSpell(), 8, y, false, false);
      }
      if (this.item.getCombatSpell()) {
        speed = this.item.getCombatSpell().fast ? "|" : "=";
        this.addLabel(`Once per Combat ${speed}`, "#A0A0A0", x, y);
        y += 8;
        y = this.showSpell(this.item.getCombatSpell(), 8, y, true, true);
      }
      if (this.item.getExtraMoves() > 0) {
        this.addLabel(`Extra Moves: ${this.item.getExtraMoves()}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.getExtraAttacks() > 0) {
        this.addLabel(`Extra Attacks: ${this.item.getExtraAttacks()}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.getToHitBonus() !== 0) {
        this.addLabel(`To-Hit Bonus: ${this.item.getToHitBonus()}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.getArmorClass() !== 0) {
        this.addLabel(`Armor Class Bonus: ${this.item.getArmorClass()}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.getResistance() !== 0) {
        this.addLabel(`Resistance Bonus: ${this.item.getResistance()}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.getStrengthBonus() !== 0) {
        this.addLabel(`Strength Bonus: ${this.item.getStrengthBonus()}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.getAccuracyBonus() !== 0) {
        this.addLabel(`Accuracy Bonus: ${this.item.getAccuracyBonus()}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.getAwarenessBonus() !== 0) {
        this.addLabel(`Awareness Bonus: ${this.item.getAwarenessBonus()}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.getConstitutionBonus() !== 0) {
        this.addLabel(`Toughness Bonus: ${this.item.getConstitutionBonus()}`, "#FFF", x, y);
        y += 8;
      }
      if (this.item.isUseable()) {
        this.addLabel(`Charges Left: ${this.item.charges}`, "#FFF", x, y);
        y += 8;
        spell = this.item.getSpell();
        speed = spell.fast ? "| Fast" : "= Normal";
        this.addLabel(`Speed: ${speed}`, "#FFF", x, y);
        y += 8;
        this.showSpell(spell, x, y, true, true);
      }
    }

    showSpell(spell, x, y, showRange = true, showDrainDamage = false) {
      var effect, range, target;
      boundMethodCheck(this, ItemInfoView);
      if (spell.type === "summon") {
        this.addLabel(`Summons: ${spell.creature}`, "#FFF", x, y);
        y += 8;
      } else {
        range = this.item.getSpellRange(spell);
        if (spell.type === "damage") {
          effect = `Damage ${range.min} - ${range.max}`;
        } else if (spell.type === "teleport") {
          effect = "Teleport";
        } else if (spell.type === "drain") {
          if (showDrainDamage) {
            effect = `Drains Life ${range.min} - ${range.max}`;
          } else {
            effect = "Drains Life";
          }
        } else if (spell.type === "heal") {
          if (spell.healType === "restore") {
            effect = `Restore ${range.min} - ${range.max}`;
          } else if (spell.healType === "remove") {
            effect = "Cure Afflictions";
          } else {
            effect = `Heal ${range.min} - ${range.max}`;
          }
        } else {
          effect = spell.effect;
          if ("Poisoned" === effect) {
            effect += " (" + spell.value + ")";
          }
        }
        if (showRange) {
          // speed = if spell.fast then "|" else "="
          this.addLabel(`Effect: ${effect}`, "#FFF", x, y);
        } else {
          this.addLabel(`${effect}`, "#FFF", x, y);
        }
        y += 8;
        if (showRange) {
          if (spell.target === "touch") {
            target = "Touch";
          } else if (spell.target === "self") {
            target = "Self";
          } else if (spell.target === "range") {
            target = "Range";
          } else if (spell.target === "area") {
            target = "Area";
          }
          this.addLabel(`Target: ${target}`, "#FFF", x, y);
          y += 8;
        }
      }
      return y;
    }

  };

  SpellView = (function() {
    // -----------------------------------------------------------------------------
    class SpellView extends SelectView {
      constructor(gurk, player1, inCombat1 = false, melee1 = false, hasSummonRoom = false, combatant1 = null) {
        super(gurk, "CAST", "X");
        this.doLayout = this.doLayout.bind(this);
        this.itemHighlighted = this.itemHighlighted.bind(this);
        this.itemSelected = this.itemSelected.bind(this);
        this.command = this.command.bind(this);
        this.processResult = this.processResult.bind(this);
        this.player = player1;
        this.inCombat = inCombat1;
        this.melee = melee1;
        this.hasSummonRoom = hasSummonRoom;
        this.combatant = combatant1;
        if (this.player.template) {
          this.creature = this.player;
        }
        if (!this.inCombat) {
          this.setButton(9, "EXIT");
          this.setButton(7, "BACK");
        } else {
          this.setButton(7, "CANCEL");
          this.clearButton(9);
        }
        this.setButton(1, "INFO");
      }

      doLayout() {
        var active, color, index, l, len, ref, spell, spellPoints, y;
        boundMethodCheck(this, SpellView);
        this.clear();
        this.spells = this.player.getSpells();
        this.castable = [];
        // @addIcon(Data.icons.spell, 128 - 17, 1)
        if (this.creature) {
          this.addLabelCentered(`${this.creature.template.name}'s Spells (SP: ${this.player.spellPoints})`, "#A0A0A0", 0, 1, 128, 8);
        } else {
          this.addLabelCentered(`${this.player.character.name}'s Spells (SP: ${this.player.spellPoints})`, "#A0A0A0", 0, 1, 128, 8);
        }
        y = 9;
        spellPoints = this.player.spellPoints;
        index = 0;
        ref = this.spells;
        for (l = 0, len = ref.length; l < len; l++) {
          spell = ref[l];
          active = false;
          if (spell.spellPoints <= spellPoints) {
            if ((spell.type === "heal" && (this.inCombat || spell.healType !== "remove")) || ((spell.type === "enhance" || spell.type === "teleport") && this.inCombat)) {
              active = true;
            } else if (this.inCombat) {
              if (spell.type === "summon" && this.hasSummonRoom) {
                active = true;
              } else if (spell.target === "touch" && this.melee) {
                active = true;
              } else if (spell.target === "range" || spell.target === "area") {
                active = true;
              }
            }
          }
          this.castable.push(active);
          color = active ? "#FFF" : "#888";
          if (active && this.inCombat) {
            if (spell.fast) {
              this.addLabel("|", "#A0A0A0", 1, y);
            } else {
              this.addLabel("=", "#A0A0A0", 1, y);
            }
          }
          this.addOption(`${spell.name} (${spell.spellPoints})`, color, 6, y);
          y += 8;
          index++;
        }
        if (!this.creature && this.player.hasUsableItem(this.inCombat, this.melee, this.hasSummonRoom, this.combatant)) {
          this.addOption(SpellView.USE_NAME, "#FFF", 6, y);
        }
        return this.start();
      }

      itemHighlighted(index, item) {
        boundMethodCheck(this, SpellView);
        if (item.text === SpellView.USE_NAME) {
          return this.setButton(5, "USE");
        } else if (this.castable[index]) {
          return this.setButton(5, "CAST");
        } else {
          return this.clearButton(5);
        }
      }

      itemSelected(index, item) {
        boundMethodCheck(this, SpellView);
        if (this.castable[index]) {
          if (this.inCombat) {
            return this.gurk.popView(this.spells[index]);
          } else {
            if (this.gurk.game.playersNeedHealing()) {
              return this.gurk.pushView(new PlayerDialog(this.gurk, PlayerDialog.ACTION_HEAL));
            } else {
              return this.gurk.pushView(new AlertView(this.gurk, Data.icons.party, "Fully Healed", "There is nobody to target with that spell, all of the adventures are fully healed!", null));
            }
          }
        }
      }

      command(text) {
        boundMethodCheck(this, SpellView);
        this.resultMode = "NORMAL";
        switch (text) {
          case "BACK":
          case "CANCEL":
            return this.gurk.popView(null);
          case "EXIT":
            return this.gurk.popToTopView(null);
          case "INFO":
            return this.gurk.pushView(new SpellInfoView(this.gurk, this.player, this.spells[this.selected]));
          case "USE":
            this.resultMode = "USE";
            return this.gurk.pushView(new ItemView(this.gurk, this.player, ItemView.ACTION_USE, this.inCombat, this.melee, this.hasSummonRoom, this.combatant));
          default:
            return super.command(text);
        }
      }

      processResult(result) {
        var bounds, healAmount, orgHitPoints, orgSpellPoints, restoreAmount, spell, target;
        boundMethodCheck(this, SpellView);
        if (this.resultMode === "USE") {
          return this.gurk.popView(result);
        } else {
          target = this.gurk.game.players[result];
          spell = this.spells[this.selected];
          this.player.spellPoints -= spell.spellPoints;
          bounds = this.player.getSpellRange(spell);
          if (spell.healType === "restore") {
            orgSpellPoints = target.spellPoints;
            target.spellPoints += Util.random(bounds.min, bounds.max);
            if (target.spellPoints > target.maxSpellPoints) {
              target.spellPoints = target.maxSpellPoints;
            }
            restoreAmount = target.spellPoints - orgSpellPoints;
            return this.gurk.pushView(new AlertView(this.gurk, target.character.icon, "Restored", `${target.character.name} was restored for ${restoreAmount} points, now at ${target.spellPoints}/${target.maxSpellPoints}.`, null));
          } else {
            orgHitPoints = target.hitPoints;
            target.hitPoints += Util.random(bounds.min, bounds.max);
            if (target.hitPoints > target.maxHitPoints) {
              target.hitPoints = target.maxHitPoints;
            }
            healAmount = target.hitPoints - orgHitPoints;
            return this.gurk.pushView(new AlertView(this.gurk, target.character.icon, "Healed", `${target.character.name} was healed for ${healAmount} points, now at ${target.hitPoints}/${target.maxHitPoints}.`, null));
          }
        }
      }

    };

    SpellView.USE_NAME = "Use...";

    SpellView.prototype.creature = null;

    SpellView.prototype.spells = null;

    SpellView.prototype.castable = null;

    SpellView.prototype.resultMode = null;

    return SpellView;

  }).call(this);

  // -----------------------------------------------------------------------------
  SpellInfoView = class SpellInfoView extends InfoView {
    constructor(gurk, player1, spell1) {
      var effect, range, speed, target, x, y;
      super(gurk, "DONE");
      this.player = player1;
      this.spell = spell1;
      range = this.player.getSpellRange(this.spell);
      this.addIcon(Data.icons.spell, 3, 3);
      this.addLabelCentered(this.spell.name, "#FFF", 0, 4, 128, 16);
      y = 23;
      x = 3;
      this.addLabel(`Level: ${this.spell.level}`, "#FFF", x, y);
      y += 8;
      this.addLabel(`Casting Cost: ${this.spell.spellPoints} SP`, "#FFF", x, y);
      y += 8;
      speed = this.spell.fast ? "| Fast" : "= Normal";
      this.addLabel(`Speed: ${speed}`, "#FFF", x, y);
      y += 8;
      if (this.spell.type === "summon") {
        this.addLabel(`Summons: ${this.spell.creature}`, "#FFF", x, y);
        y += 8;
      } else {
        if (this.spell.type === "damage") {
          effect = `Damage ${range.min} - ${range.max}`;
        } else if (this.spell.type === "drain") {
          effect = `Drains Life ${range.min} - ${range.max}`;
        } else if (this.spell.type === "heal") {
          if (this.spell.healType === "restore") {
            effect = "Restore";
          } else if (this.spell.healType === "remove") {
            effect = "Remove Afflictions";
          } else {
            effect = `Heal ${range.min} - ${range.max}`;
          }
        } else if (this.spell.type === "teleport") {
          effect = "Teleport";
        } else {
          if (this.spell.effect === "Poisoned") {
            effect = `Poisoned (${this.spell.value})`;
          } else {
            effect = this.spell.effect;
          }
        }
        this.addLabel(`Effect: ${effect}`, "#FFF", x, y);
        y += 8;
        if (this.spell.target === "touch") {
          target = "Touch";
        } else if (this.spell.target === "self") {
          target = "Self";
        } else if (this.spell.target === "range") {
          target = "Range";
        } else if (this.spell.target === "area") {
          target = "Area";
        }
        this.addLabel(`Target: ${target}`, "#FFF", x, y);
        y += 8;
      }
    }

  };

  Combatant = (function() {
    class Combatant {
      constructor(entity, isPlayer1, good1, x3 = -1, y3 = -1) {
        this.startTurn = this.startTurn.bind(this);
        this.notDone = this.notDone.bind(this);
        this.useCombatSpell = this.useCombatSpell.bind(this);
        this.isCombatSpellUsed = this.isCombatSpellUsed.bind(this);
        this.doDamage = this.doDamage.bind(this);
        this.doHeal = this.doHeal.bind(this);
        this.getName = this.getName.bind(this);
        this.getBanner = this.getBanner.bind(this);
        this.getIcon = this.getIcon.bind(this);
        this.getMaxHitPoints = this.getMaxHitPoints.bind(this);
        this.getResistance = this.getResistance.bind(this);
        this.getPotency = this.getPotency.bind(this);
        this.isFullyHealed = this.isFullyHealed.bind(this);
        this.canAttackRange = this.canAttackRange.bind(this);
        this.canAttackArea = this.canAttackArea.bind(this);
        this.getToHitBonus = this.getToHitBonus.bind(this);
        this.getArmorClass = this.getArmorClass.bind(this);
        this.getMeleeDamageBounds = this.getMeleeDamageBounds.bind(this);
        this.getRangeDamageBounds = this.getRangeDamageBounds.bind(this);
        this.getHitSpell = this.getHitSpell.bind(this);
        this.isParalyzed = this.isParalyzed.bind(this);
        this.isRooted = this.isRooted.bind(this);
        this.isPoisoned = this.isPoisoned.bind(this);
        this.computeDamageBounds = this.computeDamageBounds.bind(this);
        this.getRangeAnimation = this.getRangeAnimation.bind(this);
        this.canSummon = this.canSummon.bind(this);
        this.addEffect = this.addEffect.bind(this);
        this.removeEffect = this.removeEffect.bind(this);
        this.hasEffect = this.hasEffect.bind(this);
        this.getEffect = this.getEffect.bind(this);
        this.clearAllAfflictions = this.clearAllAfflictions.bind(this);
        this.incrementEffects = this.incrementEffects.bind(this);
        this.drawIcon = this.drawIcon.bind(this);
        this.entity = entity;
        this.isPlayer = isPlayer1;
        this.good = good1;
        this.x = x3;
        this.y = y3;
        this.hitPoints = this.entity.hitPoints;
        this.effects = {};
        this.usedCombatSpells = {};
      }

      startTurn() {
        var ref, ref1;
        if (this.isPlayer) {
          // todo - testing
          this.numMoves = 1 + this.entity.getExtraMoves();
          this.numAttacks = 1 + this.entity.getExtraAttacks();
        } else {
          this.numMoves = (ref = this.entity.template.numMoves) != null ? ref : 1;
          this.numAttacks = (ref1 = this.entity.template.numAttacks) != null ? ref1 : 1;
        }
        if (this.hasEffect("Berserk")) {
          this.numAttacks++;
        }
        if (this.hasEffect("Quick")) {
          this.numMoves += this.getEffect("Quick").value;
        }
        this.movesLeft = this.numMoves;
        this.attacksLeft = this.numAttacks;
        this.halfAttack = false;
        this.didAttack = false;
        this.drainAmount = 0;
        return this.usingItem = null;
      }

      notDone() {
        return this.movesLeft > 0 || this.attacksLeft > 0;
      }

      useCombatSpell(item) {
        return this.usedCombatSpells[item.id] = true;
      }

      isCombatSpellUsed(item) {
        var ref;
        return (ref = this.usedCombatSpells[item.id]) != null ? ref : false;
      }

      doDamage(damage) {
        if (this.hasEffect("Blessed")) {
          damage = Math.round(damage / this.getEffect("Blessed").value);
          if (damage < 1) {
            damage = 1;
          }
        }
        this.hitPoints = Math.max(0, this.hitPoints - damage);
        if (this.isPlayer) {
          this.entity.hitPoints = this.hitPoints;
        }
        if (this.hitPoints === 0) {
          return true;
        } else {
          return false;
        }
      }

      doHeal(amount, healType, imageProcessor, callback) {
        if (healType === "remove") {
          return this.clearAllAfflictions(imageProcessor, callback);
        } else if (healType === "restore") {
          return this.entity.spellPoints = Math.min(this.entity.maxSpellPoints, this.entity.spellPoints + amount);
        } else {
          this.hitPoints = Math.min(this.getMaxHitPoints(), this.hitPoints + amount);
          if (this.isPlayer) {
            return this.entity.hitPoints = this.hitPoints;
          }
        }
      }

      getName() {
        return this.entity.getName();
      }

      getBanner() {
        var k, name, ref, v;
        name = this.getName();
        ref = this.effects;
        for (k in ref) {
          v = ref[k];
          if (v) {
            name = `[${k}]`;
          }
        }
        return name;
      }

      getIcon() {
        if (this.isPlayer) {
          return this.entity.character.icon;
        } else {
          return this.entity.template.icon;
        }
      }

      getMaxHitPoints() {
        return this.entity.maxHitPoints;
      }

      getResistance() {
        var r;
        r = this.entity.getResistance();
        if (this.hasEffect("Resistant")) {
          r += this.getEffect("Resistant").value;
        }
        return r;
      }

      getPotency() {
        return this.entity.getPotency();
      }

      isFullyHealed() {
        return this.hitPoints === this.getMaxHitPoints();
      }

      canAttackRange() {
        return this.entity.canAttackRange();
      }

      canAttackArea() {
        return this.entity.canAttackArea();
      }

      getToHitBonus() {
        var toHit;
        toHit = this.entity.getToHitBonus();
        if (this.hasEffect("Eagle-eyed")) {
          toHit += this.getEffect("Eagle-eyed").value;
        }
        if (this.hasEffect("Blinded")) {
          toHit -= this.getEffect("Blinded").value;
        }
        return toHit;
      }

      getArmorClass() {
        var ac;
        ac = this.entity.getArmorClass();
        if (this.hasEffect("Protected")) {
          ac += this.getEffect("Protected").value;
        }
        if (this.hasEffect("Sluggish")) {
          ac -= this.getEffect("Sluggish").value;
        }
        return ac;
      }

      getMeleeDamageBounds() {
        var bounds;
        bounds = this.entity.getMeleeDamageBounds();
        return this.computeDamageBounds(bounds);
      }

      getRangeDamageBounds() {
        var bounds;
        bounds = this.entity.getRangeDamageBounds();
        return this.computeDamageBounds(bounds);
      }

      getHitSpell() {
        return this.entity.getHitSpell();
      }

      isParalyzed() {
        return this.hasEffect("Paralyzed");
      }

      isRooted() {
        return this.hasEffect("Rooted");
      }

      isPoisoned() {
        return this.hasEffect("Poisoned");
      }

      computeDamageBounds(bounds) {
        var value;
        if (this.hasEffect("Strong")) {
          value = this.getEffect("Strong").value;
          bounds.min = Math.round(bounds.min * value);
          bounds.max = Math.round(bounds.max * value);
        }
        if (this.hasEffect("Weakened")) {
          value = this.getEffect("Weakened").value;
          bounds.min = Math.round(bounds.min / value);
          bounds.max = Math.round(bounds.max / value);
          if (bounds.min < 1) {
            bounds.min = 1;
          }
          if (bounds.max < 1) {
            bounds.max = 1;
          }
        }
        return bounds;
      }

      getRangeAnimation() {
        if (this.isPlayer) {
          return this.entity.getWeapon().template.rangeAnimation;
        } else {
          return this.entity.template.rangeAnimation;
        }
      }

      canSummon() {
        if (this.isPlayer) {
          return false;
        } else {
          if (this.entity.template.summons) {
            return true;
          } else {
            return false;
          }
        }
      }

      addEffect(effect, value, duration, caster) {
        var already;
        already = this.hasEffect(effect);
        this.effects[effect] = {
          "value": value,
          "duration": duration
        };
        if (caster === this && !already) {
          if (effect === "Berserk") {
            return this.attacksLeft += value;
          } else if (effect === "Quick") {
            return this.movesLeft += value;
          }
        }
      }

      removeEffect(effect) {
        // todo - delete instead of nullify?
        return this.effects[effect] = null;
      }

      hasEffect(effect) {
        return !!this.effects[effect];
      }

      getEffect(effect) {
        return this.effects[effect];
      }

      clearAllAfflictions(imageProcessor, callback) {
        var effect, ref, value;
        ref = this.effects;
        for (effect in ref) {
          value = ref[effect];
          if (Combatant.EFFECT_COLORS[effect].type === "shade") {
            this.removeEffect(effect);
          }
        }
        return this.drawIcon(imageProcessor, callback);
      }

      incrementEffects(imageProcessor, callback) {
        var effect, info, l, len, ref, removeList;
        removeList = [];
        ref = this.effects;
        for (effect in ref) {
          info = ref[effect];
          if (effect === "Berserk") {
            if (!this.didAttack) {
              removeList.push(effect);
            }
          } else if (info) {
            info.duration--;
            if (info.duration <= 0) {
              removeList.push(effect);
            }
          }
        }
        if (removeList.length > 0) {
          for (l = 0, len = removeList.length; l < len; l++) {
            effect = removeList[l];
            this.removeEffect(effect);
          }
          return this.drawIcon(imageProcessor, callback);
        }
      }

      drawIcon(imageProcessor, callback) {
        var effect, haloColors, info, ref, shadeColors, value;
        if (!doCustomDraws()) {
          this.customImage = null;
          callback();
          return;
        }
        shadeColors = [];
        haloColors = [];
        ref = this.effects;
        for (effect in ref) {
          value = ref[effect];
          if (value) {
            info = Combatant.EFFECT_COLORS[effect];
            if (info.type === "shade") {
              shadeColors.push(info.color);
            } else {
              haloColors.push(info.color);
            }
          }
        }
        if (shadeColors.length === 0 && haloColors.length === 0) {
          this.customImage = null;
          return callback();
        } else {
          this.customImage = imageProcessor.process(this.getIcon(), shadeColors, haloColors);
          return this.customImage.onload = callback;
        }
      }

    };

    Combatant.EFFECT_COLORS = {
      "Berserk": {
        type: "glow",
        color: Util.rgb(108, 255, 108)
      },
      "Strong": {
        type: "glow",
        color: Util.rgb(255, 108, 108)
      },
      "Protected": {
        type: "glow",
        color: Util.rgb(108, 108, 255)
      },
      "Blessed": {
        type: "glow",
        color: Util.rgb(255, 255, 255)
      },
      "Quick": {
        type: "glow",
        color: Util.rgb(255, 192, 64)
      },
      "Eagle-eyed": {
        type: "glow",
        color: Util.rgb(255, 108, 255)
      },
      "Resistant": {
        type: "glow",
        color: Util.rgb(108, 255, 255)
      },
      "Paralyzed": {
        type: "shade",
        color: Util.rgb(-64, -64, 96)
      },
      "Rooted": {
        type: "shade",
        color: Util.rgb(32, 32, -96)
      },
      "Poisoned": {
        type: "shade",
        color: Util.rgb(-64, 96, -64)
      },
      "Weakened": {
        type: "shade",
        color: Util.rgb(72, 72, -64)
      },
      "Blinded": {
        type: "shade",
        color: Util.rgb(-64, -64, -64)
      },
      "Sluggish": {
        type: "shade",
        color: Util.rgb(-64, 72, 72)
      }
    };

    Combatant.prototype.hitPoints = 0;

    Combatant.prototype.lastTarget = null;

    Combatant.prototype.customImage = null;

    Combatant.prototype.numMoves = 1;

    Combatant.prototype.numAttacks = 1;

    Combatant.prototype.movesLeft = 0;

    Combatant.prototype.attacksLeft = 0;

    Combatant.prototype.effects = null;

    Combatant.prototype.usedCombatSpells = null;

    Combatant.prototype.halfAttack = false;

    Combatant.prototype.didAttack = false;

    Combatant.prototype.invisible = false;

    return Combatant;

  }).call(this);

  // -----------------------------------------------------------------------------
  CombatantView = class CombatantView extends FlowView {
    constructor(gurk, combatant1) {
      var effect, effectsList, ref, superIcon, superName, text, value;
      superIcon = function() {
        return this.combatant.getIcon();
      };
      superName = function() {
        return this.combatant.getName();
      };
      super(gurk, superIcon, superName);
      this.command = this.command.bind(this);
      this.combatant = combatant1;
      //           @gurk.pushView(new AlertView(@gurk, combatant.getIcon(), combatant.getName(), combatant.entity.template.description, null))
      this.addParagraph(`Hit Points: ${this.combatant.hitPoints}/${this.combatant.getMaxHitPoints()}`, "#FFF");
      if (this.combatant.isPlayer) {
        if (this.combatant.entity.maxSpellPoints > 0) {
          this.addParagraph(`Spell Points: ${this.combatant.entity.spellPoints}/${this.combatant.entity.maxSpellPoints}`, "#FFF");
        }
      }
      this.addGap();
      effectsList = [];
      ref = this.combatant.effects;
      for (effect in ref) {
        value = ref[effect];
        if (value) {
          effectsList.push(effect);
        }
      }
      if (effectsList.length > 0) {
        text = Util.arrayToString(effectsList);
        this.addParagraph("Effects: " + text, "#FFF");
        this.setButton(1, "EFFECTS");
      }
      if (!this.combatant.isPlayer) {
        this.addParagraph(this.combatant.entity.template.description, "#A0A0A0");
      }
    }

    command(text) {
      var effect, flow, ref, value;
      boundMethodCheck(this, CombatantView);
      switch (text) {
        case "EFFECTS":
          flow = new FlowView(this.gurk, this.combatant.getIcon(), "Combat Effects", null);
          ref = this.combatant.effects;
          for (effect in ref) {
            value = ref[effect];
            if (value) {
              flow.addParagraph(effect, "#FFF");
              flow.addParagraph(Data.effects[effect], "#A0A0A0");
              flow.addGap();
            }
          }
          return this.gurk.pushView(flow);
        default:
          return super.command(text);
      }
    }

  };

  CombatView = (function() {
    // -----------------------------------------------------------------------------
    class CombatView extends TileView {
      constructor(gurk, mapName, imageProcessor1, creatures, ambushed) {
        super(gurk);
        this.processIcon = this.processIcon.bind(this);
        this.command = this.command.bind(this);
        // @gurk.pushView(new AlertView(@gurk, combatant.getIcon(), combatant.getName(), combatant.entity.template.description, null))
        this.log = this.log.bind(this);
        // console.log(text)
        this.nextAction = this.nextAction.bind(this);
        this.addAction = this.addAction.bind(this);
        this.addAnimation = this.addAnimation.bind(this);
        this.addPause = this.addPause.bind(this);
        this.addSound = this.addSound.bind(this);
        this.doPause = this.doPause.bind(this);
        this.getCustomAnimation = this.getCustomAnimation.bind(this);
        this.queueFly = this.queueFly.bind(this);
        this.queueAnimation = this.queueAnimation.bind(this);
        this.queueBlockAnimation = this.queueBlockAnimation.bind(this);
        this.drawCombatant = this.drawCombatant.bind(this);
        this.doDraw = this.doDraw.bind(this);
        this.isSelected = this.isSelected.bind(this);
        this.drawSelection = this.drawSelection.bind(this);
        this.clearActions = this.clearActions.bind(this);
        this.checkForLoss = this.checkForLoss.bind(this);
        this.checkForWin = this.checkForWin.bind(this);
        this.startTurn = this.startTurn.bind(this);
        // Player is presented with turn options
        this.startPlayerTurn = this.startPlayerTurn.bind(this);
        this.move = this.move.bind(this);
        this.updateBanner = this.updateBanner.bind(this);
        this.passTurn = this.passTurn.bind(this);
        // Turn Ends
        this.endTurn = this.endTurn.bind(this);
        // Player chooses attack target
        this.startPlayerAttack = this.startPlayerAttack.bind(this);
        this.getSuggestedEnemyTarget = this.getSuggestedEnemyTarget.bind(this);
        this.startPlayerCast = this.startPlayerCast.bind(this);
        this.startPlayerUse = this.startPlayerUse.bind(this);
        this.startPlayerWield = this.startPlayerWield.bind(this);
        this.doPlayerCast = this.doPlayerCast.bind(this);
        this.computeSpellTiming = this.computeSpellTiming.bind(this);
        this.doSpellCast = this.doSpellCast.bind(this);
        this.doSpellResult = this.doSpellResult.bind(this);
        // Player's attack is executed
        this.doPlayerAttack = this.doPlayerAttack.bind(this);
        this.runAttack = this.runAttack.bind(this);
        this.processAttack = this.processAttack.bind(this);
        this.doAreaEffect = this.doAreaEffect.bind(this);
        this.doAreaHealing = this.doAreaHealing.bind(this);
        this.doAreaAttack = this.doAreaAttack.bind(this);
        this.doAreaDamage = this.doAreaDamage.bind(this);
        this.showAreaHealing = this.showAreaHealing.bind(this);
        this.showResist = this.showResist.bind(this);
        this.showAreaDamage = this.showAreaDamage.bind(this);
        this.doResist = this.doResist.bind(this);
        this.doDamage = this.doDamage.bind(this);
        this.addCreatures = this.addCreatures.bind(this);
        this.addPlayers = this.addPlayers.bind(this);
        this.addCombatant = this.addCombatant.bind(this);
        this.summonCreature = this.summonCreature.bind(this);
        this.clearSelection = this.clearSelection.bind(this);
        this.select = this.select.bind(this);
        this.getCombatant = this.getCombatant.bind(this);
        this.moveCombatant = this.moveCombatant.bind(this);
        this.getSurroundingSquares = this.getSurroundingSquares.bind(this);
        this.areEnemies = this.areEnemies.bind(this);
        this.doSavingThrow = this.doSavingThrow.bind(this);
        this.resistDamage = this.resistDamage.bind(this);
        this.canAttackMelee = this.canAttackMelee.bind(this);
        this.canTouchAlly = this.canTouchAlly.bind(this);
        this.canTargetWithSpell = this.canTargetWithSpell.bind(this);
        this.getSpellTargets = this.getSpellTargets.bind(this);
        this.hasAllies = this.hasAllies.bind(this);
        this.getRandomSquare = this.getRandomSquare.bind(this);
        this.getSuggestedSummonSquare = this.getSuggestedSummonSquare.bind(this);
        this.canSummon = this.canSummon.bind(this);
        this.isInMeleeRange = this.isInMeleeRange.bind(this);
        this.isInMeleeRangeXY = this.isInMeleeRangeXY.bind(this);
        this.canAttack = this.canAttack.bind(this);
        this.getRangeACBonus = this.getRangeACBonus.bind(this);
        this.getNearestTarget = this.getNearestTarget.bind(this);
        this.getNearestAttackTarget = this.getNearestAttackTarget.bind(this);
        this.getNearestEnemy = this.getNearestEnemy.bind(this);
        this.getRandomEnemy = this.getRandomEnemy.bind(this);
        this.getBestAreaTarget = this.getBestAreaTarget.bind(this);
        this.removeCombatant = this.removeCombatant.bind(this);
        this.isStillAlive = this.isStillAlive.bind(this);
        this.setTarget = this.setTarget.bind(this);
        this.isClear = this.isClear.bind(this);
        this.canCast = this.canCast.bind(this);
        this.canUse = this.canUse.bind(this);
        this.processResult = this.processResult.bind(this);
        this.imageProcessor = imageProcessor1;
        if (this.gurk.getFastSetting()) {
          this.combatSpeed = CombatView.FAST_SPEED;
          this.pauseTime = CombatView.FAST_PAUSE;
        }
        this.strategy = new BasicStrategy(this);
        this.offsetX = -Screen.HALF_UNIT;
        this.combatants = [];
        this.combatMap = {};
        this.queue = [];
        this.stack = [];
        if (ambushed) {
          this.addCreatures(creatures);
          this.addPlayers();
        } else {
          this.addPlayers();
          this.addCreatures(creatures);
        }
        this.setButton(5, "OK");
        this.current = 0;
        //@combatants[0].addEffect("Paralyzed", 1, 2)
        //@combatants[0].addEffect("Berserk", 1, 4)
        //@processIcon(@combatants[0])
        //@combatants[1].addEffect("Poisoned", 1, 3)
        //@processIcon(@combatants[1])
        this.startTurn();
        this.nextAction();
      }

      processIcon(combatant) {
        boundMethodCheck(this, CombatView);
        return combatant.drawIcon(this.imageProcessor, this.draw);
      }

      command(text) {
        var combatant;
        boundMethodCheck(this, CombatView);
        switch (text) {
          case View.LEFT:
            return this.move(-1, 0);
          case View.UP:
            return this.move(0, -1);
          case View.RIGHT:
            return this.move(1, 0);
          case View.DOWN:
            return this.move(0, 1);
          case "OK":
            return this.gurk.popView(null);
          case "ATT/FIRE":
          case "ATTACK":
          case "FIRE":
            this.isFiring = text === "FIRE";
            return this.startPlayerAttack();
          case "TARGET":
          case "HEAL":
          case "RESTORE":
          case "CURE":
          case "SUMMON":
          case "TELEPORT":
            if (this.spellType === CombatView.SPELL_NONE) {
              return this.doPlayerAttack();
            } else {
              return this.doSpellCast();
            }
            break;
          case "CAST":
          case "CAST/USE":
            return this.startPlayerCast();
          case "USE":
            return this.startPlayerUse();
          case "WIELD":
            return this.startPlayerWield();
          case "PASS":
            return this.passTurn();
          case "CANCEL":
            return this.startPlayerTurn();
          case "VIEW":
            this.clearActions();
            this.setButton(5, "INFO");
            this.setButton(7, "DONE");
            this.enableMovement();
            return this.select(this.selectX, this.selectY, CombatView.SELECT_VIEW);
          case "DONE":
            return this.startPlayerTurn();
          case "INFO":
            if (this.selectMode === CombatView.SELECT_TARGET) {
              combatant = this.getCombatant(this.targetX, this.targetY);
            } else {
              combatant = this.getCombatant(this.selectX, this.selectY);
            }
            if (combatant) {
              return this.gurk.pushView(new CombatantView(this.gurk, combatant));
            }
        }
      }

      log(text) {
        boundMethodCheck(this, CombatView);
      }

      nextAction() {
        var action, animation, info, next;
        boundMethodCheck(this, CombatView);
        next = true;
        while ((this.queue.length > 0 || this.stack.length > 0) && next) {
          if (this.queue.length === 0 && this.stack.length > 0) {
            this.queue = this.stack.pop();
          }
          while (this.queue.length > 0 && next) {
            ({action, animation, info} = this.queue.shift());
            this.log("Action: " + info);
            if (action) {
              this.stack.push(this.queue);
              this.queue = [];
              action();
              next = !animation;
            }
          }
        }
        if (this.queue.length === 0 && this.stack.length > 0) {
          this.queue = this.stack.pop();
        }
        return this.queue.length > 0;
      }

      addAction(action, info) {
        boundMethodCheck(this, CombatView);
        return this.queue.push({
          "action": action,
          animation: false,
          "info": info
        });
      }

      addAnimation(action, info) {
        boundMethodCheck(this, CombatView);
        return this.queue.push({
          "action": action,
          animation: true,
          "info": info
        });
      }

      addPause(info) {
        boundMethodCheck(this, CombatView);
        return this.queue.push({
          "action": this.doPause,
          animation: true,
          "info": info
        });
      }

      addSound(sound, info) {
        var action;
        boundMethodCheck(this, CombatView);
        action = () => {
          return this.gurk.playSound(sound);
        };
        return this.queue.push({
          "action": action,
          animation: false,
          "info": info
        });
      }

      doPause() {
        boundMethodCheck(this, CombatView);
        return setTimeout(this.nextAction, this.pauseTime);
      }

      getCustomAnimation(sx, sy, tx, ty, animation) {
        var angle, dx, dy;
        boundMethodCheck(this, CombatView);
        if (Icons[animation].frames) {
          return null;
        } else {
          dx = tx - sx;
          dy = ty - sy;
          if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0) {
              angle = ImageProcessor.RIGHT;
            } else {
              angle = ImageProcessor.LEFT;
            }
          } else {
            if (dy > 0) {
              angle = ImageProcessor.DOWN;
            } else {
              angle = ImageProcessor.UP;
            }
          }
          return this.gurk.imageProcessor.rotate(animation, angle);
        }
      }

      queueFly(sx, sy, tx, ty, animation, info) {
        var action, custom;
        boundMethodCheck(this, CombatView);
        custom = doCustomDraws() ? this.getCustomAnimation(sx, sy, tx, ty, animation) : null;
        action = () => {
          return this.fly(animation, sx + 1, tx + 1, sy, ty, this.combatSpeed / 2, this.nextAction, custom);
        };
        return this.addAnimation(action, info);
      }

      queueAnimation(x, y, animation, info) {
        var action;
        boundMethodCheck(this, CombatView);
        action = () => {
          return this.animate(animation, x + 1, y, this.combatSpeed, this.nextAction);
        };
        return this.addAnimation(action, info);
      }

      queueBlockAnimation(x, y, radius, animation, info) {
        var action;
        boundMethodCheck(this, CombatView);
        action = () => {
          return this.animateBlock(animation, x + 1, y, radius, this.combatSpeed, this.nextAction);
        };
        return this.addAnimation(action, info);
      }

      drawCombatant(combatant) {
        boundMethodCheck(this, CombatView);
        if (combatant.customImage) {
          return this.drawCustom(combatant.customImage, combatant.x + 1, combatant.y);
        } else {
          return this.drawTile(combatant.getIcon(), combatant.x + 1, combatant.y);
        }
      }

      doDraw() {
        var combatant, l, len, o, p, ref, ref1, ref2, tile, x, y;
        boundMethodCheck(this, CombatView);
// Draw map
        for (y = l = 0, ref = this.height; (0 <= ref ? l < ref : l > ref); y = 0 <= ref ? ++l : --l) {
          for (x = o = 0, ref1 = this.width; (0 <= ref1 ? o < ref1 : o > ref1); x = 0 <= ref1 ? ++o : --o) {
            tile = this.getTerrainIcon(x, y);
            this.drawTile(tile, x, y);
          }
        }
        // Draw selection
        this.drawSelection();
        ref2 = this.combatants;
        // Draw combatants
        for (p = 0, len = ref2.length; p < len; p++) {
          combatant = ref2[p];
          if (!combatant.invisible) {
            this.drawCombatant(combatant);
          }
        }
        this.drawBanner();
        return this.drawTopBanner();
      }

      isSelected(x, y) {
        boundMethodCheck(this, CombatView);
        switch (this.selectMode) {
          case CombatView.SELECT_ACTIVE:
          case CombatView.SELECT_VIEW:
            return x === this.selectX && y === this.selectY;
          case CombatView.SELECT_TARGET:
            return x === this.selectX && y === this.selectY || x === this.targetX && y === this.targetY;
        }
        return false;
      }

      drawSelection() {
        var l, maxX, maxY, minX, minY, o, p, ref, ref1, ref2, ref3, ref4, ref5, selectIcon, targetIcon, x, y;
        boundMethodCheck(this, CombatView);
        if (this.selectMode !== CombatView.SELECT_OFF && this.selectMode !== CombatView.SELECT_TARGETED) {
          switch (this.selectMode) {
            case CombatView.SELECT_ACTIVE:
              selectIcon = Data.icons.selectActive;
              break;
            case CombatView.SELECT_TARGET:
              targetIcon = Data.icons.selectTarget;
              if (this.areaSpell || this.areaAttack) {
                minY = Math.max(CombatView.TOP_EDGE, this.targetY - 1);
                maxY = Math.min(CombatView.BOTTOM_EDGE, this.targetY + 1);
                minX = Math.max(CombatView.LEFT_EDGE, this.targetX - 1) + 1;
                maxX = Math.min(CombatView.RIGHT_EDGE, this.targetX + 1) + 1;
// Top and bottom edges
                for (x = l = ref = minX, ref1 = maxX; (ref <= ref1 ? l <= ref1 : l >= ref1); x = ref <= ref1 ? ++l : --l) {
                  this.drawTile(targetIcon.top, x, minY - 1);
                  this.drawTile(targetIcon.bottom, x, maxY + 1);
                }
// Left and right edges, plus center
                for (y = o = ref2 = minY, ref3 = maxY; (ref2 <= ref3 ? o <= ref3 : o >= ref3); y = ref2 <= ref3 ? ++o : --o) {
                  this.drawTile(targetIcon.left, minX - 1, y);
                  this.drawTile(targetIcon.right, maxX + 1, y);
// Center
                  for (x = p = ref4 = minX, ref5 = maxX; (ref4 <= ref5 ? p <= ref5 : p >= ref5); x = ref4 <= ref5 ? ++p : --p) {
                    this.drawTile(targetIcon.center, x, y);
                  }
                }
                // Make center darker
                this.drawTile(targetIcon.center, this.targetX + 1, this.targetY);
              } else {
                this.drawTile(targetIcon.center, this.targetX + 1, this.targetY);
                this.drawTile(targetIcon.left, this.targetX, this.targetY);
                this.drawTile(targetIcon.top, this.targetX + 1, this.targetY - 1);
                this.drawTile(targetIcon.right, this.targetX + 2, this.targetY);
                this.drawTile(targetIcon.bottom, this.targetX + 1, this.targetY + 1);
              }
              selectIcon = Data.icons.selectActive;
              break;
            case CombatView.SELECT_VIEW:
              selectIcon = Data.icons.selectView;
          }
          if (this.selectMode !== CombatView.SELECT_TARGET || this.targetX !== this.selectX || this.targetY !== this.selectY) {
            this.drawTile(selectIcon.center, this.selectX + 1, this.selectY);
            this.drawTile(selectIcon.left, this.selectX, this.selectY);
            this.drawTile(selectIcon.top, this.selectX + 1, this.selectY - 1);
            this.drawTile(selectIcon.right, this.selectX + 2, this.selectY);
            return this.drawTile(selectIcon.bottom, this.selectX + 1, this.selectY + 1);
          }
        }
      }

      clearActions() {
        boundMethodCheck(this, CombatView);
        return this.clearAllButtons();
      }

      checkForLoss() {
        var combatant, l, len, ref;
        boundMethodCheck(this, CombatView);
        ref = this.combatants;
        for (l = 0, len = ref.length; l < len; l++) {
          combatant = ref[l];
          if (combatant.isPlayer) {
            return false;
          }
        }
        return true;
      }

      checkForWin() {
        var combatant, l, len, ref;
        boundMethodCheck(this, CombatView);
        ref = this.combatants;
        for (l = 0, len = ref.length; l < len; l++) {
          combatant = ref[l];
          if (!combatant.good) {
            return false;
          }
        }
        return true;
      }

      startTurn() {
        var combatant, f, numMoves;
        boundMethodCheck(this, CombatView);
        // Check for end-of-combat scenarios
        if (this.checkForLoss()) {
          return this.gurk.popView("defeat");
        } else if (this.checkForWin()) {
          return this.gurk.popView("victory");
        } else {
          combatant = this.combatants[this.current];
          combatant.startTurn();
          this.select(combatant.x, combatant.y, CombatView.SELECT_ACTIVE);
          if (combatant.isParalyzed()) {
            this.clearActions();
            this.isParalyzed = true;
            this.addPause("Paralyzed Pause 1");
            this.addPause("Paralyzed Pause 2");
            return this.addAction(this.passTurn, "Paralyzed Pass Turn");
          // @nextAction()
          } else if (combatant.good) {
            return this.startPlayerTurn();
          } else {
            this.clearActions();
            this.addPause("AI Start Pause");
            numMoves = combatant.isRooted() ? 0 : combatant.numMoves;
            f = () => {
              return this.strategy.doTurn(combatant, numMoves, combatant.numAttacks);
            };
            return this.addAction(f, "AI Do Turn");
          }
        }
      }

      startPlayerTurn() {
        var canCast, canUse, player;
        boundMethodCheck(this, CombatView);
        this.castingSpell = null;
        this.spellType = null;
        this.areaSpell = false;
        this.areaAttack = false;
        if (this.checkForLoss()) {
          this.gurk.popView("defeat");
          return;
        } else if (this.checkForWin()) {
          this.gurk.popView("victory");
          return;
        }
        player = this.combatants[this.current];
        this.select(player.x, player.y, CombatView.SELECT_ACTIVE);
        this.spellType = CombatView.SPELL_NONE;
        this.clearActions();
        if (player.isRooted()) {
          player.movesLeft = 0;
        }
        if (player.movesLeft > 0) {
          this.enableMovement();
        }
        // todo - also figure out what moves are allowed and clear/add those as appropriate
        this.setButton(5, "VIEW");
        this.setButton(7, "PASS");
        if (player.isPlayer) {
          if (player.entity.getEquipableItemsByType(Item.TYPE_WEAPON).length > 1 || player.entity.getEquipableItemsByType(Item.TYPE_WEAPON).length === 1 && player.entity.getWeapon() === null) {
            this.setButton(3, "WIELD");
          }
        }
        if (this.canAttackMelee(player) || player.canAttackRange()) {
          if (player.canAttackRange()) {
            if (this.canAttackMelee(player) && player.entity.canAttackMelee()) {
              this.setButton(1, "ATT/FIRE");
            } else {
              this.setButton(1, "FIRE");
            }
          } else {
            if (this.canAttackMelee(player)) {
              this.setButton(1, "ATTACK");
            }
          }
        }
        canCast = this.canCast(player);
        canUse = this.canUse(player, this.canAttackMelee(player), this.canSummon(player));
        if (canCast && canUse) {
          this.setButton(9, "CAST/USE");
        } else if (canCast) {
          this.setButton(9, "CAST");
        } else if (canUse) {
          this.setButton(9, "USE");
        }
        return this.draw();
      }

      move(dx, dy) {
        var casting, combatant, key, target, x, y;
        boundMethodCheck(this, CombatView);
        if (this.selectMode === CombatView.SELECT_TARGET) {
          combatant = this.combatants[this.current];
          casting = this.spellType !== CombatView.SPELL_NONE;
          x = this.targetX + dx;
          y = this.targetY + dy;
          if (this.isInMeleeRangeXY(combatant, x, y) || (!casting && (combatant.canAttackRange())) || (casting && (this.spellTarget === CombatView.SPELL_TARGET_RANGE || this.spellType === CombatView.SPELL_TELEPORT))) {
            if (x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE && y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE) {
              this.targetX = x;
              this.targetY = y;
              target = this.getCombatant(x, y);
              this.clearButton(5);
              this.clearButton(1);
              if (target) {
                this.setButton(1, "INFO");
                if (!casting) {
                  if (this.areEnemies(combatant, target)) {
                    this.setButton(5, "TARGET");
                  }
                } else if (this.castingSpell.target === "area") {
                  this.setButton(5, "TARGET");
                } else {
                  switch (this.spellType) {
                    case CombatView.SPELL_HEAL:
                      if (!this.areEnemies(combatant, target) || this.castingSpell.type === "teleport") {
                        if (this.castingSpell.type === "heal") {
                          if (this.castingSpell.healType === "restore") {
                            this.setButton(5, "RESTORE");
                          } else if (this.castingSpell.healType === "remove") {
                            this.setButton(5, "CURE");
                          } else {
                            this.setButton(5, "HEAL");
                          }
                        } else {
                          this.setButton(5, "TARGET");
                        }
                      }
                      break;
                    case CombatView.SPELL_DAMAGE:
                      if (this.areEnemies(combatant, target)) {
                        this.setButton(5, "TARGET");
                      }
                  }
                }
              } else {
                if (casting) {
                  if (this.spellType === CombatView.SPELL_SUMMON) {
                    this.setButton(5, "SUMMON");
                  } else if (this.spellType === CombatView.SPELL_TELEPORT) {
                    this.setButton(5, "TELEPORT");
                  } else if (this.castingSpell.target === "area") {
                    this.setButton(5, "TARGET");
                  }
                } else if (this.areaAttack) {
                  this.setButton(5, "TARGET");
                }
              }
              return this.updateBanner();
            } else {
              return false;
            }
          } else {
            return false;
          }
        } else if (this.selectMode === CombatView.SELECT_VIEW) {
          x = this.selectX + dx;
          y = this.selectY + dy;
          if (x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE && y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE) {
            this.selectX = x;
            this.selectY = y;
            if (this.getCombatant(x, y)) {
              this.setButton(5, "INFO");
            } else {
              this.clearButton(5);
            }
            return this.updateBanner();
          } else {
            return false;
          }
        } else {
          combatant = this.combatants[this.current];
          if (combatant.movesLeft > 0) {
            x = combatant.x + dx;
            y = combatant.y + dy;
            if (x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE && y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE) {
              key = Game.getKey(x, y);
              if (!this.combatMap[key]) {
                this.addSound("move", "Move Sound");
                this.moveCombatant(combatant.x, combatant.y, x, y);
                combatant.movesLeft--;
                if (combatant.movesLeft === 0) {
                  combatant.attacksLeft = 0;
                }
                this.draw();
                this.endTurn();
              }
            }
          }
          return false;
        }
      }

      updateBanner() {
        var banner, combatant, x, y;
        boundMethodCheck(this, CombatView);
        if (this.selectMode === CombatView.SELECT_TARGET || this.selectMode === CombatView.SELECT_TARGETED) {
          x = this.targetX;
          y = this.targetY;
        } else if (this.selectMode === CombatView.SELECT_VIEW) {
          x = this.selectX;
          y = this.selectY;
        } else {
          combatant = this.combatants[this.current];
          x = combatant.x;
          y = combatant.y;
        }
        combatant = this.getCombatant(x, y);
        if (combatant && this.selectMode !== CombatView.SELECT_OFF) {
          banner = `${combatant.getBanner()} (HP: ${combatant.hitPoints}`;
          if (combatant.good && combatant.entity.maxSpellPoints > 0) {
            banner += `, SP: ${combatant.entity.spellPoints})`;
          } else {
            banner += ")";
          }
          this.setBanner(banner);
          if (this.selectMode === CombatView.SELECT_ACTIVE && combatant.good) {
            if (!combatant.isParalyzed() && (combatant.numMoves > 1 || combatant.numAttacks > 1)) {
              this.setTopBanner(combatant.movesLeft, combatant.attacksLeft, combatant.halfAttack);
            } else {
              this.clearTopBanner();
            }
            this.topBannerLeft = this.selectX > 3;
          } else {
            this.clearTopBanner();
          }
        } else {
          this.clearBanner();
          this.clearTopBanner();
        }
        return this.draw();
      }

      passTurn() {
        var combatant;
        boundMethodCheck(this, CombatView);
        combatant = this.combatants[this.current];
        combatant.movesLeft = 0;
        combatant.attacksLeft = 0;
        return this.endTurn();
      }

      endTurn() {
        var action, combatant, damage, f, fx, wasPlayer;
        boundMethodCheck(this, CombatView);
        combatant = this.combatants[this.current];
        wasPlayer = combatant.good;
        if (wasPlayer && combatant.notDone()) {
          action = () => {
            return this.startPlayerTurn();
          };
        } else {
          if (combatant.isPoisoned()) {
            damage = combatant.getEffect("Poisoned").value;
            if (combatant.hitPoints - damage < 1) {
              damage = combatant.hitPoints - 1;
            }
            if (damage > 0) {
              f = () => {
                this.targetX = combatant.x;
                this.targetY = combatant.y;
                this.selectMode = CombatView.SELECT_TARGETED;
                this.updateBanner();
                return this.doDamage(combatant, damage, Data.icons.animPoison);
              };
              this.addAction(f, "Do Poison Damage");
              this.addPause("Pause After Poison Damage");
            }
          }
          fx = () => {
            return combatant.incrementEffects(this.imageProcessor, this.draw);
          };
          this.addAction(fx, "Increment FX");
          action = () => {
            this.current++;
            if (this.current >= this.combatants.length) {
              this.current = 0;
            }
            return this.startTurn();
          };
        }
        this.addAction(action, "End Turn");
        // Play through the queue
        if (wasPlayer && !this.isParalyzed) {
          return this.nextAction();
        } else {
          return this.isParalyzed = false;
        }
      }

      startPlayerAttack() {
        var player, target;
        boundMethodCheck(this, CombatView);
        player = this.combatants[this.current];
        target = this.getSuggestedEnemyTarget(player);
        this.areaAttack = player.canAttackArea();
        if (target) {
          this.select(target.x, target.y, CombatView.SELECT_TARGET);
          this.clearActions();
          this.enableMovement();
          this.setButton(1, "INFO");
          this.setButton(5, "TARGET");
          this.setButton(7, "CANCEL");
        }
        return this.draw();
      }

      getSuggestedEnemyTarget(player, forceRange = false) {
        var target;
        boundMethodCheck(this, CombatView);
        target = null;
        if (player.lastTarget && this.isStillAlive(player.lastTarget) && this.canAttack(player, player.lastTarget)) {
          target = player.lastTarget;
        }
        if (!target) {
          target = this.getNearestAttackTarget(player, forceRange);
        }
        return target;
      }

      startPlayerCast() {
        var melee, player, summon;
        boundMethodCheck(this, CombatView);
        this.areaSpell = false;
        this.drainAmount = 0;
        player = this.combatants[this.current];
        melee = this.canAttackMelee(player);
        summon = this.canSummon(player);
        this.selectingItemForUse = true;
        return this.gurk.pushView(new SpellView(this.gurk, player.entity, true, melee, summon, player));
      }

      startPlayerUse() {
        var melee, player, summon;
        boundMethodCheck(this, CombatView);
        this.areaSpell = false;
        player = this.combatants[this.current];
        melee = this.canAttackMelee(player);
        summon = this.canSummon(player);
        this.selectingItemForUse = true;
        return this.gurk.pushView(new ItemView(this.gurk, player.entity, ItemView.ACTION_USE, true, melee, summon, player));
      }

      startPlayerWield() {
        var player;
        boundMethodCheck(this, CombatView);
        player = this.combatants[this.current].entity;
        this.selectingItemForUse = false;
        return this.gurk.pushView(new ItemView(this.gurk, player, ItemView.ACTION_EQUIP, 0, true));
      }

      doPlayerCast() {
        var player, square, target;
        boundMethodCheck(this, CombatView);
        player = this.combatants[this.current];
        this.clearActions();
        this.enableMovement();
        switch (this.castingSpell.type) {
          case "teleport":
            this.spellType = CombatView.SPELL_TELEPORT;
            this.select(player.x, player.y, CombatView.SELECT_TARGET);
            if (this.castingSpell.target === "self") {
              this.doSpellCast();
              return;
            } else {
              this.setButton(5, "TARGET");
            }
            break;
          case "heal":
          case "enhance":
            this.spellType = CombatView.SPELL_HEAL;
            this.select(player.x, player.y, CombatView.SELECT_TARGET);
            if (this.castingSpell.target === "self") {
              this.doSpellCast();
              return;
            } else if (this.castingSpell.type === "heal") {
              this.setButton(5, "HEAL");
            } else {
              this.setButton(5, "TARGET");
            }
            break;
          case "damage":
          case "afflict":
          case "drain":
            this.spellType = CombatView.SPELL_DAMAGE;
            target = this.getSuggestedEnemyTarget(player, true);
            this.select(target.x, target.y, CombatView.SELECT_TARGET);
            this.setButton(5, "TARGET");
            break;
          case "summon":
            this.spellType = CombatView.SPELL_SUMMON;
            square = this.getSuggestedSummonSquare(player);
            if (square !== null) { // Shouldn't happen, spell shouldn't appear unless can summon
              this.select(square.x, square.y, CombatView.SELECT_TARGET);
              this.setButton(5, "SUMMON");
            }
        }
        if (this.castingSpell.target === "touch") {
          this.spellTarget = CombatView.SPELL_TARGET_MELEE;
        } else {
          this.spellTarget = CombatView.SPELL_TARGET_RANGE;
        }
        if (this.castingSpell.target === "area") {
          this.areaSpell = true;
        }
        return this.setButton(7, "CANCEL");
      }

      computeSpellTiming(combatant, spell) {
        boundMethodCheck(this, CombatView);
        if (spell.fast) {
          if (combatant.halfAttack) {
            combatant.attacksLeft--;
            combatant.movesLeft = 0;
            return combatant.halfAttack = false;
          } else {
            return combatant.halfAttack = true;
          }
        } else {
          combatant.attacksLeft--;
          return combatant.movesLeft = 0;
        }
      }

      doSpellCast() {
        var player, square;
        boundMethodCheck(this, CombatView);
        this.clearActions();
        player = this.combatants[this.current];
        if (this.castingSpell.type === "teleport") {
          if (this.teleportTarget) {
            this.selectMode = CombatView.SELECT_TARGETED;
            this.addSound("spell", "Cast Sound");
            this.addAction(this.doSpellResult, "Spell Result Action");
            this.computeSpellTiming(player, this.castingSpell);
            return this.endTurn();
          } else {
            if (this.castingSpell.target === "self") {
              this.teleportTarget = this.combatants[this.current];
            } else {
              this.teleportTarget = this.getCombatant(this.targetX, this.targetY);
            }
            this.spellType = CombatView.SPELL_TELEPORT;
            this.spellTarget = CombatView.SPELL_TARGET_RANGE;
            square = this.getSuggestedSummonSquare(this.teleportTarget);
            if (square === null) {
              square = this.getRandomSquare();
            }
            if (square !== null) {
              this.select(square.x, square.y, CombatView.SELECT_TARGET);
              this.enableMovement();
              this.setButton(5, "TELEPORT");
              return this.setButton(7, "CANCEL");
            }
          }
        } else {
          this.selectMode = CombatView.SELECT_TARGETED;
          this.addSound("spell", "Cast Sound");
          this.queueAnimation(player.x, player.y, Data.icons.animSpellCast, "Spell Cast Animation");
          if (this.castingSpell.target === "range" || this.castingSpell.target === "area") {
            this.queueFly(player.x, player.y, this.targetX, this.targetY, this.castingSpell.animation, "Spell Range Animation");
          }
          this.addAction(this.doSpellResult, "Spell Result Action");
          this.computeSpellTiming(player, this.castingSpell);
          return this.endTurn();
        }
      }

      doSpellResult() {
        var amount, bonus, bounds, caster, damage, f, fromItem, isPlayer, ref, spell, target, value;
        boundMethodCheck(this, CombatView);
        caster = this.combatants[this.current];
        isPlayer = caster.isPlayer;
        spell = this.castingSpell;
        fromItem = this.usingItem !== null;
        target = this.getCombatant(this.targetX, this.targetY);
        if (fromItem && isPlayer) {
          if (this.usingItem.getCombatSpell() === spell) {
            caster.useCombatSpell(this.usingItem);
          } else if (this.usingItem.isUseable()) {
            this.usingItem.charges--;
            if (this.usingItem.charges === 0) {
              caster.entity.dropItem(this.usingItem);
            }
          }
        } else if (caster.good) {
          caster.entity.spellPoints -= spell.spellPoints;
        }
        switch (spell.type) {
          case "heal":
            if (fromItem) {
              bounds = this.usingItem.getSpellRange();
            } else {
              bounds = caster.entity.getSpellRange(spell);
            }
            if (spell.target === "area") {
              this.doAreaHealing(bounds, spell.healType);
            } else {
              this.addSound("heal", "Heal Sound");
              this.queueAnimation(this.targetX, this.targetY, Data.icons.animHeal, "Heal Animation");
              amount = Util.random(bounds.min, bounds.max);
              target.doHeal(amount, spell.healType, this.imageProcessor, this.draw);
              this.updateBanner();
            }
            break;
          case "drain":
            if (fromItem) {
              bounds = this.usingItem.getSpellRange();
            } else {
              bounds = caster.entity.getSpellRange(spell);
            }
            if (this.drainAmount > 0) {
              amount = Math.round(spell.value * this.drainAmount / 100);
              if (amount < 1) {
                amount = 1;
              }
            } else {
              damage = this.resistDamage(caster, target, bounds);
              if (damage === 0) {
                this.doResist(target);
                amount = 0;
              } else {
                this.doDamage(target, damage, Data.icons.animHitSpell);
                amount = Math.round(spell.value * damage / 100);
                if (amount < 1) {
                  amount = 1;
                }
              }
            }
            if (amount > 0 && !caster.isFullyHealed()) {
              f = () => {
                this.addSound("heal", "Drain Sound");
                this.queueAnimation(caster.x, caster.y, Data.icons.animHeal, "Drain Animation");
                caster.doHeal(amount, "heal", this.imageProcessor, this.draw);
                this.setTarget(caster);
                return this.updateBanner();
              };
              this.addAction(f, "Drain Heal");
            }
            break;
          case "damage":
            if (fromItem) {
              bounds = this.usingItem.getSpellRange();
            } else {
              bounds = caster.entity.getSpellRange(spell);
            }
            if (spell.target === "area") {
              this.doAreaDamage(bounds);
            } else {
              amount = this.resistDamage(caster, target, bounds);
              if (amount === 0) {
                this.doResist(target);
              } else {
                this.doDamage(target, amount, Data.icons.animHitSpell);
              }
            }
            break;
          case "summon":
            this.addSound("summon", "Summon Sound");
            this.queueAnimation(this.targetX, this.targetY, Data.icons.animHeal, "Summon Animation");
            if (fromItem) {
              bonus = this.usingItem.bonus;
            } else {
              if (isPlayer) {
                bonus = Math.ceil(caster.entity.getAttributeBonus(caster.entity.getAwareness()) / 2);
              } else {
                bonus = (ref = caster.entity.bonus) != null ? ref : 0;
              }
            }
            this.summonCreature(spell.creature, bonus, caster.good, this.targetX, this.targetY);
            break;
          case "teleport":
            if (!this.areEnemies(caster, this.teleportTarget) || !this.doSavingThrow(caster, this.teleportTarget)) {
              this.teleportTarget.invisible = true;
              this.addSound("tele", "Start Teleport Sound");
              this.queueAnimation(this.teleportTarget.x, this.teleportTarget.y, Data.icons.animHeal, "Teleport Start Animation");
              f = () => {
                this.moveCombatant(this.teleportTarget.x, this.teleportTarget.y, this.targetX, this.targetY);
                this.teleportTarget.invisible = false;
                this.teleportTarget = null;
                this.addSound("port", "End Teleport Sound");
                return this.queueAnimation(this.targetX, this.targetY, Data.icons.animHeal, "Teleport Animation");
              };
              this.addAction(f, "Complete Teleportation");
            } else {
              this.showResist(this.teleportTarget);
              this.teleportTarget = null;
            }
            break;
          case "enhance":
          case "afflict":
            if (fromItem) {
              bonus = this.usingItem.bonus;
            } else {
              if (isPlayer) {
                bonus = caster.entity.getAttributeBonus(caster.entity.getAwareness());
              } else {
                bonus = caster.entity.bonus;
              }
            }
            if (spell.target === "area") {
              // Decided to go no bonus for effects
              this.doAreaEffect(spell, 0);
            } else {
              if (!this.areEnemies(caster, target) || !this.doSavingThrow(caster, target)) {
                if (this.areEnemies(caster, target)) {
                  this.addSound("afflicted", "Afflict Sound");
                } else {
                  this.addSound("enhanced", "Enhance Sound");
                }
                this.queueAnimation(this.targetX, this.targetY, Data.icons.animHeal, "Effect Animation");
                value = spell.value;
                target.addEffect(spell.effect, value, Util.random(spell.minAmount, spell.maxAmount), caster);
                f = () => {
                  return this.processIcon(target);
                };
                this.addAction(f, "Show Effect");
              } else {
                this.showResist(target);
              }
            }
        }
        this.castingSpell = null;
        return this.usingItem = null;
      }

      doPlayerAttack() {
        var player, target;
        boundMethodCheck(this, CombatView);
        player = this.combatants[this.current];
        if (this.areaAttack) {
          this.addSound("fire", "Area Fire Sound");
          this.queueFly(player.x, player.y, this.targetX, this.targetY, player.getRangeAnimation(), "Area projectile fly");
          this.addAction(this.doAreaAttack, "Run Area Attack");
          this.clearActions();
          this.selectMode = CombatView.SELECT_TARGETED;
          player.didAttack = true;
          player.attacksLeft--;
          player.movesLeft = 0;
          return this.endTurn();
        } else {
          target = this.getCombatant(this.targetX, this.targetY);
          if (target && this.areEnemies(player, target) && this.canAttack(player, target)) {
            player.lastTarget = target;
            this.clearActions();
            this.selectMode = CombatView.SELECT_TARGETED;
            if (!this.isInMeleeRange(player, target) || this.isFiring) {
              this.addSound("fire", "Fire Sound");
              this.queueFly(player.x, player.y, target.x, target.y, player.getRangeAnimation(), "Range projectile fly");
              this.addAction(this.runAttack, "Run Range Attack");
            } else {
              this.addAction(this.runAttack, "Run Melee Attack");
            }
            player.didAttack = true;
            player.attacksLeft--;
            player.movesLeft = 0;
            return this.endTurn();
          }
        }
      }

      runAttack() {
        var attacker, target;
        boundMethodCheck(this, CombatView);
        attacker = this.combatants[this.current];
        target = this.getCombatant(this.targetX, this.targetY);
        return this.processAttack(attacker, target);
      }

      processAttack(attacker, target, rangeOverride = false) {
        var ac, bounds, damage, dead, dice, fail, hitRoll, melee, square;
        boundMethodCheck(this, CombatView);
        melee = this.isInMeleeRange(attacker, target) && !rangeOverride;
        ac = target.getArmorClass();
        if (!melee) {
          ac += this.getRangeACBonus(attacker, target);
        }
        dice = Util.random(1, 20);
        hitRoll = dice + attacker.getToHitBonus();
        if (dice === 20 || (dice !== 1 && hitRoll > target.getArmorClass())) {
          if (melee) {
            bounds = attacker.getMeleeDamageBounds();
          } else {
            bounds = attacker.getRangeDamageBounds();
          }
          damage = Util.random(bounds.min, bounds.max);
          this.drainAmount = Math.min(damage, target.hitPoints);
          dead = this.doDamage(target, damage);
          if (attacker.getHitSpell()) {
            this.castingSpell = attacker.getHitSpell();
            if (attacker.isPlayer) {
              this.usingItem = attacker.entity.getWeapon();
            }
            if (!dead || this.castingSpell.type === "drain") {
              fail = false;
              if (this.castingSpell.type === "teleport") {
                this.teleportTarget = target;
                if (!attacker.good) {
                  square = this.getRandomSquare();
                  if (!square) {
                    fail = true;
                  } else {
                    this.targetX = square.x;
                    this.targetY = square.y;
                  }
                }
              }
              if (!fail) {
                return this.addAction(this.doSpellResult, "Do Hit Spell");
              }
            }
          }
        } else {
          this.addSound("miss", "Miss Sound");
          return this.queueAnimation(target.x, target.y, Data.icons.animMiss, "Miss Animation");
        }
      }

      doAreaEffect(spell, bonus) {
        var caster, f, value;
        boundMethodCheck(this, CombatView);
        this.queueBlockAnimation(this.targetX, this.targetY, 1, this.castingSpell.animation, "Area Spell Animation");
        caster = this.combatants[this.current];
        value = Math.max(spell.value + bonus, 1);
        f = () => {
          var j, l, ref, ref1, results1, target, x, y;
          results1 = [];
          for (y = l = ref = this.targetY - 1, ref1 = this.targetY + 1; (ref <= ref1 ? l <= ref1 : l >= ref1); y = ref <= ref1 ? ++l : --l) {
            if (y >= 0 && y < this.height) {
              results1.push((function() {
                var o, ref2, ref3, results2;
                results2 = [];
                for (x = o = ref2 = this.targetX - 1, ref3 = this.targetX + 1; (ref2 <= ref3 ? o <= ref3 : o >= ref3); x = ref2 <= ref3 ? ++o : --o) {
                  if (x >= 0 && x < this.width) {
                    target = this.getCombatant(x, y);
                    if (target && (spell.type === "enhance" || target !== caster)) {
                      j = () => {
                        var g, showTarget;
                        showTarget = target;
                        if (!this.areEnemies(caster, showTarget) || !this.doSavingThrow(caster, showTarget)) {
                          g = () => {
                            var h;
                            if (this.areEnemies(caster, showTarget)) {
                              this.addSound("afflicted", "Area Afflict Sound");
                            } else {
                              this.addSound("enhanced", "Area Enhance Sound");
                            }
                            this.queueAnimation(showTarget.x, showTarget.y, Data.icons.animHeal, "Area Effect Animation");
                            showTarget.addEffect(spell.effect, value, Util.random(spell.minAmount, spell.maxAmount), caster);
                            h = () => {
                              this.processIcon(showTarget);
                              return this.draw();
                            };
                            return this.addAction(h, "Do Area Effect Processing");
                          };
                          return this.addAction(g, "Show Area Target Effect");
                        } else {
                          g = () => {
                            return this.showResist(showTarget);
                          };
                          return this.addAction(g, "Show Area Target Resist");
                        }
                      };
                      results2.push(j());
                    } else {
                      results2.push(void 0);
                    }
                  } else {
                    results2.push(void 0);
                  }
                }
                return results2;
              }).call(this));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        };
        return this.addAction(f, "Show Effect");
      }

      doAreaHealing(bounds, healType) {
        var amount, caster, g, l, ref, ref1, results1, target, x, y;
        boundMethodCheck(this, CombatView);
        this.queueBlockAnimation(this.targetX, this.targetY, 1, this.castingSpell.animation, "Area Spell Animation");
        caster = this.combatants[this.current];
        results1 = [];
        for (y = l = ref = this.targetY - 1, ref1 = this.targetY + 1; (ref <= ref1 ? l <= ref1 : l >= ref1); y = ref <= ref1 ? ++l : --l) {
          if (y >= 0 && y < this.height) {
            results1.push((function() {
              var o, ref2, ref3, results2;
              results2 = [];
              for (x = o = ref2 = this.targetX - 1, ref3 = this.targetX + 1; (ref2 <= ref3 ? o <= ref3 : o >= ref3); x = ref2 <= ref3 ? ++o : --o) {
                if (x >= 0 && x < this.width) {
                  target = this.getCombatant(x, y);
                  if (target) {
                    amount = Util.random(bounds.min, bounds.max);
                    g = () => {
                      var f, heal, showTarget;
                      showTarget = target;
                      heal = amount;
                      f = () => {
                        return this.showAreaHealing(showTarget, heal, healType);
                      };
                      return this.addAction(f, "Do Area Heal");
                    };
                    results2.push(g());
                  } else {
                    results2.push(void 0);
                  }
                } else {
                  results2.push(void 0);
                }
              }
              return results2;
            }).call(this));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      doAreaAttack() {
        var combatant, g, l, ref, ref1, results1, target, x, y;
        boundMethodCheck(this, CombatView);
        combatant = this.combatants[this.current];
        this.queueBlockAnimation(this.targetX, this.targetY, 1, combatant.getRangeAnimation(), "Area Attack Animation");
        results1 = [];
        for (y = l = ref = this.targetY - 1, ref1 = this.targetY + 1; (ref <= ref1 ? l <= ref1 : l >= ref1); y = ref <= ref1 ? ++l : --l) {
          if (y >= 0 && y < this.height) {
            results1.push((function() {
              var o, ref2, ref3, results2;
              results2 = [];
              for (x = o = ref2 = this.targetX - 1, ref3 = this.targetX + 1; (ref2 <= ref3 ? o <= ref3 : o >= ref3); x = ref2 <= ref3 ? ++o : --o) {
                if (x >= 0 && x < this.width) {
                  target = this.getCombatant(x, y);
                  if (target && target !== combatant) {
                    g = () => {
                      var f, theTarget;
                      theTarget = target;
                      f = () => {
                        this.targetX = theTarget.x;
                        this.targetY = theTarget.y;
                        this.updateBanner();
                        return this.processAttack(combatant, theTarget, true);
                      };
                      return this.addAction(f);
                    };
                    results2.push(g());
                  } else {
                    results2.push(void 0);
                  }
                } else {
                  results2.push(void 0);
                }
              }
              return results2;
            }).call(this));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      doAreaDamage(bounds) {
        var amount, caster, g, l, ref, ref1, results1, target, x, y;
        boundMethodCheck(this, CombatView);
        this.queueBlockAnimation(this.targetX, this.targetY, 1, this.castingSpell.animation, "Area Spell Animation");
        caster = this.combatants[this.current];
        results1 = [];
        for (y = l = ref = this.targetY - 1, ref1 = this.targetY + 1; (ref <= ref1 ? l <= ref1 : l >= ref1); y = ref <= ref1 ? ++l : --l) {
          if (y >= 0 && y < this.height) {
            results1.push((function() {
              var o, ref2, ref3, results2;
              results2 = [];
              for (x = o = ref2 = this.targetX - 1, ref3 = this.targetX + 1; (ref2 <= ref3 ? o <= ref3 : o >= ref3); x = ref2 <= ref3 ? ++o : --o) {
                if (x >= 0 && x < this.width) {
                  target = this.getCombatant(x, y);
                  if (target && target !== caster) {
                    amount = this.resistDamage(caster, target, bounds);
                    g = () => {
                      var damage, f, showTarget;
                      showTarget = target;
                      damage = amount;
                      if (damage === 0) {
                        f = () => {
                          return this.showResist(showTarget);
                        };
                      } else {
                        f = () => {
                          return this.showAreaDamage(showTarget, damage);
                        };
                      }
                      return this.addAction(f, "Do Area Damage");
                    };
                    results2.push(g());
                  } else {
                    results2.push(void 0);
                  }
                } else {
                  results2.push(void 0);
                }
              }
              return results2;
            }).call(this));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      showAreaHealing(target, heal, healType) {
        boundMethodCheck(this, CombatView);
        target.doHeal(heal, healType, this.imageProcessor, this.draw);
        this.targetX = target.x;
        this.targetY = target.y;
        this.updateBanner();
        this.addSound("heal", "Heal Sound");
        return this.queueAnimation(target.x, target.y, Data.icons.animHeal, "Heal Animation");
      }

      showResist(target) {
        boundMethodCheck(this, CombatView);
        this.targetX = target.x;
        this.targetY = target.y;
        this.updateBanner();
        this.addSound("resist", "Resist Sound");
        return this.queueAnimation(target.x, target.y, Data.icons.animResist, "Resist Animation");
      }

      showAreaDamage(target, damage) {
        var dead;
        boundMethodCheck(this, CombatView);
        dead = target.doDamage(damage);
        this.targetX = target.x;
        this.targetY = target.y;
        this.updateBanner();
        if (dead) {
          if (target.good) {
            this.addSound("dead", "Died Sound");
          } else {
            this.addSound("killed", "Killed Sound");
          }
          this.removeCombatant(target);
        } else {
          this.addSound("hit", "Hit Sound");
        }
        return this.queueAnimation(target.x, target.y, Data.icons.animHitSpell, "Hit Animation");
      }

      doResist(target) {
        boundMethodCheck(this, CombatView);
        return this.showResist(target);
      }

      doDamage(target, damage, anim = null) {
        var dead;
        boundMethodCheck(this, CombatView);
        dead = target.doDamage(damage);
        this.updateBanner();
        if (dead) {
          if (target.good) {
            this.addSound("died", "Died Sound");
          } else {
            this.addSound("killed", "Killed Sound");
          }
          this.removeCombatant(target);
        } else {
          this.addSound("hit", "Hit Sound");
        }
        if (anim === null) {
          anim = Data.icons.animHit;
        }
        this.queueAnimation(target.x, target.y, anim, "Hit Animation");
        return dead;
      }

      addCreatures(creatures) {
        var combatant, creature, l, len, results1;
        boundMethodCheck(this, CombatView);
        results1 = [];
        for (l = 0, len = creatures.length; l < len; l++) {
          creature = creatures[l];
          combatant = new Combatant(creature, false, false);
          results1.push(this.addCombatant(combatant));
        }
        return results1;
      }

      addPlayers() {
        var combatant, index, l, len, player, ref, results1;
        boundMethodCheck(this, CombatView);
        index = 0;
        ref = this.gurk.game.players;
        results1 = [];
        for (l = 0, len = ref.length; l < len; l++) {
          player = ref[l];
          if (player.isAlive()) {
            combatant = new Combatant(player, true, true, CombatView.FORMATION[index].x, CombatView.FORMATION[index].y);
            this.addCombatant(combatant);
          }
          results1.push(index++);
        }
        return results1;
      }

      addCombatant(combatant) {
        var key, x, y;
        boundMethodCheck(this, CombatView);
        x = combatant.x;
        y = combatant.y;
        key = Game.getKey(x, y);
        while (x === -1 || this.combatMap[key]) {
          x = Util.random(0, 6);
          y = Util.random(0, 3);
          key = Game.getKey(x, y);
        }
        combatant.x = x;
        combatant.y = y;
        this.combatMap[key] = combatant;
        return this.combatants.push(combatant);
      }

      summonCreature(name, bonus, good, x, y) {
        var combatant, creature, key, template;
        boundMethodCheck(this, CombatView);
        template = Library.getCreatureByName(name);
        creature = new Creature(template, bonus);
        combatant = new Combatant(creature, false, good, x, y);
        this.combatants.splice(this.current, 0, combatant);
        this.current++;
        key = Game.getKey(x, y);
        return this.combatMap[key] = combatant;
      }

      clearSelection() {
        boundMethodCheck(this, CombatView);
        this.selectMode = CombatView.SELECT_OFF;
        this.updateBanner();
        return this.draw();
      }

      select(x, y, mode) {
        boundMethodCheck(this, CombatView);
        if (mode === CombatView.SELECT_TARGET) {
          this.targetX = x;
          this.targetY = y;
        } else {
          this.selectX = x;
          this.selectY = y;
        }
        this.selectMode = mode;
        return this.updateBanner();
      }

      getCombatant(x, y) {
        var key;
        boundMethodCheck(this, CombatView);
        key = Game.getKey(x, y);
        return this.combatMap[key];
      }

      moveCombatant(sx, sy, tx, ty) {
        var combatant, key;
        boundMethodCheck(this, CombatView);
        key = Game.getKey(sx, sy);
        combatant = this.combatMap[key];
        delete this.combatMap[key];
        combatant.x = tx;
        combatant.y = ty;
        key = Game.getKey(tx, ty);
        return this.combatMap[key] = combatant;
      }

      getSurroundingSquares(x, y, forEnemy = false) {
        var l, len, o, ref, ref1, squares, xx, yList, yy;
        boundMethodCheck(this, CombatView);
        squares = [];
        if (forEnemy) {
          yList = [y + 1, y, y - 1];
        } else {
          yList = [y - 1, y, y + 1];
        }
        for (l = 0, len = yList.length; l < len; l++) {
          yy = yList[l];
          if (yy >= CombatView.TOP_EDGE && yy <= CombatView.BOTTOM_EDGE) {
            for (xx = o = ref = x - 1, ref1 = x + 1; (ref <= ref1 ? o <= ref1 : o >= ref1); xx = ref <= ref1 ? ++o : --o) {
              if (xx >= CombatView.LEFT_EDGE && xx <= CombatView.RIGHT_EDGE) {
                if (xx !== x || yy !== y) {
                  squares.push({
                    "x": xx,
                    "y": yy
                  });
                }
              }
            }
          }
        }
        return squares;
      }

      areEnemies(combatantA, combatantB) {
        boundMethodCheck(this, CombatView);
        return combatantA.good !== combatantB.good;
      }

      doSavingThrow(caster, defender) {
        var mod, result;
        boundMethodCheck(this, CombatView);
        mod = (defender.getResistance() - caster.getPotency()) * 5 + 5;
        if (mod < 0) {
          mod = 0;
        }
        if (mod > 100) {
          mod = 100;
        }
        result = Util.random(0, 99);
        if (result < 3) {
          return true;
        } else if (result > 96) {
          return false;
        } else {
          return result < mod;
        }
      }

      resistDamage(caster, defender, bounds) {
        var mod;
        boundMethodCheck(this, CombatView);
        mod = 100 - (defender.getResistance() - caster.getPotency() - 3) * 5;
        if (mod < 0) {
          mod = 0;
        }
        if (mod > 100) {
          mod = 100;
        }
        bounds.min = Math.round(bounds.min * mod / 100);
        bounds.max = Math.round(bounds.max * mod / 100);
        if (bounds.min < 0) {
          bounds.min = 0;
        }
        if (bounds.max < 0) {
          bounds.max = 0;
        }
        return Util.random(bounds.min, bounds.max);
      }

      canAttackMelee(combatant) {
        var l, len, other, square, squares;
        boundMethodCheck(this, CombatView);
        squares = this.getSurroundingSquares(combatant.x, combatant.y);
        for (l = 0, len = squares.length; l < len; l++) {
          square = squares[l];
          other = this.getCombatant(square.x, square.y);
          if (other && this.areEnemies(combatant, other)) {
            return true;
          }
        }
        return false;
      }

      canTouchAlly(combatant) {
        var l, len, other, square, squares;
        boundMethodCheck(this, CombatView);
        squares = this.getSurroundingSquares(combatant.x, combatant.y);
        for (l = 0, len = squares.length; l < len; l++) {
          square = squares[l];
          other = this.getCombatant(square.x, square.y);
          if (other && !this.areEnemies(combatant, other)) {
            return true;
          }
        }
        return false;
      }

      canTargetWithSpell(caster, target, isFriendly, isHeal, effect = null) {
        boundMethodCheck(this, CombatView);
        if (isHeal && target.hitPoints === target.getMaxHitPoints()) {
          return false;
        }
        if (isFriendly === this.areEnemies(caster, target)) {
          return false;
        }
        if (effect && target.hasEffect(effect)) {
          return false;
        }
        return true;
      }

      getSpellTargets(caster, isRange, isFriendly, isHeal, includeSelf) {
        var l, len, len1, o, ref, square, squares, target, targets;
        boundMethodCheck(this, CombatView);
        targets = [];
        if (isRange) {
          ref = this.combatants;
          for (l = 0, len = ref.length; l < len; l++) {
            target = ref[l];
            if (this.canTargetWithSpell(caster, target, isFriendly, isHeal)) {
              targets.push(target);
            }
          }
        } else {
          squares = this.getSurroundingSquares(caster.x, caster.y);
          for (o = 0, len1 = squares.length; o < len1; o++) {
            square = squares[o];
            target = this.getCombatant(square.x, square.y);
            if (target && this.canTargetWithSpell(caster, target, isFriendly, isHeal)) {
              targets.push(target);
            }
          }
        }
        if (includeSelf) {
          if (this.canTargetWithSpell(caster, caster, isFriendly, isHeal)) {
            targets.push(caster);
          }
        }
        return targets;
      }

      hasAllies(combatant) {
        var l, len, other, ref;
        boundMethodCheck(this, CombatView);
        ref = this.combatants;
        for (l = 0, len = ref.length; l < len; l++) {
          other = ref[l];
          if (other !== combatant && this.areEnemies(combatant, other)) {
            return true;
          }
        }
        return false;
      }

      getRandomSquare() {
        var clear, tries, x, y;
        boundMethodCheck(this, CombatView);
        // if (x >= CombatView.LEFT_EDGE and x <= CombatView.RIGHT_EDGE and y >= CombatView.TOP_EDGE and y <= CombatView.BOTTOM_EDGE)
        clear = false;
        tries = 0;
        while (!clear && tries < 10) {
          x = Util.random(CombatView.LEFT_EDGE, CombatView.RIGHT_EDGE);
          y = Util.random(CombatView.TOP_EDGE, CombatView.BOTTOM_EDGE);
          clear = !this.getCombatant(x, y);
          tries++;
        }
        if (clear) {
          return {
            "x": x,
            "y": y
          };
        } else {
          return null;
        }
      }

      getSuggestedSummonSquare(combatant) {
        var l, len, square, squares;
        boundMethodCheck(this, CombatView);
        squares = this.getSurroundingSquares(combatant.x, combatant.y, !combatant.good);
        for (l = 0, len = squares.length; l < len; l++) {
          square = squares[l];
          if (this.isClear(square.x, square.y)) {
            return square;
          }
        }
        return null;
      }

      canSummon(combatant) {
        var l, len, square, squares;
        boundMethodCheck(this, CombatView);
        squares = this.getSurroundingSquares(combatant.x, combatant.y);
        for (l = 0, len = squares.length; l < len; l++) {
          square = squares[l];
          if (this.isClear(square.x, square.y)) {
            return true;
          }
        }
        return false;
      }

      isInMeleeRange(combatant, target) {
        var dx, dy;
        boundMethodCheck(this, CombatView);
        dx = Math.abs(combatant.x - target.x);
        dy = Math.abs(combatant.y - target.y);
        return dx <= 1 && dy <= 1;
      }

      isInMeleeRangeXY(combatant, x, y) {
        var dx, dy;
        boundMethodCheck(this, CombatView);
        dx = Math.abs(combatant.x - x);
        dy = Math.abs(combatant.y - y);
        return dx <= 1 && dy <= 1;
      }

      canAttack(combatant, target) {
        boundMethodCheck(this, CombatView);
        if (combatant.canAttackRange()) {
          return true;
        } else {
          return this.isInMeleeRange(combatant, target);
        }
      }

      getRangeACBonus(attacker, target) {
        var d;
        boundMethodCheck(this, CombatView);
        d = Math.abs(target.x - attacker.x) + Math.abs(target.y - attacker.y);
        return Math.floor(d / 3);
      }

      getNearestTarget(combatant, forceRange = false) {
        var count, d, distance, l, len, nearest, ref, target;
        boundMethodCheck(this, CombatView);
        nearest = null;
        distance = 100;
        count = 0;
        ref = this.combatants;
        for (l = 0, len = ref.length; l < len; l++) {
          target = ref[l];
          if (target !== combatant && this.areEnemies(combatant, target) && (this.canAttack(combatant, target) || forceRange)) {
            d = Math.abs(target.x - combatant.x) + Math.abs(target.y - combatant.y);
            if (d === distance) {
              count++;
              if (Util.random(1, count) === 1) {
                nearest = target;
              }
            }
            if (d < distance) {
              distance = d;
              nearest = target;
              count = 1;
            }
          }
        }
        return nearest;
      }

      getNearestAttackTarget(combatant, forceRange = false) {
        var count, d, distance, dx, dy, l, len, nearest, ref, target;
        boundMethodCheck(this, CombatView);
        nearest = null;
        distance = 100;
        count = 0;
        ref = this.combatants;
        for (l = 0, len = ref.length; l < len; l++) {
          target = ref[l];
          if (target !== combatant && this.areEnemies(combatant, target) && (this.canAttack(combatant, target) || forceRange)) {
            dx = Math.abs(target.x - combatant.x);
            dy = Math.abs(target.y - combatant.y);
            if (dx <= 1 && dy <= 1) {
              d = 1;
            } else {
              d = dx + dy;
            }
            if (d === distance) {
              count++;
              if (Util.random(1, count) === 1) {
                nearest = target;
              }
            }
            if (d < distance) {
              distance = d;
              nearest = target;
              count = 1;
            }
          }
        }
        return nearest;
      }

      getNearestEnemy(combatant) {
        var count, d, distance, l, len, nearest, ref, target;
        boundMethodCheck(this, CombatView);
        nearest = null;
        distance = 100;
        count = 0;
        ref = this.combatants;
        for (l = 0, len = ref.length; l < len; l++) {
          target = ref[l];
          if (target !== combatant && this.areEnemies(combatant, target)) {
            d = Math.abs(target.x - combatant.x) + Math.abs(target.y - combatant.y);
            if (d === distance) {
              count++;
              if (Util.random(1, count) === 1) {
                nearest = target;
              }
            }
            if (d < distance) {
              distance = d;
              nearest = target;
              count = 1;
            }
          }
        }
        return nearest;
      }

      getRandomEnemy(combatant) {
        var enemies, l, len, ref, target;
        boundMethodCheck(this, CombatView);
        enemies = [];
        ref = this.combatants;
        for (l = 0, len = ref.length; l < len; l++) {
          target = ref[l];
          if (target !== combatant && this.areEnemies(combatant, target)) {
            enemies.push(target);
          }
        }
        return Util.randomElement(enemies);
      }

      getBestAreaTarget(caster, isAttack) {
        var best, bestScore, combatant, l, o, p, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, score, x, xx, y, yy;
        boundMethodCheck(this, CombatView);
        bestScore = 0;
        best = null;
        for (yy = l = ref = CombatView.TOP_EDGE, ref1 = CombatView.BOTTOM_EDGE; (ref <= ref1 ? l <= ref1 : l >= ref1); yy = ref <= ref1 ? ++l : --l) {
          for (xx = o = ref2 = CombatView.LEFT_EDGE, ref3 = CombatView.RIGHT_EDGE; (ref2 <= ref3 ? o <= ref3 : o >= ref3); xx = ref2 <= ref3 ? ++o : --o) {
            score = 0;
            for (y = p = ref4 = yy - 1, ref5 = yy + 1; (ref4 <= ref5 ? p <= ref5 : p >= ref5); y = ref4 <= ref5 ? ++p : --p) {
              for (x = q = ref6 = xx - 1, ref7 = xx + 1; (ref6 <= ref7 ? q <= ref7 : q >= ref7); x = ref6 <= ref7 ? ++q : --q) {
                if (y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE && x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE) {
                  combatant = this.getCombatant(x, y);
                  if (combatant && (!isAttack || combatant !== caster)) {
                    if (this.areEnemies(caster, combatant) === isAttack) {
                      score += 3;
                    } else {
                      score -= 2;
                    }
                    if (caster === combatant && isAttack) {
                      // Not allowed to target self!
                      score = -10000;
                    }
                  }
                }
              }
            }
            if (score > bestScore) {
              bestScore = score;
              best = {
                "x": xx,
                "y": yy
              };
            }
          }
        }
        return best;
      }

      removeCombatant(combatant) {
        var index, key;
        boundMethodCheck(this, CombatView);
        key = Game.getKey(combatant.x, combatant.y);
        delete this.combatMap[key];
        index = Util.indexOfElement(this.combatants, combatant);
        Util.removeElement(this.combatants, combatant);
        if (index < this.current) {
          return this.current--;
        }
      }

      isStillAlive(combatant) {
        boundMethodCheck(this, CombatView);
        return Util.hasElement(this.combatants, combatant);
      }

      setTarget(combatant) {
        boundMethodCheck(this, CombatView);
        this.selectMode = CombatView.SELECT_TARGETED;
        this.targetX = combatant.x;
        return this.targetY = combatant.y;
      }

      isClear(x, y) {
        boundMethodCheck(this, CombatView);
        if (y >= CombatView.TOP_EDGE && y <= CombatView.BOTTOM_EDGE) {
          if (x >= CombatView.LEFT_EDGE && x <= CombatView.RIGHT_EDGE) {
            if (!this.getCombatant(x, y)) {
              return true;
            }
          }
        }
        return false;
      }

      canCast(combatant) {
        var l, len, spell, spells;
        boundMethodCheck(this, CombatView);
        spells = combatant.entity.getSpells();
        for (l = 0, len = spells.length; l < len; l++) {
          spell = spells[l];
          if (spell.spellPoints <= combatant.entity.spellPoints) {
            return true;
          }
        }
        return false;
      }

      canUse(combatant, melee, summon) {
        boundMethodCheck(this, CombatView);
        if (combatant.isPlayer) {
          return combatant.entity.hasUsableItem(true, melee, summon, combatant);
        }
      }

      processResult(result) {
        var item, player;
        boundMethodCheck(this, CombatView);
        if (result === "debug1") {
          // Automatically win combat
          return this.gurk.popView("victory");
        } else if (result === "debug2") {
          this.queueBlockAnimation(4, 4, 1, Data.icons.animHit, "Test Block Animation");
          return this.nextAction();
        } else if (result.spellPoints) {
          // It's a spell
          this.usingItem = null;
          this.castingSpell = result;
          return this.doPlayerCast();
        } else if ((result === ItemView.NONE || result.template) && !this.selectingItemForUse) {
          // It's a wield result
          item = result;
          player = this.combatants[this.current];
          if (item === ItemView.NONE) {
            player.entity.unequipItemByType(Item.TYPE_WEAPON);
          } else {
            player.entity.equipItem(item);
          }
          player.attacksLeft--;
          player.movesLeft = 0;
          return this.endTurn();
        } else {
          // It's a used item
          this.usingItem = result;
          this.castingSpell = this.usingItem.getSpell();
          if (!this.castingSpell) {
            this.castingSpell = this.usingItem.getCombatSpell();
          }
          return this.doPlayerCast();
        }
      }

    };

    CombatView.FORMATION = [
      {
        "x": 3,
        "y": 5
      },
      {
        "x": 2,
        "y": 6
      },
      {
        "x": 4,
        "y": 6
      }
    ];

    CombatView.SELECT_OFF = 0;

    CombatView.SELECT_VIEW = 1;

    CombatView.SELECT_ACTIVE = 2;

    CombatView.SELECT_TARGET = 3;

    CombatView.SELECT_TARGETED = 4;

    CombatView.SPELL_NONE = 0;

    CombatView.SPELL_HEAL = 1;

    CombatView.SPELL_DAMAGE = 2;

    CombatView.SPELL_SUMMON = 3;

    CombatView.SPELL_TELEPORT = 4;

    CombatView.SPELL_TARGET_MELEE = 0;

    CombatView.SPELL_TARGET_RANGE = 1;

    CombatView.LEFT_EDGE = 0;

    CombatView.RIGHT_EDGE = 6;

    CombatView.TOP_EDGE = 0;

    CombatView.BOTTOM_EDGE = 6;

    CombatView.BASE_SPEED = 175;

    CombatView.BASE_PAUSE = 625;

    CombatView.FAST_SPEED = 120;

    CombatView.FAST_PAUSE = 450;

    CombatView.prototype.combatants = null;

    CombatView.prototype.combatMap = null;

    CombatView.prototype.selectMode = CombatView.SELECT_OFF;

    CombatView.prototype.selectX = 0;

    CombatView.prototype.selectY = 0;

    CombatView.prototype.targetX = 0;

    CombatView.prototype.targetY = 0;

    CombatView.prototype.current = 0;

    CombatView.prototype.castingSpell = null;

    CombatView.prototype.teleportTarget = null;

    CombatView.prototype.usingItem = null;

    CombatView.prototype.spellType = 0;

    CombatView.prototype.spellTarget = 0;

    CombatView.prototype.areaSpell = false;

    CombatView.prototype.areaAttack = false;

    CombatView.prototype.drainAmount = 0;

    CombatView.prototype.selectingItemForUse = false;

    CombatView.prototype.queue = null;

    CombatView.prototype.stack = null;

    CombatView.prototype.combatSpeed = CombatView.BASE_SPEED;

    CombatView.prototype.pauseTime = CombatView.BASE_PAUSE;

    CombatView.prototype.isFiring = false;

    CombatView.prototype.isParalyzed = false;

    CombatView.prototype.strategy = null;

    return CombatView;

  }).call(this);

  // -----------------------------------------------------------------------------
  BasicStrategy = class BasicStrategy {
    constructor(combat) {
      this.getCastableSpells = this.getCastableSpells.bind(this);
      this.doTurn = this.doTurn.bind(this);
      // END
      this.reselect = this.reselect.bind(this);
      this.moveTowards = this.moveTowards.bind(this);
      this.combat = combat;
    }

    getCastableSpells(me) {
      var casts, includeSelf, isFriendly, isHeal, isRange, l, len, result, spell, spellInfo, spells, target, targets;
      spells = me.entity.template.spells;
      casts = [];
      if (spells) {
        for (l = 0, len = spells.length; l < len; l++) {
          spellInfo = spells[l];
          spell = Library.getSpellByName(spellInfo.name);
          if (spell.type === "summon") {
            if (this.combat.canSummon(me)) {
              result = {
                "spell": spell,
                "weight": spellInfo.weight,
                "targets": null
              };
              casts.push(result);
            }
          } else {
            isHeal = spell.type === "heal";
            isFriendly = spell.type === "heal" || spell.type === "enhance" || spell.type === "teleport";
            isRange = spell.target === "area" || spell.target === "range";
            includeSelf = spell.type === "heal" || spell.type === "teleport";
            if (spell.target === "self") {
              if (this.combat.canTargetWithSpell(me, me, isFriendly, isHeal, spell.effect)) {
                targets = [me];
              } else {
                targets = [];
              }
            } else if (spell.target === "area") {
              target = this.combat.getBestAreaTarget(me, !isFriendly);
              if (target) {
                targets = [target];
              }
            } else {
              targets = this.combat.getSpellTargets(me, isRange, isFriendly, isHeal);
            }
            if (targets.length > 0) {
              result = {
                "spell": spell,
                "weight": spellInfo.weight,
                "targets": targets
              };
              casts.push(result);
            }
          }
        }
      }
      return casts;
    }

    doTurn(me, numMoves, numAttacks) {
      var attackWeight, canAttackArea, canAttackMelee, canAttackRange, cast, casts, couldCast, destination, didAction, enemy, f, g, k, l, len, len1, moveWeight, nearest, o, ref, ref1, ref2, spell, target, totalWeight;
      this.combat.clearSelection();
      this.combat.usingItem = null;
      //# Get all castable spells (if any)
      casts = this.getCastableSpells(me);
      canAttackMelee = this.combat.canAttackMelee(me);
      canAttackRange = me.canAttackRange();
      canAttackArea = me.canAttackArea();
      if (canAttackMelee) {
        moveWeight = 0;
        attackWeight = (ref = me.entity.template.attackWeight) != null ? ref : 75;
      } else {
        moveWeight = (ref1 = me.entity.template.moveWeight) != null ? ref1 : 25;
        if (canAttackRange) {
          attackWeight = (ref2 = me.entity.template.attackWeight) != null ? ref2 : 75;
        } else {
          attackWeight = 0;
        }
      }
      if (numAttacks === 0) {
        attackWeight = 0;
      }
      if (numMoves === 0) {
        moveWeight = 0;
      }
      totalWeight = attackWeight + moveWeight;
      for (l = 0, len = casts.length; l < len; l++) {
        cast = casts[l];
        totalWeight += cast.weight;
      }
      k = Util.random(0, totalWeight - 1);
      didAction = false;
      if (k < attackWeight) {
        if (canAttackArea) {
          target = this.combat.getBestAreaTarget(me, true);
          if (target) {
            numMoves = 0;
            numAttacks--;
            me.didAttack = true;
            this.combat.setTarget(target);
            this.combat.queueFly(me.x, me.y, target.x, target.y, me.getRangeAnimation(), "AI Area Projectile Fly");
            this.combat.addAction(this.combat.doAreaAttack, "Run AI Area Attack");
            didAction = true;
          }
        } else {
          nearest = this.combat.getNearestAttackTarget(me);
          if (me.lastTarget && this.combat.isStillAlive(me.lastTarget) && this.combat.canAttack(me, me.lastTarget)) {
            target = me.lastTarget;
          } else {
            if (canAttackRange) {
              target = this.combat.getRandomEnemy(me);
            } else {
              target = this.combat.getNearestAttackTarget(me);
            }
          }
          if (this.combat.isInMeleeRange(me, nearest) && !this.combat.isInMeleeRange(me, target)) {
            target = nearest;
          }
          me.lastTarget = target;
          // Can't move after attacking
          numMoves = 0;
          numAttacks--;
          me.didAttack = true;
          this.combat.setTarget(target);
          if (canAttackMelee) {
            this.combat.addAction(this.combat.runAttack, "Run AI Melee Attack");
          } else if (canAttackRange) {
            this.combat.queueFly(me.x, me.y, target.x, target.y, me.getRangeAnimation(), "AI Projectile Fly");
            this.combat.addAction(this.combat.runAttack, "Run AI Range Attack");
          }
          didAction = true;
        }
      } else {
        k -= attackWeight;
      }
      if (!didAction && k < moveWeight) {
        target = this.combat.getNearestEnemy(me);
        numMoves--;
        if (numMoves === 0) {
          numAttacks = 0;
        }
        f = () => {
          return this.moveTowards(me, target);
        };
        this.combat.addAction(f, "Do Move");
        didAction = true;
      } else {
        k -= moveWeight;
      }
      if (!didAction) {
        for (o = 0, len1 = casts.length; o < len1; o++) {
          cast = casts[o];
          if (!didAction && k < cast.weight) {
            couldCast = true;
            spell = cast.spell;
            this.combat.castingSpell = spell;
            if (spell.type === "summon") {
              target = this.combat.getSuggestedSummonSquare(me);
              if (target !== null) {
                this.combat.targetX = target.x;
                this.combat.targetY = target.y;
              }
            } else {
              target = Util.randomElement(cast.targets);
              if (spell.type === "teleport") {
                enemy = this.combat.getRandomEnemy(me);
                destination = this.combat.getSuggestedSummonSquare(enemy);
                if (destination === null) {
                  destination = this.combat.getRandomSquare();
                  if (destination === null) {
                    couldCast = false;
                  }
                }
                if (destination !== null) {
                  this.combat.teleportTarget = target;
                  this.combat.targetX = destination.x;
                  this.combat.targetY = destination.y;
                }
              } else {
                this.combat.targetX = target.x;
                this.combat.targetY = target.y;
              }
            }
            if (couldCast) {
              this.combat.addSound("spell", "AI Cast Sound");
              this.combat.queueAnimation(me.x, me.y, Data.icons.animSpellCast, "Enemy Cast Animation");
              if (spell.target === "range" || spell.target === "area") {
                this.combat.queueFly(me.x, me.y, target.x, target.y, spell.animation, "Enemy Spell Range Animation");
              }
              if (spell.fast) {
                if (me.halfAttack) {
                  numMoves = 0;
                  numAttacks--;
                  me.halfAttack = false;
                } else {
                  me.halfAttack = true;
                }
              } else {
                numMoves = 0;
                numAttacks--;
              }
              this.combat.selectMode = CombatView.SELECT_TARGETED;
              f = () => {
                return this.combat.doSpellResult();
              };
              this.combat.addAction(f, "Do Enemy Spell Result");
              didAction = true;
            }
          } else {
            k -= cast.weight;
          }
        }
      }
      if (!didAction) {
        numMoves = 0;
        numAttacks = 0;
      }
      if (numMoves === 0 && numAttacks === 0) {
        this.combat.endTurn();
      } else {
        g = () => {
          return this.reselect(me);
        };
        this.combat.addAction(g, "AI Reselect");
        this.combat.addPause("AI Action Pause");
        f = () => {
          return this.doTurn(me, numMoves, numAttacks);
        };
        this.combat.addAction(f, "AI Turn Continuation");
      }
    }

    reselect(me) {
      return this.combat.select(me.x, me.y, CombatView.SELECT_ACTIVE);
    }

    moveTowards(me, target) {
      var dx, dy, moved, sx, sy;
      dx = target.x - me.x;
      dy = target.y - me.y;
      sx = dx > 0 ? 1 : dx < 0 ? -1 : 0;
      sy = dy > 0 ? 1 : dy < 0 ? -1 : 0;
      moved = false;
      if (Math.abs(dy) >= Math.abs(dx)) {
        if (this.combat.isClear(me.x, me.y + sy)) {
          this.combat.moveCombatant(me.x, me.y, me.x, me.y + sy);
          moved = true;
        } else if (this.combat.isClear(me.x + sx, me.y)) {
          this.combat.moveCombatant(me.x, me.y, me.x + sx, me.y);
          moved = true;
        }
      } else {
        if (this.combat.isClear(me.x + sx, me.y)) {
          this.combat.moveCombatant(me.x, me.y, me.x + sx, me.y);
          moved = true;
        } else if (this.combat.isClear(me.x, me.y + sy)) {
          this.combat.moveCombatant(me.x, me.y, me.x, me.y + sy);
          moved = true;
        }
      }
      if (moved) {
        this.combat.addSound("move", "AI Move Sound");
      }
      return this.combat.draw();
    }

  };

  Test = class Test {
    static assert(condition, failDescription) {
      if (!condition) {
        return console.log("ASSERTION FAILED: " + failDescription);
      }
    }

    static run() {
      var damage, leatherArmor, rugnar, shortSword, shortSwordTemplate;
      console.log("--- TESTING START ---");
      shortSwordTemplate = Library.getItemTemplateByName("Short Sword");
      Test.assert(shortSwordTemplate, "Short sword template not found by name");
      shortSword = new Item(shortSwordTemplate, 100, 2);
      Test.assert(shortSword.name === "Short Sword +2", "Short Sword name is wrong.");
      Test.assert(shortSword.getMeleeMinDamage() === 3, "Short Sword melee min damage is wrong.");
      Test.assert(shortSword.getMeleeMaxDamage() === 7, "Short Sword melee max damage is wrong.");
      Test.assert(shortSword.getToHitBonus() === 2, "Short Sword to hit bonus is wrong.");
      Test.assert(shortSword.getArmorClass() === 0, "Short Sword should have 0 AC.");
      leatherArmor = new Item(Library.getItemTemplateByName("Leather Armor"), 101, -1);
      Test.assert(leatherArmor.getArmorClass() === 1, "Leather Armor -1 should have 1 AC");
      rugnar = new Player(Data.characters[0]);
      Test.assert(rugnar.strength >= rugnar.accuracy, "Strength is not greatest attribute.");
      Test.assert(rugnar.strength >= rugnar.awareness, "Strength is not greatest attribute.");
      Test.assert(rugnar.strength >= rugnar.constitution, "Strength is not greatest attribute.");
      Test.assert(rugnar.maxHitPoints > 0, "Max hit points not positive.");
      Test.assert(rugnar.hitPoints === rugnar.maxHitPoints, "Hit points not equal to max hit points.");
      rugnar.strength = 18;
      Test.assert(rugnar.getAttributeBonus(rugnar.strength) === 3, "Strength bonus incorrect.");
      damage = rugnar.getMeleeDamageBounds();
      Test.assert(damage.min === 1 + 3, "Min damage is wrong");
      Test.assert(damage.max === 1 + 3, "Max damage is wrong");
      rugnar.addItem(shortSword);
      rugnar.equipItem(shortSword);
      damage = rugnar.getMeleeDamageBounds();
      Test.assert(damage.min === 1 + 2 + 3, "Min damage is wrong");
      Test.assert(damage.max === 5 + 2 + 3, "Max damage is wrong");
      rugnar.addItem(leatherArmor);
      rugnar.equipItem(leatherArmor);
      rugnar.awareness = 14;
      Test.assert(rugnar.getArmorClass() === 1 + 1, "Rugnar armor class is wrong.");
      rugnar.unequipItem(leatherArmor);
      Test.assert(rugnar.getArmorClass() === 0 + 1, "Rugnar armor class is wrong after unequip.");
      rugnar.dropItem(leatherArmor);
      Test.assert(rugnar.items.length === 1, "Rugnar should have 1 item.");
      return console.log("--- TESTING COMPLETED ---");
    }

  };

  // -----------------------------------------------------------------------------
  Validate = class Validate {
    static require(object, item, name) {
      if (!object.hasOwnProperty(item)) {
        return console.log(`${name} is missing '${item}'.`);
      }
    }

    static run() {
      var creature, feature, i1, idSet, item, l, len, len1, len2, len3, len4, len5, len6, len7, location, locationSet, map, name, o, p, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s, spell, spellSet, target, u, z;
      console.log("--- VALIDATING ...");
      console.log("-- SPELLS");
      ref = Data.spells;
      for (l = 0, len = ref.length; l < len; l++) {
        spell = ref[l];
        if (spell.type === "summon") {
          if (!spell.creature) {
            console.log(` No creature for summon spell ${spell.name}.`);
          } else if (!Library.getCreatureByName(spell.creature)) {
            console.log(` Creature for summon spell ${spell.name} not found: '${spell.creature}'.`);
          }
        }
        if ((spell.target === "range" || spell.target === "area") && !spell.animation) {
          console.log(` Animation missing for spell ${spell.name}`);
        }
      }
      console.log("-- CREATURES");
      spellSet = {};
      ref1 = Data.creatures;
      for (o = 0, len1 = ref1.length; o < len1; o++) {
        creature = ref1[o];
        Validate.require(creature, "icon", creature.name);
        Validate.require(creature, "groups", creature.name);
        Validate.require(creature, "meleeMinDamage", creature.name);
        Validate.require(creature, "meleeMaxDamage", creature.name);
        Validate.require(creature, "level", creature.name);
        Validate.require(creature, "minHitPoints", creature.name);
        Validate.require(creature, "maxHitPoints", creature.name);
        Validate.require(creature, "experienceValue", creature.name);
        Validate.require(creature, "numAttacks", creature.name);
        Validate.require(creature, "numMoves", creature.name);
        Validate.require(creature, "armorClass", creature.name);
        Validate.require(creature, "description", creature.name);
        if (creature.rangeMinDamage && !creature.rangeAnimation) {
          console.log(` No range animation for ${creature.name}.`);
        }
        if (creature.hitSpell && !Library.getSpellByName(creature.hitSpell)) {
          console.log(` Missing hit spell ${creature.hitSpell} for ${creature.name}.`);
        }
        if (creature.hitSpell) {
          spellSet[creature.hitSpell] = true;
        }
        if (creature.spells) {
          ref2 = creature.spells;
          for (p = 0, len2 = ref2.length; p < len2; p++) {
            spell = ref2[p];
            if (!Library.getSpellByName(spell.name)) {
              console.log(` Missing spell ${spell.name} for ${creature.name}.`);
            } else {
              spellSet[spell.name] = true;
            }
          }
        }
      }
      console.log("-- ITEMS");
      ref3 = Data.items;
      for (q = 0, len3 = ref3.length; q < len3; q++) {
        item = ref3[q];
        Validate.require(item, "icon", item.name);
        Validate.require(item, "type", item.name);
        Validate.require(item, "groups", item.name);
        Validate.require(item, "rarity", item.name);
        Validate.require(item, "baseValue", item.name);
        Validate.require(item, "level", item.name);
        Validate.require(item, "usedBy", item.name);
        if (item.rangeMinDamage && !item.rangeAnimation) {
          console.log(` No range animation for ${item.name}.`);
        }
        if (item.spell && !Library.getSpellByName(item.spell)) {
          console.log(` Missing spell ${item.spell} for ${item.name}.`);
        }
        if (item.hitSpell && !Library.getSpellByName(item.hitSpell)) {
          console.log(` Missing hit spell ${item.hitSpell} for ${item.name}.`);
        }
        if (item.combatSpell && !Library.getSpellByName(item.combatSpell)) {
          console.log(` Missing combat spell ${item.combatSpell} for ${item.name}.`);
        }
        if (item.spell) {
          spellSet[item.spell] = true;
        }
        if (item.hitSpell) {
          spellSet[item.hitSpell] = true;
        }
        if (item.combatSpell) {
          spellSet[item.combatSpell] = true;
        }
      }
      console.log("-- MAPS");
      idSet = {};
      locationSet = {};
      ref4 = Data.maps;
      for (name in ref4) {
        map = ref4[name];
        if (map.encounterChance && map.encounterChance > 0 && !map.combatMap) {
          console.log(` Missing combat map for ${name}.`);
        }
        if (map.features) {
          ref5 = map.features;
          for (s = 0, len4 = ref5.length; s < len4; s++) {
            feature = ref5[s];
            if (feature.type === "transition") {
              if (!feature.target) {
                console.log(` Missing transition target in ${name}.`);
              } else if (!Data.maps[feature.target]) {
                console.log(` Transition target ${feature.target} not found in ${name}.`);
              } else {
                target = Data.maps[feature.target];
                if (feature.targetX >= target.width || feature.targetY >= target.height) {
                  console.log(` Transition target location is not valid in ${feature.target} for ${name}.`);
                }
              }
            } else if (feature.type === "encounter") {
              location = name + "-" + feature.x + "-" + feature.y;
              if (locationSet[location]) {
                console.log(` More than one encounter at '${name} : ${feature.x}, ${feature.y}'.`);
              } else {
                locationSet[location] = true;
              }
              if (idSet[feature.id]) {
                console.log(` More than one encounter with id '${feature.id}'.`);
              } else {
                idSet[feature.id] = true;
              }
              if (feature.creatures) {
                ref6 = feature.creatures;
                for (u = 0, len5 = ref6.length; u < len5; u++) {
                  creature = ref6[u];
                  if (!Library.getCreatureByName(creature.name)) {
                    console.log(` Creature ${creature.name} not found in ${name}.`);
                  }
                }
              }
              if (feature.items) {
                ref7 = feature.items;
                for (z = 0, len6 = ref7.length; z < len6; z++) {
                  item = ref7[z];
                  if (!Library.getItemTemplateByName(item.name)) {
                    console.log(` Item ${item.name} not found in ${name}.`);
                  }
                }
              }
            }
          }
        }
      }
      ref8 = Data.spells;
      for (i1 = 0, len7 = ref8.length; i1 < len7; i1++) {
        spell = ref8[i1];
        if (!spellSet[spell.name] && !spell.who) {
          console.log(` Unused spell: ${spell.name}`);
        }
      }
      return console.log("--- VALIDATION COMPLETE.");
    }

  };

  // -----------------------------------------------------------------------------
  SettingsView = class SettingsView extends SelectView {
    constructor(gurk) {
      super(gurk, "TOGGLE", "DONE");
      this.doLayout = this.doLayout.bind(this);
      this.itemSelected = this.itemSelected.bind(this);
    }

    doLayout() {
      var combatMusic, fast, music, sound, y;
      boundMethodCheck(this, SettingsView);
      this.clear();
      y = 3;
      this.addLabelCentered("Settings", "#FFF", 0, y, 128, Screen.FONT.fontHeight);
      y += 12;
      music = this.gurk.getMusicSetting() ? "ON" : "OFF";
      combatMusic = this.gurk.getCombatMusicSetting() ? "ON" : "OFF";
      sound = this.gurk.getSoundSetting() ? "ON" : "OFF";
      fast = this.gurk.getFastSetting() ? "ON" : "OFF";
      this.addOption(`Music is ${music}`, "#FFF", 8, y);
      y += 8;
      this.addOption(`Combat music is ${combatMusic}`, "#FFF", 8, y);
      y += 8;
      this.addOption(`Sound FX are ${sound}`, "#FFF", 8, y);
      y += 8;
      this.addOption(`Fast combat is ${fast}`, "#FFF", 8, y);
      return this.start();
    }

    itemSelected(index, item) {
      boundMethodCheck(this, SettingsView);
      if (index === 0) {
        this.gurk.setMusicSetting(!this.gurk.getMusicSetting());
      } else if (index === 1) {
        this.gurk.setCombatMusicSetting(!this.gurk.getCombatMusicSetting());
      } else if (index === 2) {
        this.gurk.setSoundSetting(!this.gurk.getSoundSetting());
      } else if (index === 3) {
        this.gurk.setFastSetting(!this.gurk.getFastSetting());
      }
      this.doLayout();
      return this.draw();
    }

  };

  Gurk = (function() {
    // -----------------------------------------------------------------------------
    class Gurk {
      startSavedGame() {
        var mapView;
        this.game = new Game();
        this.game.loadGame(Device.loadGame());
        mapView = new MapView(this);
        return this.setView(mapView);
      }

      getSoundSetting() {
        return Device.getSetting("sound", true);
      }

      setSoundSetting(value) {
        return Device.setSetting("sound", value);
      }

      getMusicSetting() {
        return Device.getSetting("music", true);
      }

      setMusicSetting(value) {
        Device.setSetting("music", value);
        if (value) {
          return this.resumeMusic();
        } else {
          return this.stopMusic();
        }
      }

      getCombatMusicSetting() {
        return Device.getSetting("combatMusic", true);
      }

      setCombatMusicSetting(value) {
        return Device.setSetting("combatMusic", value);
      }

      getFastSetting() {
        return Device.getSetting("fast", false);
      }

      setFastSetting(value) {
        return Device.setSetting("fast", value);
      }

      startNewGame(game) {
        var mapView;
        this.game = game;
        mapView = new MapView(this);
        return this.setView(mapView);
      }

      playSound(sound) {
        if (this.getSoundSetting()) {
          return playAudio(sound);
        }
      }

      playMusic(track) {
        this.music = track;
        console.log("Music setting: '" + this.getMusicSetting() + "'.");
        if (this.getMusicSetting()) {
          console.log("Play track '" + track + "'.");
          return playTrack(track);
        }
      }

      playCombatMusic() {
        if (this.getCombatMusicSetting()) {
          return playTrack(Data.combatMusic);
        }
      }

      stopMusic() {
        return stopTrack();
      }

      resumeMusic() {
        if (this.music) {
          return this.playMusic(this.music);
        }
      }

      start() {
        var canvasWork, clickHandler, ctx, ctxControl, ctxWork, splashView;
        // @playSound("summon")
        console.log("Get contexts");
        ctx = document.getElementById("screenID").getContext("2d");
        ctxControl = document.getElementById("controlID").getContext("2d");
        canvasWork = document.getElementById("workID");
        ctxWork = canvasWork.getContext("2d");
        this.stack = new Array();
        this.screen = new Screen(ctx);
        this.buttonGrid = new ButtonGrid(ctxControl, this);
        this.imageProcessor = new ImageProcessor(canvasWork, ctxWork, this.screen.icons);
        // @imageProcessor.shade(Data.icons.ship)
        splashView = new SplashView(this);
        this.setView(splashView);
        console.log("Set splash view");
        this.playMusic(Data.splashMusic);
        //    touchstart = (e) =>
        //      @buttonGrid.clicked(document.getElementById("controlID").relMouseCoords(e))
        //    document.getElementById("controlID").addEventListener("touchstart", touchstart, false);

        // ENABLE THE TWO LINES BELOW FOR WEB CLICKS
        //    document.getElementById("controlID").onclick = (e) =>
        //      @buttonGrid.clicked(document.getElementById("controlID").relMouseCoords(e))
        clickHandler = (e) => {
          switch (e.keyCode) {
            case 37:
              return this.buttonGrid.forceClick(4);
            case 38:
              return this.buttonGrid.forceClick(2);
            case 39:
              return this.buttonGrid.forceClick(6);
            case 40:
              return this.buttonGrid.forceClick(8);
            case 13:
              return this.buttonGrid.forceClick(5); // Enter
            case 81:
              return this.buttonGrid.forceClick(1); // Q
            case 87:
              return this.buttonGrid.forceClick(2); // W
            case 69:
              return this.buttonGrid.forceClick(3); // E
            case 65:
              return this.buttonGrid.forceClick(4); // A
            case 83:
              return this.buttonGrid.forceClick(5); // S
            case 68:
              return this.buttonGrid.forceClick(6); // D
            case 90:
              return this.buttonGrid.forceClick(7); // Z
            case 88:
              return this.buttonGrid.forceClick(8); // X
            case 67:
              return this.buttonGrid.forceClick(9); // C
            case 96:
              return this.buttonGrid.forceClick(5); // Num Pad 0
            case 97:
              return this.buttonGrid.forceClick(7); // Num Pad 1
            case 98:
              return this.buttonGrid.forceClick(8); // Num Pad 2
            case 99:
              return this.buttonGrid.forceClick(9); // Num Pad 3
            case 100:
              return this.buttonGrid.forceClick(4); // Num Pad 4
            case 101:
              return this.buttonGrid.forceClick(5); // Num Pad 5
            case 102:
              return this.buttonGrid.forceClick(6); // Num Pad 6
            case 103:
              return this.buttonGrid.forceClick(1); // Num Pad 7
            case 104:
              return this.buttonGrid.forceClick(2); // Num Pad 8
            case 105:
              return this.buttonGrid.forceClick(3); // Num Pad 9
            case 71:
              return this.view.processResult("debug1"); // Debug hook 1
            case 72:
              return this.view.processResult("debug2"); // Debug hook 2
          }
        };
        // todo - maybe add ESC -> 9 and BACKSPACE -> 7
        window.addEventListener('keydown', clickHandler);
        return this.buttonGrid.draw();
      }

      // Test.run()
      phoneClick(e, offsetX = 0, offsetY = 0) {
        var point;
        point = document.getElementById("controlID").relMouseCoords(e);
        point.x -= offsetX;
        point.y -= offsetY;
        return this.buttonGrid.clicked(point);
      }

      constructor() {
        this.startSavedGame = this.startSavedGame.bind(this);
        this.getSoundSetting = this.getSoundSetting.bind(this);
        this.setSoundSetting = this.setSoundSetting.bind(this);
        this.getMusicSetting = this.getMusicSetting.bind(this);
        this.setMusicSetting = this.setMusicSetting.bind(this);
        this.getCombatMusicSetting = this.getCombatMusicSetting.bind(this);
        this.setCombatMusicSetting = this.setCombatMusicSetting.bind(this);
        this.getFastSetting = this.getFastSetting.bind(this);
        this.setFastSetting = this.setFastSetting.bind(this);
        this.startNewGame = this.startNewGame.bind(this);
        this.playSound = this.playSound.bind(this);
        this.playMusic = this.playMusic.bind(this);
        this.playCombatMusic = this.playCombatMusic.bind(this);
        this.stopMusic = this.stopMusic.bind(this);
        this.resumeMusic = this.resumeMusic.bind(this);
        this.start = this.start.bind(this);
        this.phoneClick = this.phoneClick.bind(this);
        this.getScreen = this.getScreen.bind(this);
        this.setView = this.setView.bind(this);
        this.showSettings = this.showSettings.bind(this);
        this.showView = this.showView.bind(this);
        this.pushView = this.pushView.bind(this);
        this.popView = this.popView.bind(this);
        this.swapView = this.swapView.bind(this);
        this.popToTopView = this.popToTopView.bind(this);
        this.buttonPressed = this.buttonPressed.bind(this);
        this.showAlert = this.showAlert.bind(this);
        this.showConfirm = this.showConfirm.bind(this);
        this.isCurrentView = this.isCurrentView.bind(this);
        // Get all the images in here
        //Screen.SCALE = 4
        console.log(`Preloading..., scale is ${Screen.SCALE}`);
        // Preloader.reset()
        Preloader.load("img/icons0-" + Screen.SCALE + ".png");
        Preloader.load("img/icons1-" + Screen.SCALE + ".png");
        Preloader.load("img/screen" + Screen.SCALE + ".png");
        Preloader.load("img/font_micro" + Screen.SCALE + ".png");
        Preloader.load("img/font_gurkoid" + Screen.SCALE + ".png");
        Preloader.load("img/button" + Screen.SCALE + ".png");
        Preloader.load("img/buttonoff" + Screen.SCALE + ".png");
        Preloader.load("img/buttontop" + Screen.SCALE + ".png");
        Preloader.load("img/shadow" + Screen.SCALE + ".png");
        console.log("Preloading started...");
        // End images
        Preloader.setCallback(this.start);
      }

      getScreen() {
        return this.screen;
      }

      setView(view) {
        console.log("Set View: " + view);
        this.stack = new Array();
        this.view = view;
        return this.showView();
      }

      showSettings() {
        return this.pushView(new SettingsView(this));
      }

      showView() {
        console.log(`View: ${this.view.name}`);
        this.view.doLayout();
        this.view.setButtons(this.buttonGrid);
        return this.view.draw();
      }

      pushView(view) {
        this.stack.unshift(this.view);
        this.view = view;
        return this.showView();
      }

      popView(result) {
        var parent;
        parent = this.stack.shift();
        if (parent !== null) {
          this.view = parent;
          if (result !== null) {
            this.view.processResult(result);
          }
          return this.showView();
        }
      }

      swapView(result) {
        this.view = view;
        if (result !== null) {
          this.view.processResult(result);
        }
        return this.showView();
      }

      popToTopView(result) {
        if (this.stack.length > 0) {
          this.view = this.stack.shift();
          while (this.stack.length > 0) {
            this.view = this.stack.shift();
          }
          if (result !== null) {
            this.view.processResult(result);
          }
          return this.showView();
        }
      }

      buttonPressed(text) {
        return this.view.command(text);
      }

      showAlert(icon, title, text, result) {
        var alert;
        alert = new AlertView(this, icon, title, text, result);
        return this.pushView(alert);
      }

      showConfirm(icon, title, text, yesResult, noResult) {
        var confirm;
        confirm = new ConfirmView(this, icon, title, text, yesResult, noResult);
        return this.pushView(confirm);
      }

      isCurrentView(view) {
        return this.view === view;
      }

    };

    Gurk.prototype.stack = null;

    Gurk.prototype.view = null;

    Gurk.prototype.screen = null;

    Gurk.prototype.buttonGrid = null;

    Gurk.prototype.game = null;

    Gurk.prototype.imageProcessor = null;

    Gurk.prototype.music = null;

    return Gurk;

  }).call(this);

  // -----------------------------------------------------------------------------
  App = {};

  window.App = App;

  App.init = function(platform) {
    console.log('App init...');
    
  /*
  function relMouseCoords(event){
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var canvasX = 0;
    var canvasY = 0;
    var currentElement = this;

    do{
        totalOffsetX += currentElement.offsetLeft;
        totalOffsetY += currentElement.offsetTop;
    }
    while(currentElement = currentElement.offsetParent)

    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;

    return {x:canvasX, y:canvasY}
  }
  */
  function relMouseCoords(event) {
    //console.log("event.pageY: " + event.pageY + ", this.offsetTop: " + this.offsetTop);
    var x;
    var y;
    if ("ios" == platform) {
      x = event.pageX * 2 - this.offsetLeft;
      y = event.pageY * 2 - this.offsetTop;
    } else {
      x = event.pageX - this.offsetLeft;
      y = event.pageY - this.offsetTop;
    }
    return {"x":x, "y":y};
  }
  HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;;
    console.log('Starting E.B.U.R.P...');
    return App.gurk = new Gurk();
  };

}).call(this);
